Index: adminBackend/Routes/mainRoutes.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import express from 'express';\r\nimport upload from \"../middlewares/upload.js\";\r\nimport db from '../utils/db.js';\r\n\r\nconst router = express.Router();\r\n\r\n// Save  new item\r\nrouter.post(\"/add-item\", upload.fields([{ name: \"img\", maxCount: 1 }, { name: \"img1\", maxCount: 1 }, { name: \"img2\", maxCount: 1 }, { name: \"img3\", maxCount: 1 }]), async (req, res) => {\r\n    try {\r\n        // Validate request body\r\n        const { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost ,material,s_Id } = req.body;\r\n        // Convert data to appropriate types\r\n        const parsedPrice = parseFloat(price) || 0;\r\n        const parsedCost = parseFloat(cost) || 0;\r\n\r\n        // Extract image buffers\r\n        const imgBuffer = req.files[\"img\"][0].buffer;\r\n        const img1Buffer = req.files[\"img1\"][0].buffer;\r\n        const img2Buffer = req.files[\"img2\"][0].buffer ;\r\n        const img3Buffer = req.files[\"img3\"][0].buffer;\r\n\r\n        const itemValues = [\r\n            I_Id, I_name, Ty_id, descrip, color,material, parsedPrice, imgBuffer, warrantyPeriod\r\n        ];\r\n        const imgValues = [\r\n            I_Id, img1Buffer ? Buffer.from(img1Buffer) : null, img2Buffer ? Buffer.from(img2Buffer) : null, img3Buffer ? Buffer.from(img3Buffer) : null\r\n        ];\r\n        const supplierValues = [\r\n            I_Id, s_Id,parsedCost\r\n        ];\r\n        // Insert into `Item` table (Main image)\r\n        const itemSql = `INSERT INTO Item (I_Id, I_name, Ty_id, descrip, color,material, price, stockQty, bookedQty, availableQty, img, warrantyPeriod) \r\n                         VALUES (?, ?, ?, ?, ?,?,?, 0, 0, 0, ?, ?);`;\r\n\r\n        const query = await db.query(itemSql, itemValues);\r\n        console.log(\"query\");\r\n\r\n        // Insert into `Item_img` table (Additional images)\r\n        const imgSql = `INSERT INTO Item_img (I_Id, img1, img2, img3) VALUES (?, ?, ?, ?);`;\r\n\r\n        const query1 = await db.query(imgSql, imgValues);\r\n        console.log(\"query1\");\r\n\r\n        // Insert into `Item_supplier` table\r\n        const itemsuplierSql = `INSERT INTO item_supplier (I_Id, s_ID,unit_cost) VALUES (?, ?,?);`;\r\n\r\n        const query2 = await db.query(itemsuplierSql, supplierValues);\r\n        console.log(\"query2\");\r\n\r\n        res.status(201).json({\r\n            success: true,\r\n            message: \"Item added successfully\",\r\n            data: {\r\n                I_Id,\r\n                I_name,\r\n                Ty_id: Ty_id,\r\n                descrip,\r\n                color,\r\n                material,\r\n                price: parsedPrice,\r\n                warrantyPeriod,\r\n                cost: parsedCost\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"❌ Error inserting item data:\", err.message);\r\n        res.status(500).json({ success: false, message: \"Error inserting data into database\", details: err.message });\r\n    }\r\n});\r\n\r\n// Update exit item\r\n// router.put(\"/update-item\", upload.fields([{ name: \"img\", maxCount: 1 }, { name: \"img1\", maxCount: 1 }, { name: \"img2\", maxCount: 1 }, { name: \"img3\", maxCount: 1 }]), async (req, res) => {\r\n//     try {\r\n//         // Extract request body and parse incoming form data\r\n//         const { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty  } = req.body;\r\n//\r\n//         // Parse price and cost fields to float\r\n//         const parsedPrice = parseFloat(price) || 0;\r\n//         const parsedCost = parseFloat(cost) || 0;\r\n//\r\n//          // console.log(\"\uD83D\uDD39 Request Data:\", { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty });\r\n//\r\n//         // Ensure I_Id exists in the database\r\n//         const itemCheckSql = `SELECT * FROM Item WHERE I_Id = ?`;\r\n//         const [itemCheckResult] = await db.query(itemCheckSql, [I_Id]);\r\n//\r\n//         if (itemCheckResult.length === 0) {\r\n//             return res.status(404).json({ success: false, message: \"Item not found.\" });\r\n//         }\r\n//\r\n//         // Handle image files, if any\r\n//         // const imgBuffer = req.files[\"img\"]?.[0]?.buffer || null;\r\n//         // const img1Buffer = req.files[\"img1\"]?.[0]?.buffer || null;\r\n//         // const img2Buffer = req.files[\"img2\"]?.[0]?.buffer || null;\r\n//         // const img3Buffer = req.files[\"img3\"]?.[0]?.buffer || null;\r\n//         const imgBuffer = req.files[\"img\"][0].buffer;\r\n//         const img1Buffer = req.files[\"img1\"][0].buffer;\r\n//         const img2Buffer = req.files[\"img2\"][0].buffer ;\r\n//         const img3Buffer = req.files[\"img3\"][0].buffer;\r\n//\r\n//         console.log(imgBuffer,img1Buffer,img2Buffer,img3Buffer);\r\n//\r\n//         // Update `Item` table with regular fields\r\n//         const itemUpdateSql = `\r\n//             UPDATE Item\r\n//             SET I_name = ?, Ty_id = ?, descrip = ?, color = ?, material = ?, price = ?, availableQty = ?, bookedQty = ?, stockQty = ?, img = ?, warrantyPeriod = ?\r\n//             WHERE I_Id = ?;\r\n//         `;\r\n//         const itemValues = [\r\n//             I_name, Ty_id, descrip, color, material, parsedPrice, availableQty, bookedQty, stockQty, imgBuffer, warrantyPeriod, I_Id\r\n//         ];\r\n//         // console.log(itemValues);\r\n//         // await db.query(itemUpdateSql, itemValues);\r\n//         // **Handle Suppliers (Array of suppliers from formData)**\r\n//         if (suppliers && Array.isArray(suppliers)) {\r\n//             console.log(\"pass\");\r\n//             for (const supplier of suppliers) {\r\n//\r\n//                 const { s_ID, unit_cost } = supplier;\r\n//                 console.log(supplier);\r\n//                 const parsedUnitCost = parseFloat(unit_cost) || 0;\r\n//\r\n//                 // Update or insert supplier cost data\r\n//                 const supplierUpdateSql = `\r\n//                     INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n//                     VALUES (?, ?, ?)\r\n//                     ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost);\r\n//                 `;\r\n//                 const supplierValues = [\r\n//                     I_Id, s_ID, parsedUnitCost\r\n//                 ];\r\n//                 console.log(supplierValues);\r\n//                 // await db.query(supplierUpdateSql, supplierValues);\r\n//             }\r\n//         }\r\n//\r\n//         // Handle image updates for `Item_img` table (if any images are provided)\r\n//         if (img1Buffer || img2Buffer || img3Buffer) {\r\n//             const imgUpdateSql = `\r\n//                 UPDATE Item_img\r\n//                 SET img1 = ?, img2 = ?, img3 = ?\r\n//                 WHERE I_Id = ?;\r\n//             `;\r\n//             const imgValues = [\r\n//                 img1Buffer, img2Buffer, img3Buffer, I_Id\r\n//             ];\r\n//              console.log(imgValues);\r\n//             // await db.query(imgUpdateSql, imgValues);\r\n//         }\r\n//\r\n//\r\n//\r\n//         // Respond with success\r\n//         res.status(200).json({\r\n//             success: true,\r\n//             message: \"Item updated successfully\",\r\n//             data: {\r\n//                 I_Id,\r\n//                 I_name,\r\n//                 Ty_id,\r\n//                 descrip,\r\n//                 color,\r\n//                 material,\r\n//                 price: parsedPrice,\r\n//                 warrantyPeriod,\r\n//                 availableQty,\r\n//                 bookedQty,\r\n//                 stockQty\r\n//             }\r\n//         });\r\n//\r\n//     } catch (err) {\r\n//         console.error(\"❌ Error updating item data:\", err.message);\r\n//         res.status(500).json({ success: false, message: \"Error updating data into database\", details: err.message });\r\n//     }\r\n// });\r\nrouter.put(\"/update-item\",  async (req, res) => {\r\n    try {\r\n        // Extract request body and parse incoming form data\r\n        const { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty  } = req.body;\r\n\r\n        // Parse price and cost fields to float\r\n        const parsedPrice = parseFloat(price) || 0;\r\n        const parsedCost = parseFloat(cost) || 0;\r\n\r\n         console.log(\"\uD83D\uDD39 Request Data:\", { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty });\r\n\r\n        // Ensure I_Id exists in the database\r\n        const itemCheckSql = `SELECT * FROM Item WHERE I_Id = ?`;\r\n        const [itemCheckResult] = await db.query(itemCheckSql, [I_Id]);\r\n\r\n        if (itemCheckResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found.\" });\r\n        }\r\n\r\n        // Handle image files, if any\r\n        // const imgBuffer = req.files[\"img\"]?.[0]?.buffer || null;\r\n        // const img1Buffer = req.files[\"img1\"]?.[0]?.buffer || null;\r\n        // const img2Buffer = req.files[\"img2\"]?.[0]?.buffer || null;\r\n        // const img3Buffer = req.files[\"img3\"]?.[0]?.buffer || null;\r\n        // const imgBuffer = req.files[\"img\"][0].buffer;\r\n        // const img1Buffer = req.files[\"img1\"][0].buffer;\r\n        // const img2Buffer = req.files[\"img2\"][0].buffer ;\r\n        // const img3Buffer = req.files[\"img3\"][0].buffer;\r\n\r\n        // console.log(imgBuffer,img1Buffer,img2Buffer,img3Buffer);\r\n\r\n        // Update `Item` table with regular fields\r\n        const itemUpdateSql = `\r\n            UPDATE Item\r\n            SET I_name = ?, Ty_id = ?, descrip = ?, color = ?, material = ?, price = ?, availableQty = ?, bookedQty = ?, stockQty = ?, img = ?, warrantyPeriod = ?\r\n            WHERE I_Id = ?;\r\n        `;\r\n        const itemValues = [\r\n            I_name, Ty_id, descrip, color, material, parsedPrice, availableQty, bookedQty, stockQty, imgBuffer, warrantyPeriod, I_Id\r\n        ];\r\n         console.log(itemValues);\r\n        // await db.query(itemUpdateSql, itemValues);\r\n        // **Handle Suppliers (Array of suppliers from formData)**\r\n        if (suppliers && Array.isArray(suppliers)) {\r\n            console.log(\"pass\");\r\n            for (const supplier of suppliers) {\r\n\r\n                const { s_ID, unit_cost } = supplier;\r\n                console.log(supplier);\r\n                const parsedUnitCost = parseFloat(unit_cost) || 0;\r\n\r\n                // Update or insert supplier cost data\r\n                const supplierUpdateSql = `\r\n                    INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n                    VALUES (?, ?, ?)\r\n                        ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost);\r\n                `;\r\n                const supplierValues = [\r\n                    I_Id, s_ID, parsedUnitCost\r\n                ];\r\n                console.log(supplierValues);\r\n                // await db.query(supplierUpdateSql, supplierValues);\r\n            }\r\n        }\r\n\r\n        // // Handle image updates for `Item_img` table (if any images are provided)\r\n        // if (img1Buffer || img2Buffer || img3Buffer) {\r\n        //     const imgUpdateSql = `\r\n        //         UPDATE Item_img\r\n        //         SET img1 = ?, img2 = ?, img3 = ?\r\n        //         WHERE I_Id = ?;\r\n        //     `;\r\n        //     const imgValues = [\r\n        //         img1Buffer, img2Buffer, img3Buffer, I_Id\r\n        //     ];\r\n        //     console.log(imgValues);\r\n        //     // await db.query(imgUpdateSql, imgValues);\r\n        // }\r\n\r\n\r\n\r\n        // Respond with success\r\n        res.status(200).json({\r\n            success: true,\r\n            message: \"Item updated successfully\",\r\n            data: {\r\n                I_Id,\r\n                I_name,\r\n                Ty_id,\r\n                descrip,\r\n                color,\r\n                material,\r\n                price: parsedPrice,\r\n                warrantyPeriod,\r\n                availableQty,\r\n                bookedQty,\r\n                stockQty\r\n            }\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"❌ Error updating item data:\", err.message);\r\n        res.status(500).json({ success: false, message: \"Error updating data into database\", details: err.message });\r\n    }\r\n});\r\n\r\n\r\n// Get all orders\r\nrouter.get(\"/orders\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all Orders\r\n        const [orders] = await db.query(\"SELECT * FROM Orders\");\r\n\r\n        // If no promotions found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Orders found\" });\r\n        }\r\n\r\n\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID : order.OrID, // Assuming you have an id column\r\n            orDate : order.orDate,\r\n            customerEmail : order.customerEmail,\r\n            ordertype : order.order_type,\r\n            orStatus : order.orStatus,\r\n            dvStatus : order.dvStatus,\r\n            dvPrice : order.dvPrice,\r\n            disPrice : order.disPrice,\r\n            totPrice : order.totPrice,\r\n            stID:  order.stID,\r\n            expectedDeliveryDate: order.expectedDate\r\n        }));\r\n        // console.log(formattedOrders);\r\n\r\n        // Send the formatted promotions as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Orders are founded.\",\r\n            data : formattedOrders,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching promotions:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching promotions\" });\r\n    }\r\n});\r\n\r\n// Get all items\r\nrouter.get(\"/allitems\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [items] = await db.query(\"SELECT * FROM Item\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (items.length === 0) {\r\n            return res.status(404).json({ message: \"No items found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedItems = items.map(item => ({\r\n            I_Id: item.I_Id, // Item ID\r\n            I_name: item.I_name, // Item name\r\n            Ty_id: item.Ty_id, // Type ID (foreign key)\r\n            descrip: item.descrip, // Item description\r\n            price: item.price, // Price\r\n            stockQty: item.stockQty, // Quantity\r\n            availableQty : item.availableQty, // available stock\r\n            warrantyPeriod: item.warrantyPeriod,\r\n            img: `data:image/png;base64,${item.img.toString(\"base64\")}`, // Convert LONGBLOB image to Base64\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedItems);\r\n    } catch (error) {\r\n        console.error(\"Error fetching items:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching items\" });\r\n    }\r\n});\r\n\r\n// Save Supplier\r\nrouter.post(\"/supplier\", async (req, res) => {\r\n    const sql = `INSERT INTO Supplier (s_ID,name,contact) VALUES (?, ?,?)`;\r\n    const values = [\r\n        req.body.s_ID,\r\n        req.body.name,\r\n        req.body.contact,\r\n    ];\r\n    try {\r\n        // Execute the query and retrieve the result\r\n        const [result] = await db.query(sql, values);\r\n\r\n        // Return success response with inserted data details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Suppplier added successfully\",\r\n            data: {\r\n                s_ID: req.body.s_ID,\r\n                name: req.body.name,\r\n                contact : req.body.contact\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting supplier data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get one accept order in-detail\r\nrouter.get(\"/accept-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info with Sales Team Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.contact1, o.contact2,\r\n                o.orStatus, o.dvStatus, o.dvPrice, o.disPrice, o.totPrice, o.order_type,\r\n                o.expectedDate, o.specialNote, s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items with Updated Stock Fields\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, od.qty, od.tprice, i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Booked Items\r\n        const bookedItemsQuery = `\r\n            SELECT bi.I_Id, i.I_name, bi.qty\r\n            FROM booked_item bi\r\n                     JOIN Item i ON bi.I_Id = i.I_Id\r\n            WHERE bi.orID = ?`;\r\n\r\n        const [bookedItemsResult] = await db.query(bookedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Fetch Accepted Orders\r\n        const acceptedOrdersQuery = `\r\n            SELECT ao.I_Id, i.I_name, ao.itemReceived, ao.status\r\n            FROM accept_orders ao\r\n                     JOIN Item i ON ao.I_Id = i.I_Id\r\n            WHERE ao.orID = ?`;\r\n\r\n        const [acceptedOrdersResult] = await db.query(acceptedOrdersQuery, [orID]);\r\n\r\n        // 5\uFE0F⃣ Initialize Response Object\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate: orderData.orDate,\r\n            customerEmail: orderData.customerEmail,\r\n            ordertype : orderData.order_type,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.dvStatus,\r\n            deliveryCharge: orderData.dvPrice,\r\n            discount: orderData.disPrice,\r\n            totalPrice: orderData.totPrice,\r\n            expectedDeliveryDate: orderData.expectedDate,\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty,\r\n                price: item.tprice,\r\n                unitPrice: item.unitPrice,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty // Updated field from Item table\r\n            })),\r\n            bookedItems: bookedItemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty\r\n            })),\r\n            acceptedOrders: acceptedOrdersResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                itemReceived: item.itemReceived,\r\n                status: item.status\r\n            }))\r\n        };\r\n\r\n        // 6\uFE0F⃣ Fetch Delivery Info If Order is for Delivery\r\n        if (orderData.dvStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, contact, status, schedule_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: deliveryData.schedule_Date,\r\n                };\r\n            }\r\n        }\r\n\r\n        // // 7\uFE0F⃣ If Order Status is \"Accepted\", Trigger Additional API Call (Optional)\r\n        // if (orderData.orStatus === \"Accepted\") {\r\n        //     // console.log(`Calling additional API for accepted order: ${orID}`);\r\n        //     // Add API call logic here if needed (e.g., send notification)\r\n        // }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get one order in-detail\r\nrouter.get(\"/order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // Fetch Order Info along with Sales Team details (Employee Name)\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.contact1, o.contact2, o.orStatus, o.dvStatus,\r\n                o.dvPrice, o.disPrice, o.totPrice, o.expectedDate, o.specialNote, o.order_type,\r\n                s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        const orderData = orderResult[0];\r\n\r\n        // Fetch Ordered Items with Updated Stock Fields\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, od.qty, od.tprice, i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty , i.stockQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // Prepare the order response\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate: orderData.orDate,\r\n            customerEmail: orderData.customerEmail,\r\n            ordertype : orderData.order_type,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.dvStatus,\r\n            deliveryCharge: orderData.dvPrice,\r\n            discount: orderData.disPrice,\r\n            totalPrice: orderData.totPrice,\r\n            expectedDeliveryDate: orderData.expectedDate,\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: []\r\n        };\r\n\r\n        // If order is \"Accepted\", fetch booked items and accept_orders\r\n        if (orderData.orStatus === \"Accepted\") {\r\n            for (const item of itemsResult) {\r\n                let itemReceived = \"No\";\r\n                let itemStatus = \"Incomplete\";\r\n\r\n                // Fetch accept order data\r\n                const acceptQuery = `SELECT itemReceived, status FROM accept_orders WHERE orID = ? AND I_Id = ?`;\r\n                const [acceptResult] = await db.query(acceptQuery, [orID, item.I_Id]);\r\n                if (acceptResult.length > 0) {\r\n                    itemReceived = acceptResult[0].itemReceived;\r\n                    itemStatus = acceptResult[0].status;\r\n                }\r\n\r\n                orderResponse.items.push({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    price: item.tprice,\r\n                    quantity: item.qty,\r\n                    unitPrice: item.unitPrice,\r\n                    booked: item.bookedQty > 0, // true if the item is booked\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty, // Updated field from Item table\r\n                    stockQuantity : item.stockQty,\r\n                    itemReceived: itemReceived,\r\n                    itemStatus: itemStatus\r\n                });\r\n            }\r\n        } else {\r\n            // If order is not \"Accepted\", return normal item details\r\n            orderResponse.items = itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty,\r\n                price: item.tprice,\r\n                unitPrice: item.unitPrice,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty, // Updated field\r\n                stockQuantity : item.stockQty\r\n            }));\r\n        }\r\n\r\n        // If it's a delivery order, fetch delivery details\r\n        if (orderData.dvStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, contact, status, schedule_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: deliveryData.schedule_Date,\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// GET Item Details by Item ID\r\nrouter.get(\"/item-details\", async (req, res) => {\r\n    try {\r\n        const { I_Id } = req.query;\r\n\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Fetch item details along with Type and Category information\r\n        const itemQuery = `\r\n            SELECT\r\n                I.I_Id, I.I_name, I.Ty_id, I.descrip, I.price, I.stockQty, I.bookedQty, I.availableQty,\r\n                I.warrantyPeriod, I.img, I.color, I.material,\r\n                T.sub_one, T.sub_two, C.Ca_Id, C.name AS category_name\r\n            FROM Item I\r\n            JOIN Type T ON I.Ty_id = T.Ty_Id\r\n            JOIN Category C ON T.Ca_Id = C.Ca_Id\r\n            WHERE I.I_Id = ?`;\r\n\r\n        const [itemResult] = await db.query(itemQuery, [I_Id]);\r\n\r\n        if (itemResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found\" });\r\n        }\r\n\r\n        const itemData = itemResult[0];\r\n\r\n        // Fetch additional images from Item_img table\r\n        const imageQuery = `SELECT img1, img2, img3 FROM Item_img WHERE I_Id = ?`;\r\n        const [imageResult] = await db.query(imageQuery, [I_Id]);\r\n\r\n        let imgData = { img1: null, img2: null, img3: null };\r\n\r\n        if (imageResult.length > 0) {\r\n            imgData = {\r\n                img1: imageResult[0].img1 ? Buffer.from(imageResult[0].img1).toString(\"base64\") : null,\r\n                img2: imageResult[0].img2 ? Buffer.from(imageResult[0].img2).toString(\"base64\") : null,\r\n                img3: imageResult[0].img3 ? Buffer.from(imageResult[0].img3).toString(\"base64\") : null,\r\n            };\r\n        }\r\n\r\n        // Convert the main image from Item table to Base64\r\n        const mainImgBase64 = itemData.img ? Buffer.from(itemData.img).toString(\"base64\") : null;\r\n\r\n        // Fetch all suppliers that provide this item along with unit_cost\r\n        const supplierQuery = `\r\n            SELECT S.s_ID, S.name, S.contact, ISUP.unit_cost\r\n            FROM Supplier S\r\n            JOIN item_supplier ISUP ON S.s_ID = ISUP.s_ID\r\n            WHERE ISUP.I_Id = ?`;\r\n\r\n        const [suppliersResult] = await db.query(supplierQuery, [I_Id]);\r\n\r\n        const suppliers = suppliersResult.map(supplier => ({\r\n            s_ID: supplier.s_ID,\r\n            name: supplier.name,\r\n            contact: supplier.contact,\r\n            unit_cost: supplier.unit_cost // Include unit cost\r\n        }));\r\n\r\n        // Construct final response\r\n        const responseData = {\r\n            success: true,\r\n            item: {\r\n                I_Id: itemData.I_Id,\r\n                I_name: itemData.I_name,\r\n                Ty_id: itemData.Ty_id,\r\n                descrip: itemData.descrip,\r\n                color: itemData.color,\r\n                material: itemData.material,\r\n                price: itemData.price,\r\n                stockQty: itemData.stockQty,\r\n                availableQty: itemData.availableQty,\r\n                bookedQty: itemData.bookedQty,\r\n                warrantyPeriod: itemData.warrantyPeriod,\r\n                img: mainImgBase64, // Main image from Item table\r\n                img1: imgData.img1, // Additional Image 1\r\n                img2: imgData.img2, // Additional Image 2\r\n                img3: imgData.img3, // Additional Image 3\r\n                category_id: itemData.Ca_Id, // Category ID\r\n                category_name: itemData.category_name, // Category name\r\n                subcategory_one: itemData.sub_one, // Subcategory One\r\n                subcategory_two: itemData.sub_two,  // Subcategory Two\r\n                suppliers: suppliers // List of suppliers with unit cost\r\n            }\r\n        };\r\n\r\n        return res.status(200).json(responseData);\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= pending\r\nrouter.get(\"/orders-pending\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all pending Orders\r\n        const [orders] = await db.query(\"SELECT * FROM Orders WHERE orStatus = 'pending'\");\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No pending orders found\" });\r\n        }\r\n\r\n        // Format orders\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID: order.OrID, // Order ID\r\n            orDate: order.orDate, // Order Date\r\n            customerEmail: order.customerEmail, // Customer Email\r\n            ordertype : order.order_type,\r\n            orStatus: order.orStatus, // Order Status\r\n            dvStatus: order.dvStatus, // Delivery Status\r\n            dvPrice: order.dvPrice, // Delivery Price\r\n            disPrice: order.disPrice, // Discount Price\r\n            totPrice: order.totPrice, // Total Price\r\n            stID: order.stID, // Sales Team ID\r\n            expectedDeliveryDate: order.expectedDate, // Expected Delivery Date\r\n        }));\r\n\r\n        // Send the formatted orders as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching pending orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= accepting\r\nrouter.get(\"/orders-accepting\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT \r\n                o.OrID, \r\n                o.orDate, \r\n                o.customerEmail,\r\n                o.order_type,\r\n                o.orStatus, \r\n                o.dvStatus, \r\n                o.dvPrice, \r\n                o.disPrice, \r\n                o.totPrice, \r\n                o.stID, \r\n                o.expectedDate AS expectedDeliveryDate, \r\n                ao.itemReceived, \r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Accepted'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customerEmail: order.customerEmail,\r\n                    ordertype : order.order_type,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.dvStatus,\r\n                    dvPrice: order.dvPrice,\r\n                    disPrice: order.disPrice,\r\n                    totPrice: order.totPrice,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n                console.log(order.order_type);\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any of the items have an \"In Production\" or \"None\" status, mark the order as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= completed\r\nrouter.get(\"/orders-completed\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT \r\n                o.OrID, \r\n                o.orDate, \r\n                o.customerEmail,\r\n                o.order_type,\r\n                o.orStatus, \r\n                o.dvStatus, \r\n                o.dvPrice, \r\n                o.disPrice, \r\n                o.totPrice, \r\n                o.stID, \r\n                o.expectedDate AS expectedDeliveryDate, \r\n                ao.itemReceived, \r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Completed'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customerEmail: order.customerEmail,\r\n                    ordertype : order.order_type,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.dvStatus,\r\n                    dvPrice: order.dvPrice,\r\n                    disPrice: order.disPrice,\r\n                    totPrice: order.totPrice,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any of the items have an \"In Production\" or \"None\" status, mark the order as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= inproduction\r\nrouter.get(\"/orders-inproduction\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all pending Orders\r\n        const [suporders] = await db.query(\"SELECT * FROM production WHERE status= 'Incomplete'\");\r\n\r\n        // If no orders found, return a 404 status\r\n        if (suporders.length === 0) {\r\n            return res.status(404).json({ message: \"No supplier orders found\" });\r\n        }\r\n\r\n        // Format orders\r\n        const formattedOrders = suporders.map(order => ({\r\n            p_ID : order.p_ID,\r\n            I_Id : order.I_Id,\r\n            qty : order.qty,\r\n            s_ID : order.s_ID,\r\n            expectedDate : order.expectedDate,\r\n            specialNote: order.specialNote,\r\n            status: order.status\r\n        }));\r\n\r\n        // Send the formatted orders as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching pending orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all items where stock count is less than or equal to one\r\nrouter.get(\"/allitemslessone\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch items with qty <= 1\r\n        const [items] = await db.query(\r\n            \"SELECT I_Id, I_name, Ty_id, descrip, price,stockQty, availableQty, img FROM Item WHERE availableQty <= 1\"\r\n        );\r\n\r\n        // If no items found, return a 404 status with a descriptive message\r\n        if (items.length === 0) {\r\n            return res.status(404).json({ message: \"No items found with stock count less than or equal to 1\" });\r\n        }\r\n\r\n        // Format the items data with necessary fields\r\n        const formattedItems = items.map(item => ({\r\n            I_Id: item.I_Id,\r\n            I_name: item.I_name,\r\n            Ty_id: item.Ty_id,\r\n            descrip: item.descrip,\r\n            price: item.price,\r\n            availableQty: item.availableQty,\r\n            stockQty: item.stockQty,\r\n            img: `data:image/png;base64,${item.img.toString(\"base64\")}`, // Convert image to base64\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedItems);\r\n    } catch (error) {\r\n        console.error(\"Error fetching items:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching items\" });\r\n    }\r\n});\r\n\r\n// get all suppliers for the item\r\nrouter.get(\"/item-suppliers\", async (req, res) => {\r\n    try {\r\n        const { I_Id } = req.query;\r\n\r\n        // Validate the input\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Step 1: Fetch the suppliers associated with the item from item_supplier table\r\n        const itemSuppliersQuery = `\r\n            SELECT s_ID\r\n            FROM item_supplier\r\n            WHERE I_Id = ?`;\r\n\r\n        const [itemSuppliersResult] = await db.query(itemSuppliersQuery, [I_Id]);\r\n\r\n        if (itemSuppliersResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No suppliers found for the given item\" });\r\n        }\r\n\r\n        // Step 2: Extract the supplier IDs from the result\r\n        const supplierIds = itemSuppliersResult.map(row => row.s_ID);\r\n\r\n        // Step 3: Fetch the supplier details using the supplier IDs\r\n        const suppliersQuery = `\r\n            SELECT s_ID, name, contact\r\n            FROM Supplier\r\n            WHERE s_ID IN (?)`;\r\n\r\n        const [suppliersResult] = await db.query(suppliersQuery, [supplierIds]);\r\n\r\n        // Step 4: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            suppliers: suppliersResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item suppliers:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n// get all items for the supplier\r\n// Fetch all items associated with the supplier\r\nrouter.get(\"/supplier-items\", async (req, res) => {\r\n    try {\r\n        const { s_Id } = req.query;\r\n\r\n        // Validate input\r\n        if (!s_Id) {\r\n            return res.status(400).json({ success: false, message: \"Supplier ID is required\" });\r\n        }\r\n\r\n        // Query to fetch supplier's items along with cost, warranty period, and image\r\n        const query = `\r\n            SELECT\r\n                item_supplier.I_Id,\r\n                Item.I_name,\r\n                item_supplier.unit_cost,\r\n                Item.warrantyPeriod,\r\n                Item.img  -- Fetch the binary image (LONGBLOB)\r\n            FROM item_supplier\r\n                     JOIN Item ON Item.I_Id = item_supplier.I_Id\r\n            WHERE item_supplier.s_ID = ?\r\n        `;\r\n\r\n        const [itemsResult] = await db.query(query, [s_Id]);\r\n\r\n        // If no items found, return a 404 response\r\n        if (itemsResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No items found for the given supplier\" });\r\n        }\r\n\r\n        // Convert image binary data to Base64\r\n        const itemsWithImages = itemsResult.map(item => ({\r\n            ...item,\r\n            img: item.img ? `data:image/jpeg;base64,${item.img.toString('base64')}` : null  // Convert LONGBLOB to Base64\r\n        }));\r\n\r\n        // Return the supplier's items with cost, warranty period, and image\r\n        return res.status(200).json({\r\n            success: true,\r\n            items: itemsWithImages,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching supplier items:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all suppliers\r\nrouter.get(\"/suppliers\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all suppliers\r\n        const suppliersQuery = `\r\n            SELECT s_ID, name, contact,address\r\n            FROM Supplier`;\r\n\r\n        const [suppliersResult] = await db.query(suppliersQuery);\r\n        // Step 2: Check if suppliers were found\r\n        if (suppliersResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No suppliers found\" });\r\n        }\r\n\r\n        // Step 3: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            suppliers: suppliersResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching suppliers:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// get item detail in item table only\r\nrouter.get(\"/item-detail\", async (req, res) => {\r\n    try {\r\n        const { Id } = req.query;\r\n\r\n        if (!Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Step 1: Fetch Item details\r\n        const itemQuery = `\r\n            SELECT \r\n                I.I_Id, I.I_name, I.Ty_id, I.descrip, I.price, I.stockQty,I.bookedQty,I.availableQty,\r\n                I.warrantyPeriod, I.img\r\n            FROM Item I\r\n            WHERE I.I_Id = ?`;\r\n\r\n        const [itemResult] = await db.query(itemQuery, [Id]);\r\n\r\n        if (itemResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found\" });\r\n        }\r\n\r\n        const itemData1 = itemResult[0];\r\n        // Step 2: Construct final response\r\n        const responseData = {\r\n            success: true,\r\n            item: {\r\n                I_Id: itemData1.I_Id,\r\n                I_name: itemData1.I_name,\r\n                price: itemData1.price,\r\n                stockQty: itemData1.stockQty,\r\n                bookedQty: itemData1.bookedQty,\r\n                availableQty: itemData1.availableQty,\r\n            }\r\n        };\r\n\r\n        return res.status(200).json(responseData);\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// save in production\r\nrouter.post('/add-production', async (req, res) => {\r\n    const {itemId, qty, supplierId, expectedDate, specialnote} = req.body;\r\n\r\n    if (!itemId || !qty || !supplierId || !expectedDate) {\r\n        return res.status(400).json({error: 'All fields are required'});\r\n    }\r\n\r\n    const p_ID = `InP_${Date.now()}`;\r\n\r\n    const sql = `INSERT INTO production (p_ID, I_Id, qty, s_ID, expectedDate, specialNote,status)\r\n                 VALUES (?, ?, ?, ?, ?, ?,'Incomplete')`;\r\n    const [Result] = await db.query(sql, [p_ID, itemId, qty, supplierId, expectedDate, specialnote]);\r\n    return res.status(200).json({\r\n        success: true,\r\n        message: \"Order details fetched successfully\",\r\n        result: Result\r\n    });\r\n});\r\n\r\n// Get category namees\r\nrouter.get(\"/getcategory\", async (req, res) => {\r\n    const { category } = req.query;\r\n\r\n    // Check if category is provided\r\n    if (!category) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Category is required\",\r\n        });\r\n    }\r\n\r\n    // SQL query to join Category and subCat_one based on category name\r\n    const sql = `\r\n        SELECT sc.sb_c_id, sc.subcategory, sc.img, c.name AS category \r\n        FROM subCat_one sc\r\n        INNER JOIN Category c ON sc.Ca_Id = c.Ca_Id\r\n        WHERE c.name = ?\r\n    `;\r\n\r\n    try {\r\n        const [rows] = await db.query(sql, [category]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No images found for the given category\",\r\n            });\r\n        }\r\n\r\n        // Send back the response with image data\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Category images retrieved successfully\",\r\n            data: rows.map(row => ({\r\n                id: row.sb_c_id,\r\n                category: row.category,\r\n                subcategory: row.subcategory,\r\n                img: row.img.toString(\"base64\"), // Convert binary image to Base64\r\n            })),\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Check and update stock receive\r\nrouter.post('/update-stock', async (req, res) => {\r\n    const { p_ID, rDate, recCount, detail } = req.body;\r\n\r\n    // Validate input fields\r\n    if (!p_ID || !rDate || !recCount) {\r\n        return res.status(400).json({ error: 'All fields are required' });\r\n    }\r\n\r\n    try {\r\n        // Get the current quantity for the production order\r\n        const [rows] = await db.query(\"SELECT qty, I_Id FROM production WHERE p_ID = ?\", [p_ID]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({ error: \"Production order not found\" });\r\n        }\r\n\r\n        const currentQty = rows[0].qty;\r\n        const itemId = rows[0].I_Id;\r\n        const receivedQty = parseInt(recCount, 10); // Convert received count to integer\r\n\r\n        // Insert received stock details into the stock_received table\r\n        const sqlInsert = `INSERT INTO stock_received (p_ID, rDate, rec_count, detail) VALUES (?, ?, ?, ?)`;\r\n        await db.query(sqlInsert, [p_ID, rDate, receivedQty, detail]);\r\n\r\n        // Determine the new status and remaining quantity\r\n        let newStatus = \"Incomplete\";\r\n        let newQty = currentQty - receivedQty;\r\n\r\n        if (receivedQty >= currentQty) {\r\n            // Mark order as complete if received qty is equal or more than the order qty\r\n            newStatus = \"Complete\";\r\n            newQty = 0;\r\n        }\r\n\r\n        // Update the production table with the new status and remaining quantity\r\n        const sqlUpdate = `UPDATE production SET qty = ?, status = ? WHERE p_ID = ?`;\r\n        await db.query(sqlUpdate, [newQty, newStatus, p_ID]);\r\n\r\n        // Update the Item table stock quantity\r\n        const sqlUpdateItem = `UPDATE Item SET stockQty = stockQty + ? WHERE I_Id = ?`;\r\n        await db.query(sqlUpdateItem, [receivedQty, itemId]);\r\n\r\n        const sqlUpdateItem1 = `UPDATE Item SET availableQty = availableQty + ? WHERE I_Id = ?`;\r\n        await db.query(sqlUpdateItem1, [receivedQty, itemId]);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Stock received updated successfully\",\r\n            updatedStatus: newStatus,\r\n            remainingQty: newQty\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating stock received:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n});\r\n\r\n// Update order in invoice part\r\nrouter.put(\"/update-invoice\", async (req, res) => {\r\n    try {\r\n        console.log(req.body);\r\n        const {\r\n            orID,\r\n            isPickup,\r\n            netTotal,\r\n            updatedAdvance,\r\n            updatedDeliveryCharge,\r\n            updatedDiscount\r\n        } = req.body;\r\n\r\n        // Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM Orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orID]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"Order not found\",\r\n            });\r\n        }\r\n\r\n        // Update the Orders table\r\n        let orderUpdateQuery = `\r\n            UPDATE Orders\r\n            SET totPrice = ?, disPrice = ?, dvPrice = ?\r\n            WHERE OrID = ?`;\r\n        const orderUpdateParams = [netTotal, updatedDiscount, updatedDeliveryCharge, orID];\r\n        await db.query(orderUpdateQuery, orderUpdateParams);\r\n\r\n        // If isPickup is true, update the delivery table\r\n        if (isPickup) {\r\n            // Remove the existing delivery entry for the order\r\n            const deleteDeliveryQuery = `DELETE FROM delivery WHERE orID = ?`;\r\n            await db.query(deleteDeliveryQuery, [orID]);\r\n        }\r\n\r\n        // Calculate the balance (netTotal - advance)\r\n        const balance = netTotal - updatedAdvance;\r\n\r\n        // Insert the new entry into the order_Payment table\r\n        const insertPaymentQuery = `\r\n            INSERT INTO order_Payment (orID, netTotal, advance, balance)\r\n            VALUES (?, ?, ?, ?)`;\r\n        const paymentParams = [orID, netTotal, updatedAdvance, balance];\r\n        await db.query(insertPaymentQuery, paymentParams);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order and payment updated successfully\",\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error updating invoice:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating invoice data\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n//\r\nrouter.get(\"/orders-accept\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all the orders and their associated items' statuses from the accept_orders table.\r\n        const query = `\r\n            SELECT \r\n                o.OrID, \r\n                o.orDate, \r\n                o.customerEmail, \r\n                o.order_type,\r\n                o.orStatus, \r\n                o.dvStatus, \r\n                o.dvPrice, \r\n                o.disPrice, \r\n                o.totPrice, \r\n                o.stID, \r\n                o.expectedDate AS expectedDeliveryDate, \r\n                ao.itemReceived, \r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Accepted'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders are found, return a 404 response.\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        // Step 2: Group orders by OrID.\r\n        const groupedOrders = {};\r\n\r\n        // Initialize arrays to hold booked and unbooked orders.\r\n        const bookedOrders = [];\r\n        const unbookedOrders = [];\r\n\r\n        // Step 3: Process each order and its items.\r\n        orders.forEach(order => {\r\n            // If the order does not exist in the groupedOrders object, create it.\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customerEmail: order.customerEmail,\r\n                    ordertype : order.order_type,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.dvStatus,\r\n                    dvPrice: order.dvPrice,\r\n                    disPrice: order.disPrice,\r\n                    totPrice: order.totPrice,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    acceptanceStatuses: [], // Array to track item statuses.\r\n                    isUnbooked: false // Flag to check if the order contains any unbooked item.\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list of acceptance statuses.\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // Check the acceptance status of the current item:\r\n            if (order.acceptanceStatus !== \"Complete\") {\r\n                // If the status is not \"Complete\", mark the order as unbooked.\r\n                groupedOrders[order.OrID].isUnbooked = true;\r\n            }\r\n        });\r\n\r\n        // Step 4: Now, categorize the orders as \"booked\" or \"unbooked\".\r\n        Object.values(groupedOrders).forEach(order => {\r\n            if (order.isUnbooked) {\r\n                // If the order has any unbooked item, mark the entire order as unbooked.\r\n                order.acceptanceStatus = \"Incomplete\";\r\n                unbookedOrders.push(order);\r\n            } else {\r\n                // If all items are booked, mark the order as booked.\r\n                order.acceptanceStatus = \"Complete\";\r\n                bookedOrders.push(order);\r\n            }\r\n        });\r\n\r\n        // Step 5: Send the response with two arrays: bookedOrders and unbookedOrders.\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            bookedOrders: bookedOrders,\r\n            unbookedOrders: unbookedOrders\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Update order\r\nrouter.put(\"/update-order\", async (req, res) => {\r\n    try {\r\n        const {\r\n            orderId,\r\n            orderDate,\r\n            customerEmail,\r\n            phoneNumber,\r\n            optionalNumber,\r\n            orderStatus,\r\n            deliveryStatus,\r\n            deliveryCharge,\r\n            discount,\r\n            totalPrice,\r\n            expectedDeliveryDate,\r\n            specialNote,\r\n            salesTeam,\r\n            items,\r\n            deliveryInfo\r\n        } = req.body;\r\n\r\n        console.log(orderStatus);\r\n\r\n        // Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orderId]);\r\n\r\n        //console.log(orderResult);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"Order not found\",\r\n            });\r\n        }\r\n\r\n        // Ensure order status is 'Accepted' if any item is booked\r\n        const isAnyItemBooked = items.some(item => item.booked);\r\n        if (isAnyItemBooked && orderStatus !== \"Accepted\") {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"Order status must be 'Accepted' if any item is booked.\",\r\n            });\r\n        }\r\n\r\n        // Update the order details\r\n        const orderUpdateQuery = `\r\n            UPDATE orders\r\n            SET orDate = ?, customerEmail = ?, contact1 = ?, contact2 = ?, orStatus = ?,\r\n                dvStatus = ?, dvPrice = ?, disPrice = ?, totPrice = ?, expectedDate = ?, specialNote = ?\r\n            WHERE OrID = ?`;\r\n        const orderUpdateParams = [\r\n            orderDate, customerEmail, phoneNumber, optionalNumber, orderStatus,\r\n            deliveryStatus, deliveryCharge, discount, totalPrice, expectedDeliveryDate, specialNote, orderId\r\n        ];\r\n        const query = await db.query(orderUpdateQuery, orderUpdateParams);\r\n\r\n        console.log(query);\r\n\r\n        // Handle accept_orders table update\r\n        for (const item of items) {\r\n            const itemReceived = item.booked ? \"Yes\" : \"No\";\r\n            const itemStatus = item.booked ? \"Complete\" : \"Incomplete\";\r\n\r\n            // Check if the record already exists in accept_orders\r\n            const checkAcceptOrderQuery = `SELECT * FROM accept_orders WHERE orID = ? AND I_Id = ?`;\r\n            const [existingRecord] = await db.query(checkAcceptOrderQuery, [orderId, item.itemId]);\r\n\r\n            console.log(existingRecord);\r\n\r\n            if (existingRecord.length > 0) {\r\n                // If the record exists, update it\r\n                const updateAcceptOrderQuery = `\r\n                    UPDATE accept_orders\r\n                    SET itemReceived = ?, status = ?\r\n                    WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(updateAcceptOrderQuery, [\r\n                    itemReceived, itemStatus, orderId, item.itemId\r\n                ]);\r\n            } else {\r\n                // If the record does not exist, insert a new one\r\n                const insertAcceptOrderQuery = `\r\n                    INSERT INTO accept_orders (orID, I_Id, itemReceived, status)\r\n                    VALUES (?, ?, ?, ?)`;\r\n                await db.query(insertAcceptOrderQuery, [\r\n                    orderId, item.itemId, itemReceived, itemStatus\r\n                ]);\r\n            }\r\n        }\r\n\r\n        // Handle booked items & inventory update\r\n        for (const item of items) {\r\n            if (item.booked) {\r\n                const checkBookedItemQuery = `SELECT * FROM booked_item WHERE orID = ? AND I_Id = ?`;\r\n                const [existingBookedItem] = await db.query(checkBookedItemQuery, [orderId, item.itemId]);\r\n\r\n                console.log(existingBookedItem);\r\n\r\n                if (existingBookedItem.length === 0) {\r\n                    // Insert only if the item is not already booked\r\n                    const bookItemQuery = `\r\n                        INSERT INTO booked_item (orID, I_Id, qty)\r\n                        VALUES (?, ?, ?)`;\r\n                    await db.query(bookItemQuery, [orderId, item.itemId, item.quantity]);\r\n\r\n                    // Update inventory (only if booked is TRUE)\r\n                    const updateItemQtyQuery = `\r\n                        UPDATE Item\r\n                        SET bookedQty = bookedQty + ?, availableQty = availableQty - ?\r\n                        WHERE I_Id = ?`;\r\n                    await db.query(updateItemQtyQuery, [item.quantity, item.quantity, item.itemId]);\r\n                }\r\n            } else {\r\n                // If unchecked, remove from booked_item table & restore inventory\r\n                const deleteBookedItemQuery = `DELETE FROM booked_item WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(deleteBookedItemQuery, [orderId, item.itemId]);\r\n\r\n                // Restore inventory (only if item was previously booked)\r\n                const checkIfBookedQuery = `SELECT * FROM Item WHERE I_Id = ? AND bookedQty >= ?`;\r\n                const [bookedCheck] = await db.query(checkIfBookedQuery, [item.itemId, item.quantity]);\r\n\r\n                if (bookedCheck.length > 0) {\r\n                    const restoreStockQuery = `\r\n                        UPDATE Item\r\n                        SET bookedQty = bookedQty - ?, availableQty = availableQty + ?\r\n                        WHERE I_Id = ?`;\r\n                    await db.query(restoreStockQuery, [item.quantity, item.quantity, item.itemId]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If order status changes to \"Pending\", remove all bookings and restore stock\r\n        if (orderStatus === \"Pending\") {\r\n            const bookedItemsQuery = `SELECT I_Id, qty FROM booked_item WHERE orID = ?`;\r\n            const [bookedItems] = await db.query(bookedItemsQuery, [orderId]);\r\n\r\n            console.log(bookedItems);\r\n\r\n            for (const item of bookedItems) {\r\n                const restoreStockQuery = `\r\n                    UPDATE Item\r\n                    SET bookedQty = bookedQty - ?, availableQty = availableQty + ?\r\n                    WHERE I_Id = ?`;\r\n                await db.query(restoreStockQuery, [item.qty, item.qty, item.I_Id]);\r\n            }\r\n\r\n            const deleteBookedItemsQuery = `DELETE FROM booked_item WHERE orID = ?`;\r\n            await db.query(deleteBookedItemsQuery, [orderId]);\r\n\r\n            const deleteAcceptOrderQuery = `DELETE FROM accept_orders WHERE orID = ?`;\r\n            await db.query(deleteAcceptOrderQuery, [orderId]);\r\n        }\r\n\r\n        // Update order details (items)\r\n        for (const item of items) {\r\n            const orderDetailUpdateQuery = `\r\n                UPDATE Order_Detail\r\n                SET qty = ?, tprice = ?\r\n                WHERE orID = ? AND I_Id = ?`;\r\n            await db.query(orderDetailUpdateQuery, [item.quantity, item.price, orderId, item.itemId]);\r\n        }\r\n\r\n        // **Handling delivery status change:**\r\n        if (deliveryStatus === \"Delivery\" && deliveryInfo) {\r\n            // Check if delivery record exists, if not, insert it\r\n            const checkDeliveryQuery = `SELECT * FROM delivery WHERE orID = ?`;\r\n            const [existingDelivery] = await db.query(checkDeliveryQuery, [orderId]);\r\n\r\n            if (existingDelivery.length === 0) {\r\n                const deliveryInsertQuery = `\r\n                    INSERT INTO delivery (orID, address, district, contact, schedule_Date)\r\n                    VALUES (?, ?, ?, ?, ?)`;\r\n                await db.query(deliveryInsertQuery, [\r\n                    orderId, deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate\r\n                ]);\r\n            } else {\r\n                // Update delivery info if already exists\r\n                const deliveryUpdateQuery = `\r\n                    UPDATE delivery\r\n                    SET address = ?, district = ?, contact = ?, schedule_Date = ?\r\n                    WHERE orID = ?`;\r\n                await db.query(deliveryUpdateQuery, [\r\n                    deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate, orderId\r\n                ]);\r\n            }\r\n        }\r\n\r\n        // **Handle the case when changing from Delivery to Pickup**\r\n        if (deliveryStatus === \"Pick Up\") {\r\n            // Delete existing delivery record if exists\r\n            const checkDeliveryQuery = `SELECT * FROM delivery WHERE orID = ?`;\r\n            const [existingDelivery] = await db.query(checkDeliveryQuery, [orderId]);\r\n\r\n            console.log(existingDelivery);\r\n\r\n            if (existingDelivery.length > 0) {\r\n                const deleteDeliveryQuery = `DELETE FROM delivery WHERE orID = ?`;\r\n                await db.query(deleteDeliveryQuery, [orderId]);\r\n            }\r\n\r\n            // Reset delivery charge (dvPrice) when changing to Pickup\r\n            const updateDeliveryQuery = `UPDATE orders SET dvPrice = 0 WHERE OrID = ?`;\r\n            await db.query(updateDeliveryQuery, [orderId]);\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order updated successfully\",\r\n            data: {\r\n                orderId: orderId,\r\n                orderDate: orderDate,\r\n                expectedDeliveryDate: expectedDeliveryDate,\r\n            },\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order data:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating data in database\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\nrouter.put(\"/update-order-details\", async (req, res) => {\r\n    try {\r\n        const { orderId, orderDate, customerEmail, phoneNumber, optionalNumber, orderStatus,\r\n            deliveryStatus, deliveryCharge, discount, totalPrice, expectedDeliveryDate, specialNote } = req.body;\r\n\r\n        // Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orderId]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        // Update order details\r\n        const orderUpdateQuery = `\r\n            UPDATE orders SET orDate = ?, customerEmail = ?, contact1 = ?, contact2 = ?, orStatus = ?, \r\n            dvStatus = ?, dvPrice = ?, disPrice = ?, totPrice = ?, expectedDate = ?, specialNote = ?\r\n            WHERE OrID = ?`;\r\n        await db.query(orderUpdateQuery, [\r\n            orderDate, customerEmail, phoneNumber, optionalNumber, orderStatus, deliveryStatus,\r\n            deliveryCharge, discount, totalPrice, expectedDeliveryDate, specialNote, orderId\r\n        ]);\r\n        console.log(\"sucess\");\r\n        // return res.status(200).json({ success: true, message: \"Order details updated successfully\" });\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order updated successfully\",\r\n            data: {\r\n                orderId: orderId,\r\n                orderDate: orderDate,\r\n                expectedDeliveryDate: expectedDeliveryDate,\r\n            },\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order data:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating data in database\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\nrouter.put(\"/update-order-items\", async (req, res) => {\r\n    try {\r\n        const { orderId, orderStatus, items } = req.body;\r\n\r\n        if (!items || items.length === 0) {\r\n            return res.status(400).json({ success: false, message: \"No items provided.\" });\r\n        }\r\n\r\n        // Ensure order status is 'Accepted' if any item is booked\r\n        const isAnyItemBooked = items.some(item => item.booked);\r\n        if (isAnyItemBooked && orderStatus !== \"Accepted\") {\r\n            return res.status(400).json({ success: false, message: \"Order status must be 'Accepted' if any item is booked.\" });\r\n        }\r\n\r\n        for (const item of items) {\r\n            const itemReceived = item.booked ? \"Yes\" : \"No\";\r\n            const itemStatus = item.booked ? \"Complete\" : \"Incomplete\";\r\n\r\n            // Check if the record exists in accept_orders\r\n            const checkAcceptOrderQuery = `SELECT * FROM accept_orders WHERE orID = ? AND I_Id = ?`;\r\n            const [existingRecord] = await db.query(checkAcceptOrderQuery, [orderId, item.itemId]);\r\n\r\n            if (existingRecord.length > 0) {\r\n                const updateAcceptOrderQuery = `UPDATE accept_orders SET itemReceived = ?, status = ? WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(updateAcceptOrderQuery, [itemReceived, itemStatus, orderId, item.itemId]);\r\n            } else {\r\n                const insertAcceptOrderQuery = `INSERT INTO accept_orders (orID, I_Id, itemReceived, status) VALUES (?, ?, ?, ?)`;\r\n                await db.query(insertAcceptOrderQuery, [orderId, item.itemId, itemReceived, itemStatus]);\r\n            }\r\n\r\n            // Handle booking & inventory\r\n            if (item.booked) {\r\n                const checkBookedItemQuery = `SELECT * FROM booked_item WHERE orID = ? AND I_Id = ?`;\r\n                const [existingBookedItem] = await db.query(checkBookedItemQuery, [orderId, item.itemId]);\r\n\r\n                if (existingBookedItem.length === 0) {\r\n                    const bookItemQuery = `INSERT INTO booked_item (orID, I_Id, qty) VALUES (?, ?, ?)`;\r\n                    await db.query(bookItemQuery, [orderId, item.itemId, item.quantity]);\r\n\r\n                    // Update inventory\r\n                    const updateItemQtyQuery = `UPDATE Item SET bookedQty = bookedQty + ?, availableQty = availableQty - ? WHERE I_Id = ?`;\r\n                    await db.query(updateItemQtyQuery, [item.quantity, item.quantity, item.itemId]);\r\n                }\r\n            } else {\r\n                // Remove from booked items & restore inventory\r\n                const deleteBookedItemQuery = `DELETE FROM booked_item WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(deleteBookedItemQuery, [orderId, item.itemId]);\r\n\r\n                const checkIfBookedQuery = `SELECT * FROM Item WHERE I_Id = ? AND bookedQty >= ?`;\r\n                const [bookedCheck] = await db.query(checkIfBookedQuery, [item.itemId, item.quantity]);\r\n\r\n                if (bookedCheck.length > 0) {\r\n                    const restoreStockQuery = `UPDATE Item SET bookedQty = bookedQty - ?, availableQty = availableQty + ? WHERE I_Id = ?`;\r\n                    await db.query(restoreStockQuery, [item.quantity, item.quantity, item.itemId]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Order items updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order items:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Database update failed\", details: error.message });\r\n    }\r\n});\r\nrouter.put(\"/update-delivery\", async (req, res) => {\r\n    try {\r\n        const { orderId, deliveryStatus, phoneNumber, deliveryInfo } = req.body;\r\n\r\n        if (!orderId || !deliveryStatus) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        if (deliveryStatus === \"Delivery\" && deliveryInfo) {\r\n            // Check if a delivery record already exists\r\n            const checkDeliveryQuery = `SELECT * FROM delivery WHERE orID = ?`;\r\n            const [existingDelivery] = await db.query(checkDeliveryQuery, [orderId]);\r\n\r\n            if (existingDelivery.length > 0) {\r\n                // Update existing delivery record\r\n                const deliveryUpdateQuery = `UPDATE delivery SET address = ?, district = ?, contact = ?, schedule_Date = ? WHERE orID = ?`;\r\n                await db.query(deliveryUpdateQuery, [deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate, orderId]);\r\n            } else {\r\n                // Insert new delivery record\r\n                const insertDeliveryQuery = `INSERT INTO delivery (orID, address, district, contact, schedule_Date) VALUES (?, ?, ?, ?, ?)`;\r\n                await db.query(insertDeliveryQuery, [orderId, deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate]);\r\n            }\r\n        }\r\n\r\n        if (deliveryStatus === \"Pick Up\") {\r\n            // Remove any existing delivery record\r\n            const deleteDeliveryQuery = `DELETE FROM delivery WHERE orID = ?`;\r\n            await db.query(deleteDeliveryQuery, [orderId]);\r\n\r\n            // Update the delivery price to 0 in orders\r\n            const updateDeliveryQuery = `UPDATE orders SET dvPrice = 0 WHERE orID = ?`;\r\n            await db.query(updateDeliveryQuery, [orderId]);\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Delivery information updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating delivery information:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Database update failed\", details: error.message });\r\n    }\r\n});\r\n\r\n//Get All sale team members\r\nrouter.get(\"/salesteam\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all sales team members\r\n        const [salesTeam] = await db.query(`\r\n            SELECT \r\n                st.stID, \r\n                st.target, \r\n                st.currentRate, \r\n                e.E_Id, \r\n                e.name AS employeeName, \r\n                e.address, \r\n                e.nic, \r\n                e.dob, \r\n                e.contact, \r\n                e.job, \r\n                e.basic\r\n            FROM sales_team st\r\n            JOIN Employee e ON st.E_Id = e.E_Id;\r\n        `);\r\n\r\n        // If no sales team members found, return a 404 status\r\n        if (salesTeam.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team members found\" });\r\n        }\r\n\r\n        // Format the response data\r\n        const formattedSalesTeam = salesTeam.map(member => ({\r\n            stID: member.stID,\r\n            E_Id: member.E_Id,\r\n            employeeName: member.employeeName,\r\n            address: member.address,\r\n            nic: member.nic,\r\n            dob: member.dob,\r\n            contact: member.contact,\r\n            job: member.job,\r\n            basic: member.basic,\r\n            target: member.target,\r\n            currentRate: member.currentRate\r\n        }));\r\n\r\n        // Send the formatted data as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Sales team members found.\",\r\n            data: formattedSalesTeam\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching sales team members:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching sales team members\" });\r\n    }\r\n});\r\n\r\n// Get orders for a specific sales team member (stID)\r\nrouter.get(\"/orders/by-sales-team\", async (req, res) => {\r\n    try {\r\n        const { stID } = req.query;\r\n        console.log(stID);\r\n\r\n        // Query the database to fetch sales team member details and their orders using a JOIN\r\n        const [results] = await db.query(`\r\n            SELECT \r\n                e.name AS employeeName, \r\n                e.contact AS employeeContact,\r\n                e.nic AS employeeNic,\r\n                e.dob AS employeeDob,\r\n                e.address AS employeeAddress,\r\n                e.job AS employeeJob,\r\n                e.basic AS employeeBasic,\r\n                st.stID,\r\n                st.target,\r\n                st.currentRate,\r\n                o.OrID AS orderId,\r\n                o.orDate AS orderDate,\r\n                o.totPrice AS totalPrice\r\n            FROM sales_team st\r\n            JOIN Employee e ON e.E_Id = st.E_Id\r\n            LEFT JOIN Orders o ON o.stID = st.stID\r\n            WHERE st.stID = ?;\r\n        `, [stID]);\r\n\r\n        // Check if we have any data for the given sales team\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ message: \"No orders found for this sales team member.\" });\r\n        }\r\n\r\n        // Prepare the response with sales team details and orders\r\n        const memberDetails = {\r\n            employeeName: results[0].employeeName,\r\n            employeeContact: results[0].employeeContact,\r\n            employeeNic: results[0].employeeNic,\r\n            employeeDob: results[0].employeeDob,\r\n            employeeAddress: results[0].employeeAddress,\r\n            employeeJob: results[0].employeeJob,\r\n            employeeBasic: results[0].employeeBasic,\r\n            stID: results[0].stID,\r\n            target: results[0].target,\r\n            currentRate: results[0].currentRate,\r\n        };\r\n\r\n        const orders = results.map(order => ({\r\n            orderId: order.orderId,\r\n            orderDate: order.orderDate,\r\n            totalPrice: order.totalPrice\r\n        }));\r\n\r\n        // Send the member details and orders as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Sales team details and orders fetched successfully.\",\r\n            data: {\r\n                memberDetails,\r\n                orders\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching orders and member details:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching orders and member details.\" });\r\n    }\r\n});\r\n\r\n// Get all categories\r\nrouter.get(\"/categories\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all categories\r\n        const [categories] = await db.query(\"SELECT * FROM Category\");\r\n\r\n        // If no categories found, return a 404 status\r\n        if (categories.length === 0) {\r\n            return res.status(404).json({ message: \"No categories found\" });\r\n        }\r\n\r\n        // Map through categories to format the response\r\n        const formattedCategories = categories.map(category => ({\r\n            id: category.Ca_Id,  // Assuming you have a Ca_Id column for the category ID\r\n            name: category.name   // Assuming you have a name column for the category name\r\n        }));\r\n\r\n        // Send the formatted categories as a JSON response\r\n        return res.status(200).json(formattedCategories);\r\n    } catch (error) {\r\n        console.error(\"Error fetching categories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching categories\" });\r\n    }\r\n});\r\n\r\n//API to Get All Sub Categories (sub_one and sub_two) by Category ID (Ca_Id):\r\nrouter.get(\"/types\", async (req, res) => {\r\n    try {\r\n        const { Ca_Id } = req.query; // Get Category ID from the query parameters\r\n\r\n        if (!Ca_Id) {\r\n            return res.status(400).json({ message: \"Category ID is required.\" });\r\n        }\r\n\r\n        // Query the database to fetch all types for the given Ca_Id\r\n        const [types] = await db.query(`\r\n            SELECT Ty_Id, sub_one, sub_two\r\n            FROM Type\r\n            WHERE Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        // If no types found for this category, return a 404 status\r\n        if (types.length === 0) {\r\n            return res.status(404).json({ message: \"No types found for this category.\" });\r\n        }\r\n\r\n        // Send the types as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Types found.\",\r\n            types: types,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching types:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching types\" });\r\n    }\r\n});\r\n\r\n// find type by cat name\r\nrouter.get(\"/types-cat\", async (req, res) => {\r\n    try {\r\n        const { category_name } = req.query; // Get Category name from the query parameters\r\n\r\n        if (!category_name) {\r\n            return res.status(400).json({ message: \"Category name is required.\" });\r\n        }\r\n\r\n        // Step 1: Query the Category table to get the Ca_Id based on the category_name\r\n        const [categoryResult] = await db.query(`\r\n            SELECT Ca_Id\r\n            FROM Category\r\n            WHERE name = ?;\r\n        `, [category_name]);\r\n\r\n        // If no category found, return an error\r\n        if (categoryResult.length === 0) {\r\n            return res.status(404).json({ message: \"Category not found.\" });\r\n        }\r\n\r\n        const Ca_Id = categoryResult[0].Ca_Id; // Extract the Ca_Id from the result\r\n\r\n        // Step 2: Query the Type table to fetch all types for the given Ca_Id\r\n        const [types] = await db.query(`\r\n            SELECT Ty_Id, sub_one, sub_two\r\n            FROM Type\r\n            WHERE Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        // If no types found for this category, return a 404 status\r\n        if (types.length === 0) {\r\n            return res.status(404).json({ message: \"No types found for this category.\" });\r\n        }\r\n\r\n        // Step 3: Return the found types\r\n        return res.status(200).json({\r\n            message: \"Types found.\",\r\n            types: types,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching types:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching types\" });\r\n    }\r\n});\r\n\r\n// Find Type id\r\nrouter.get(\"/find-types\", async (req, res) => {\r\n    try {\r\n        const { Ca_Id, sub_one, sub_two } = req.query; // Get Category ID, sub_one, and sub_two from the query parameters\r\n\r\n        if (!Ca_Id || !sub_one || !sub_two) {\r\n            return res.status(400).json({ message: \"Category ID, Sub One, and Sub Two are required.\" });\r\n        }\r\n\r\n        // Query the database to fetch the type for the given Ca_Id, sub_one, and sub_two\r\n        const [types] = await db.query(`\r\n            SELECT Ty_Id, sub_one, sub_two\r\n            FROM Type\r\n            WHERE Ca_Id = ? AND sub_one = ? AND sub_two = ?;\r\n        `, [Ca_Id, sub_one, sub_two]);\r\n\r\n        // If no type found for this combination, return a 404 status\r\n        if (types.length === 0) {\r\n            return res.status(404).json({ message: \"No type found for this category and sub-one/sub-two combination.\" });\r\n        }\r\n        console.log(types[0]);\r\n\r\n        // Send the type as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Type found.\",\r\n            type: types[0],  // Return only the first matching type\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching types:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching types\" });\r\n    }\r\n});\r\n\r\n// Find type id when category name comes\r\nrouter.get(\"/find-types-cat\", async (req, res) => {\r\n    try {\r\n        const { category_name, sub_one, sub_two } = req.query; // Get Category name, sub_one, and sub_two from the query parameters\r\n\r\n        if (!category_name || !sub_one || !sub_two) {\r\n            return res.status(400).json({ message: \"Category name, Sub One, and Sub Two are required.\" });\r\n        }\r\n\r\n        // Step 1: Query the Category table to get the Ca_Id based on the category name\r\n        const [categoryResult] = await db.query(`\r\n            SELECT Ca_Id\r\n            FROM Category\r\n            WHERE name = ?;\r\n        `, [category_name]);\r\n\r\n        // If no category found, return an error\r\n        if (categoryResult.length === 0) {\r\n            return res.status(404).json({ message: \"Category not found.\" });\r\n        }\r\n\r\n        const Ca_Id = categoryResult[0].Ca_Id; // Extract the Ca_Id from the result\r\n\r\n        // Step 2: Query the Type table to find the Ty_Id based on Ca_Id, sub_one, and sub_two\r\n        const [types] = await db.query(`\r\n            SELECT Ty_Id, sub_one, sub_two\r\n            FROM Type\r\n            WHERE Ca_Id = ? AND sub_one = ? AND sub_two = ?;\r\n        `, [Ca_Id, sub_one, sub_two]);\r\n\r\n        // If no type found for this combination, return a 404 status\r\n        if (types.length === 0) {\r\n            return res.status(404).json({ message: \"No type found for this category and sub-one/sub-two combination.\" });\r\n        }\r\n\r\n        console.log(types[0]);\r\n\r\n        // Step 3: Return the found Type data\r\n        return res.status(200).json({\r\n            message: \"Type found.\",\r\n            type: types[0],  // Return only the first matching type\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching types:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching types\" });\r\n    }\r\n});\r\n\r\n// API endpoint to save item-supplier association\r\nrouter.post('/add-item-supplier', async (req, res) => {\r\n    const { I_Id, s_ID ,cost } = req.body;\r\n\r\n    // Check if I_Id and s_ID are provided\r\n    if (!I_Id || !s_ID ) {\r\n        return res.status(400).json({ success: false, message: 'Item ID and Supplier ID are required' });\r\n    }\r\n\r\n    try {\r\n        // Step 1: Check if the Item ID exists in the Item table\r\n        const [itemExists] = await db.query('SELECT * FROM Item WHERE I_Id = ?', [I_Id]);\r\n        if (itemExists.length === 0) {\r\n            return res.status(404).json({ success: false, message: 'Item not found' });\r\n        }\r\n\r\n        // Step 2: Check if the Supplier ID exists in the Supplier table\r\n        const [supplierExists] = await db.query('SELECT * FROM Supplier WHERE s_ID = ?', [s_ID]);\r\n        if (supplierExists.length === 0) {\r\n            return res.status(404).json({ success: false, message: 'Supplier not found' });\r\n        }\r\n\r\n        // Step 3: Insert the item-supplier relationship into the item_supplier table\r\n        const insertQuery = 'INSERT INTO item_supplier (I_Id, s_ID,unit_cost) VALUES (?, ?,?)';\r\n        const [result] = await db.query(insertQuery, [I_Id, s_ID,cost]);\r\n\r\n        // Step 4: Return success response\r\n        return res.status(200).json({ success: true, message: 'Item-Supplier relationship added successfully', data: result });\r\n    } catch (error) {\r\n        console.error('Error adding item-supplier:', error.message);\r\n        return res.status(500).json({ success: false, message: 'Server error', error: error.message });\r\n    }\r\n});\r\n\r\n// API to save stock received data\r\nrouter.post(\"/add-stock-received\", async (req, res) => {\r\n    try {\r\n        const { supplierId, itemId, date, stockCount, comment } = req.body;\r\n\r\n        // Validate required fields\r\n        if (!supplierId || !itemId || !date || !stockCount ) {\r\n            return res.status(400).json({ success: false, message: \"All fields are required!\" });\r\n        }\r\n\r\n        // Insert stock received record\r\n        const insertQuery = `\r\n                INSERT INTO main_stock_received (s_ID, I_Id, rDate, rec_count,  detail)\r\n                VALUES (?, ?, ?, ?, ?)\r\n            `;\r\n        const values = [supplierId, itemId, date, stockCount, comment || \"\"];\r\n        const [result] = await db.query(insertQuery, values);\r\n        const receivedStockId = result.insertId;\r\n\r\n        // Update stockQty and availableQty in Item table\r\n        const updateItemQuery = `\r\n                UPDATE Item \r\n                SET stockQty = stockQty + ?, availableQty = availableQty + ?\r\n                WHERE I_Id = ?\r\n            `;\r\n        const [result1] =await db.query(updateItemQuery, [stockCount, stockCount, itemId]);\r\n\r\n        // Get last stock_Id for this item\r\n        const getLastStockIdQuery = `SELECT MAX(stock_Id) AS lastStockId FROM m_s_r_detail WHERE I_Id = ?`;\r\n        const [lastStockResult] = await db.query(getLastStockIdQuery, [itemId]);\r\n        let lastStockId = lastStockResult[0]?.lastStockId || 0; // Default to 0 if no previous stock exists\r\n\r\n        // Insert stock details in m_s_r_detail\r\n        const insertDetailQuery = `INSERT INTO m_s_r_detail (I_Id, stock_Id,sr_ID) VALUES (?, ?,?)`;\r\n        for (let i = 1; i <= stockCount; i++) {\r\n            lastStockId++;\r\n            const query = await db.query(insertDetailQuery, [itemId, lastStockId,receivedStockId]);\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Stock received successfully added and inventory updated!\",\r\n            stockReceivedId: receivedStockId,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error adding stock received:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Find cost by sid and iid\r\nrouter.get(\"/find-cost\", async (req, res) => {\r\n    try {\r\n        const { s_ID , I_Id } = req.query;\r\n\r\n        if (!s_ID || !I_Id ) {\r\n            return res.status(400).json({ message: \"Item ID, Supplier Id are required.\" });\r\n        }\r\n\r\n        // Query the database to fetch the type for the given Ca_Id, sub_one, and sub_two\r\n        const [cost] = await db.query(`\r\n            SELECT unit_cost\r\n            FROM item_supplier\r\n            WHERE s_ID = ? AND I_Id = ? ;\r\n        `, [s_ID,I_Id]);\r\n\r\n        // If no type found for this combination, return a 404 status\r\n        if (cost.length === 0) {\r\n            return res.status(404).json({ message: \"No cost found.\" });\r\n        }\r\n\r\n        // Send the type as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Cost found.\",\r\n            cost: cost[0],  // Return only the first matching cost\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching cost:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching cost\" });\r\n    }\r\n});\r\n\r\n// Get subcat one detail by ca_id\r\nrouter.get(\"/getSubcategories\", async (req, res) => {\r\n    const { Ca_Id } = req.query;\r\n    console.log(Ca_Id);\r\n    if (!Ca_Id) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Category ID (Ca_Id) is required\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Fetch subcategories under the given category ID\r\n        const sqlSubcategories = `SELECT sb_c_id, subcategory FROM subCat_one WHERE Ca_Id = ?`;\r\n        const [subCategories] = await db.query(sqlSubcategories, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No subcategories found for the given category ID\",\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Subcategories retrieved successfully\",\r\n            data: subCategories.map(subCat => ({\r\n                sb_c_id: subCat.sb_c_id,\r\n                subcategory: subCat.subcategory\r\n            })),\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching subcategories:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// // Get subcat two detail by ca_id\r\nrouter.get(\"/getSubcategoriesTwo\", async (req, res) => {\r\n    const { sb_c_id } = req.query;\r\n\r\n    if (!sb_c_id) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Subcategory One ID (sb_c_id) is required\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Fetch subcategory two names under the given subcategory one ID\r\n        const sqlSubcategoriesTwo = `SELECT sb_cc_id, subcategory FROM subCat_two WHERE sb_c_id = ?\r\n        `;\r\n        const [subCategoriesTwo] = await db.query(sqlSubcategoriesTwo, [sb_c_id]);\r\n\r\n        if (subCategoriesTwo.length === 0) {\r\n            return res.status(200).json({\r\n                success: true,\r\n                message: \"No subcategories found\",\r\n                data: [{ sb_cc_id: \"None\", subcategory: \"None\" }],\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Subcategories retrieved successfully\",\r\n            data: subCategoriesTwo.map(subCat => ({\r\n                sb_cc_id: subCat.sb_cc_id,\r\n                subcategory: subCat.subcategory\r\n            })),\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching subcategories:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Category\r\nrouter.post(\"/category\", async (req, res) => {\r\n    try {\r\n        // Fetch the last inserted category ID\r\n        const [lastCategory] = await db.query(\"SELECT Ca_Id FROM Category ORDER BY Ca_Id DESC LIMIT 1\");\r\n\r\n        let newId;\r\n        if (lastCategory.length > 0) {\r\n            // Extract the number from the last ID and increment\r\n            const lastIdNumber = parseInt(lastCategory[0].Ca_Id.split(\"_\")[1], 10);\r\n            newId = `Ca_${String(lastIdNumber + 1).padStart(4, \"0\")}`;\r\n        } else {\r\n            // If no categories exist, start from Ca_0001\r\n            newId = \"Ca_0001\";\r\n        }\r\n\r\n        // SQL query to insert new category\r\n        const sql = `INSERT INTO Category (Ca_Id, name) VALUES (?, ?)`;\r\n        const values = [newId, req.body.Catname];\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, values);\r\n\r\n        // Return success response with the new category details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Category added successfully\",\r\n            data: {\r\n                Ca_Id: newId,\r\n                name: req.body.Catname\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting category data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Sub category one and two with image\r\nrouter.post(\"/subcategory\", upload.fields([{ name: \"subcatone_img\" }, { name: \"subcattwo_img\" }]), async (req, res) => {\r\n    const { Ca_Id, sub_one, sub_two } = req.body;\r\n    const subcatone_img = req.files[\"subcatone_img\"] ? req.files[\"subcatone_img\"][0].buffer : null;\r\n    const subcattwo_img = req.files[\"subcattwo_img\"] ? req.files[\"subcattwo_img\"][0].buffer : null;\r\n\r\n    try {\r\n        // Generate ID for subCat_one\r\n        const sb_c_id = await generateNewId(\"subCat_one\", \"sb_c_id\", \"S1\");\r\n\r\n        // Insert into subCat_one\r\n        await db.query(\r\n            \"INSERT INTO subCat_one (sb_c_id, subcategory, Ca_Id, img) VALUES (?, ?, ?, ?)\",\r\n            [sb_c_id, sub_one, Ca_Id, subcatone_img]\r\n        );\r\n\r\n        let sb_cc_id = null;\r\n        if (sub_two !== \"None\" && subcattwo_img) {\r\n            // Generate ID for subCat_two\r\n            sb_cc_id = await generateNewId(\"subCat_two\", \"sb_cc_id\", \"S2\");\r\n\r\n            // Insert into subCat_two\r\n            await db.query(\r\n                \"INSERT INTO subCat_two (sb_cc_id, subcategory, sb_c_id, img) VALUES (?, ?, ?, ?)\",\r\n                [sb_cc_id, sub_two, sb_c_id, subcattwo_img]\r\n            );\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Sub-category added successfully\",\r\n            data: {\r\n                sb_c_id,\r\n                sub_one,\r\n                Ca_Id,\r\n                sb_cc_id: sb_cc_id || null,\r\n                sub_two: sb_cc_id ? sub_two : null,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting sub-category data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// API to save or retrieve existing Type\r\nrouter.post(\"/type\", async (req, res) => {\r\n    const { Ca_Id, sub_one, sub_two } = req.body;\r\n    console.log(req.body);\r\n\r\n    if (!Ca_Id || !sub_one) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Ca_Id and sub_one are required.\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Check if a Type entry already exists\r\n        const [existing] = await db.query(\r\n            \"SELECT * FROM Type WHERE Ca_Id = ? AND sub_one = ? AND (sub_two = ? OR ? IS NULL)\",\r\n            [Ca_Id, sub_one, sub_two, sub_two]\r\n        );\r\n\r\n        if (existing.length > 0) {\r\n            return res.status(200).json({\r\n                success: true,\r\n                message: \"Type already exists.\",\r\n                data: existing[0],\r\n            });\r\n        }\r\n\r\n        // Generate new Type ID\r\n        const newTypeId = await generateNewId(\"Type\", \"Ty_Id\", \"Ty\");\r\n\r\n        // Insert new Type entry\r\n        await db.query(\r\n            \"INSERT INTO Type (Ty_Id, Ca_Id, sub_one, sub_two) VALUES (?, ?, ?, ?)\",\r\n            [newTypeId, Ca_Id, sub_one, sub_two || null]\r\n        );\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Type added successfully.\",\r\n            data: {\r\n                Ty_Id: newTypeId,\r\n                Ca_Id,\r\n                sub_one,\r\n                sub_two: sub_two || null,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error saving type:\", err);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Save new item to supplier\r\nrouter.post(\"/add-supplier-item\", async (req, res) => {\r\n    try {\r\n        const { I_Id, s_ID, unit_cost } = req.body;\r\n        console.log(I_Id, s_ID, unit_cost);\r\n\r\n        // Validate input\r\n        if (!I_Id || !s_ID || !unit_cost) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        // Query to insert the supplier item\r\n        const query = `\r\n            INSERT INTO item_supplier (I_Id, s_ID, unit_cost) \r\n            VALUES (?, ?, ?)\r\n            ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost)\r\n        `;\r\n\r\n        await db.query(query, [I_Id, s_ID, unit_cost]);\r\n\r\n        return res.status(201).json({ success: true, message: \"Item added successfully\" });\r\n    } catch (error) {\r\n        console.error(\"Error adding supplier item:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Function to generate new ida\r\nconst generateNewId = async (table, column, prefix) => {\r\n    const [rows] = await db.query(`SELECT ${column} FROM ${table} ORDER BY ${column} DESC LIMIT 1`);\r\n    if (rows.length === 0) return `${prefix}_001`; // First entry\r\n    const lastId = rows[0][column]; // Get last ID\r\n    const lastNum = parseInt(lastId.split(\"_\")[1], 10) + 1; // Extract number and increment\r\n    return `${prefix}_${String(lastNum).padStart(3, \"0\")}`;\r\n};\r\n\r\n\r\nexport default router;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/adminBackend/Routes/mainRoutes.js b/adminBackend/Routes/mainRoutes.js
--- a/adminBackend/Routes/mainRoutes.js	(revision 0d7570bdb9f683916152c4dab2893a71e6cd377e)
+++ b/adminBackend/Routes/mainRoutes.js	(date 1739959198223)
@@ -5,280 +5,432 @@
 const router = express.Router();
 
 // Save  new item
-router.post("/add-item", upload.fields([{ name: "img", maxCount: 1 }, { name: "img1", maxCount: 1 }, { name: "img2", maxCount: 1 }, { name: "img3", maxCount: 1 }]), async (req, res) => {
+router.post("/add-item", upload.fields([
+    { name: "img", maxCount: 1 },
+    { name: "img1", maxCount: 1 },
+    { name: "img2", maxCount: 1 },
+    { name: "img3", maxCount: 1 }
+]), async (req, res) => {
     try {
-        // Validate request body
-        const { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost ,material,s_Id } = req.body;
-        // Convert data to appropriate types
+        const { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, s_Id } = req.body;
         const parsedPrice = parseFloat(price) || 0;
         const parsedCost = parseFloat(cost) || 0;
 
-        // Extract image buffers
-        const imgBuffer = req.files["img"][0].buffer;
-        const img1Buffer = req.files["img1"][0].buffer;
-        const img2Buffer = req.files["img2"][0].buffer ;
-        const img3Buffer = req.files["img3"][0].buffer;
-
-        const itemValues = [
-            I_Id, I_name, Ty_id, descrip, color,material, parsedPrice, imgBuffer, warrantyPeriod
-        ];
-        const imgValues = [
-            I_Id, img1Buffer ? Buffer.from(img1Buffer) : null, img2Buffer ? Buffer.from(img2Buffer) : null, img3Buffer ? Buffer.from(img3Buffer) : null
-        ];
-        const supplierValues = [
-            I_Id, s_Id,parsedCost
-        ];
-        // Insert into `Item` table (Main image)
-        const itemSql = `INSERT INTO Item (I_Id, I_name, Ty_id, descrip, color,material, price, stockQty, bookedQty, availableQty, img, warrantyPeriod) 
-                         VALUES (?, ?, ?, ?, ?,?,?, 0, 0, 0, ?, ?);`;
+        // ✅ Check if `Ty_id` exists in `Type` table
+        const [typeCheck] = await db.query(`SELECT Ty_Id FROM Type WHERE Ty_Id = ?`, [Ty_id]);
+        if (typeCheck.length === 0) {
+            return res.status(400).json({ success: false, message: `Invalid Type ID: ${Ty_id}` });
+        }
 
-        const query = await db.query(itemSql, itemValues);
-        console.log("query");
+        // ✅ Check if `s_Id` exists in `Supplier` table
+        const [supplierCheck] = await db.query(`SELECT s_ID FROM Supplier WHERE s_ID = ?`, [s_Id]);
+        if (supplierCheck.length === 0) {
+            return res.status(400).json({ success: false, message: `Invalid Supplier ID: ${s_Id}` });
+        }
 
-        // Insert into `Item_img` table (Additional images)
-        const imgSql = `INSERT INTO Item_img (I_Id, img1, img2, img3) VALUES (?, ?, ?, ?);`;
+        // ✅ Extract image buffers safely
+        const imgBuffer = req.files["img"]?.[0]?.buffer || null;
+        const img1Buffer = req.files["img1"]?.[0]?.buffer || null;
+        const img2Buffer = req.files["img2"]?.[0]?.buffer || null;
+        const img3Buffer = req.files["img3"]?.[0]?.buffer || null;
 
-        const query1 = await db.query(imgSql, imgValues);
-        console.log("query1");
+        // ✅ Insert into `Item` table
+        const itemSql = `
+            INSERT INTO Item (I_Id, I_name, Ty_id, descrip, color, material, price, stockQty, bookedQty, availableQty, img, img1, img2, img3, warrantyPeriod) 
+            VALUES (?, ?, ?, ?, ?, ?, ?, 0, 0, 0, ?, ?, ?, ?, ?);
+        `;
+        await db.query(itemSql, [I_Id, I_name, Ty_id, descrip, color, material, parsedPrice, imgBuffer, img1Buffer, img2Buffer, img3Buffer, warrantyPeriod]);
 
-        // Insert into `Item_supplier` table
-        const itemsuplierSql = `INSERT INTO item_supplier (I_Id, s_ID,unit_cost) VALUES (?, ?,?);`;
-
-        const query2 = await db.query(itemsuplierSql, supplierValues);
-        console.log("query2");
+        // ✅ Insert into `Item_supplier` table
+        const supplierSql = `INSERT INTO item_supplier (I_Id, s_ID, unit_cost) VALUES (?, ?, ?);`;
+        await db.query(supplierSql, [I_Id, s_Id, parsedCost]);
 
         res.status(201).json({
             success: true,
-            message: "Item added successfully",
-            data: {
-                I_Id,
-                I_name,
-                Ty_id: Ty_id,
-                descrip,
-                color,
-                material,
-                price: parsedPrice,
-                warrantyPeriod,
-                cost: parsedCost
-            }
+            message: "✅ Item added successfully!",
+            data: { I_Id, I_name, Ty_id, descrip, color, material, price: parsedPrice, warrantyPeriod, cost: parsedCost }
         });
+
     } catch (err) {
         console.error("❌ Error inserting item data:", err.message);
         res.status(500).json({ success: false, message: "Error inserting data into database", details: err.message });
     }
 });
 
+
+
+
 // Update exit item
-// router.put("/update-item", upload.fields([{ name: "img", maxCount: 1 }, { name: "img1", maxCount: 1 }, { name: "img2", maxCount: 1 }, { name: "img3", maxCount: 1 }]), async (req, res) => {
-//     try {
-//         // Extract request body and parse incoming form data
-//         const { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty  } = req.body;
+// router.put("/update-item", upload.fields([{ name: "img", maxCount: 1 },{ name: "img1", maxCount: 1 },{ name: "img2", maxCount: 1 }, { name: "img3", maxCount: 1 },]), async (req, res) => {
+//         try {
+//             // Extract request body data
+//             const {
+//                 I_Id,
+//                 I_name,
+//                 Ty_id,
+//                 descrip,
+//                 color,
+//                 price,
+//                 warrantyPeriod,
+//                 cost,
+//                 material,
+//                 suppliers,
+//                 availableQty,
+//                 bookedQty,
+//                 stockQty,
+//             } = req.body;
+//             console.log(req.body);
 //
-//         // Parse price and cost fields to float
-//         const parsedPrice = parseFloat(price) || 0;
-//         const parsedCost = parseFloat(cost) || 0;
+//             // Parse price and cost values
+//             const parsedPrice = parseFloat(price) || 0;
+//             const parsedCost = parseFloat(cost) || 0;
 //
-//          // console.log("🔹 Request Data:", { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty });
-//
-//         // Ensure I_Id exists in the database
-//         const itemCheckSql = `SELECT * FROM Item WHERE I_Id = ?`;
-//         const [itemCheckResult] = await db.query(itemCheckSql, [I_Id]);
+//             // ✅ Check if the item exists
+//             const itemCheckSql = `SELECT * FROM Item WHERE I_Id = ?`;
+//             const [itemCheckResult] = await db.query(itemCheckSql, [I_Id]);
 //
-//         if (itemCheckResult.length === 0) {
-//             return res.status(404).json({ success: false, message: "Item not found." });
-//         }
+//             if (itemCheckResult.length === 0) {
+//                 return res.status(404).json({ success: false, message: "Item not found." });
+//             }
 //
-//         // Handle image files, if any
-//         // const imgBuffer = req.files["img"]?.[0]?.buffer || null;
-//         // const img1Buffer = req.files["img1"]?.[0]?.buffer || null;
-//         // const img2Buffer = req.files["img2"]?.[0]?.buffer || null;
-//         // const img3Buffer = req.files["img3"]?.[0]?.buffer || null;
-//         const imgBuffer = req.files["img"][0].buffer;
-//         const img1Buffer = req.files["img1"][0].buffer;
-//         const img2Buffer = req.files["img2"][0].buffer ;
-//         const img3Buffer = req.files["img3"][0].buffer;
-//
-//         console.log(imgBuffer,img1Buffer,img2Buffer,img3Buffer);
+//             // ✅ Handle image updates (Only include images that were provided)
+//             const imgBuffer = req.files["img"]?.[0]?.buffer || null;
+//             const img1Buffer = req.files["img1"]?.[0]?.buffer || null;
+//             const img2Buffer = req.files["img2"]?.[0]?.buffer || null;
+//             const img3Buffer = req.files["img3"]?.[0]?.buffer || null;
 //
-//         // Update `Item` table with regular fields
-//         const itemUpdateSql = `
+//             // Update `Item` table with regular fields
+//             const itemUpdateSql = `
 //             UPDATE Item
-//             SET I_name = ?, Ty_id = ?, descrip = ?, color = ?, material = ?, price = ?, availableQty = ?, bookedQty = ?, stockQty = ?, img = ?, warrantyPeriod = ?
+//             SET I_name = ?, Ty_id = ?, descrip = ?, color = ?, material = ?, price = ?, availableQty = ?, bookedQty = ?, stockQty = ?, img = ?, warrantyPeriod = ? ,img1 = ? ,img2 = ? ,img3 = ?
 //             WHERE I_Id = ?;
 //         `;
-//         const itemValues = [
-//             I_name, Ty_id, descrip, color, material, parsedPrice, availableQty, bookedQty, stockQty, imgBuffer, warrantyPeriod, I_Id
-//         ];
-//         // console.log(itemValues);
-//         // await db.query(itemUpdateSql, itemValues);
-//         // **Handle Suppliers (Array of suppliers from formData)**
-//         if (suppliers && Array.isArray(suppliers)) {
-//             console.log("pass");
-//             for (const supplier of suppliers) {
+//             const itemValues = [
+//                 I_name, Ty_id, descrip, color, material, parsedPrice, availableQty, bookedQty, stockQty, imgBuffer, warrantyPeriod, img1Buffer, img2Buffer, img3Buffer, I_Id
+//             ];
+//              console.log(itemValues);
+//
+//            // await db.query(itemUpdateSql, itemValues);
+//             // **Handle Suppliers (Array of suppliers from formData)**
+//             if (suppliers && Array.isArray(suppliers)) {
+//                 console.log("pass");
+//                 for (const supplier of suppliers) {
 //
-//                 const { s_ID, unit_cost } = supplier;
-//                 console.log(supplier);
-//                 const parsedUnitCost = parseFloat(unit_cost) || 0;
+//                     const { s_ID, unit_cost } = supplier;
+//                     console.log(supplier);
+//                     const parsedUnitCost = parseFloat(unit_cost) || 0;
 //
-//                 // Update or insert supplier cost data
-//                 const supplierUpdateSql = `
+//                     // Update or insert supplier cost data
+//                     const supplierUpdateSql = `
 //                     INSERT INTO item_supplier (I_Id, s_ID, unit_cost)
 //                     VALUES (?, ?, ?)
 //                     ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost);
 //                 `;
-//                 const supplierValues = [
-//                     I_Id, s_ID, parsedUnitCost
-//                 ];
-//                 console.log(supplierValues);
-//                 // await db.query(supplierUpdateSql, supplierValues);
-//             }
-//         }
+//                     const supplierValues = [
+//                         I_Id, s_ID, parsedUnitCost
+//                     ];
+//                     console.log(supplierValues);
+//                     // await db.query(supplierUpdateSql, supplierValues);
+//                 }
+//             }
 //
-//         // Handle image updates for `Item_img` table (if any images are provided)
-//         if (img1Buffer || img2Buffer || img3Buffer) {
-//             const imgUpdateSql = `
-//                 UPDATE Item_img
-//                 SET img1 = ?, img2 = ?, img3 = ?
-//                 WHERE I_Id = ?;
-//             `;
-//             const imgValues = [
-//                 img1Buffer, img2Buffer, img3Buffer, I_Id
-//             ];
-//              console.log(imgValues);
-//             // await db.query(imgUpdateSql, imgValues);
-//         }
-//
-//
-//
-//         // Respond with success
-//         res.status(200).json({
-//             success: true,
-//             message: "Item updated successfully",
-//             data: {
-//                 I_Id,
-//                 I_name,
-//                 Ty_id,
-//                 descrip,
-//                 color,
-//                 material,
-//                 price: parsedPrice,
-//                 warrantyPeriod,
-//                 availableQty,
-//                 bookedQty,
-//                 stockQty
-//             }
-//         });
-//
-//     } catch (err) {
-//         console.error("❌ Error updating item data:", err.message);
-//         res.status(500).json({ success: false, message: "Error updating data into database", details: err.message });
+//             // ✅ Respond with success message
+//             res.status(200).json({
+//                 success: true,
+//                 message: "Item updated successfully",
+//                 data: {
+//                     I_Id,
+//                     I_name,
+//                     Ty_id,
+//                     descrip,
+//                     color,
+//                     material,
+//                     price: parsedPrice,
+//                     warrantyPeriod,
+//                     availableQty,
+//                     bookedQty,
+//                     stockQty,
+//                 },
+//             });
+//         } catch (err) {
+//             console.error("❌ Error updating item data:", err.message);
+//             res.status(500).json({ success: false, message: "Error updating data", details: err.message });
+//         }
 //     }
-// });
-router.put("/update-item",  async (req, res) => {
-    try {
-        // Extract request body and parse incoming form data
-        const { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty  } = req.body;
+// );
+
+
+router.put(
+    "/update-item",
+    upload.fields([
+        { name: "img", maxCount: 1 },
+        { name: "img1", maxCount: 1 },
+        { name: "img2", maxCount: 1 },
+        { name: "img3", maxCount: 1 },
+    ]),
+    async (req, res) => {
+        try {
+            // ✅ Extract request body
+            let {
+                I_Id,
+                I_name,
+                Ty_id,
+                descrip,
+                color,
+                price,
+                warrantyPeriod,
+                material,
+                suppliers,
+                availableQty,
+                bookedQty,
+                stockQty,
+            } = req.body;
 
-        // Parse price and cost fields to float
-        const parsedPrice = parseFloat(price) || 0;
-        const parsedCost = parseFloat(cost) || 0;
+            // console.log(req.body);
 
-         console.log("🔹 Request Data:", { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty });
+            // ✅ Ensure `I_Id` is provided
+            if (!I_Id) {
+                return res.status(400).json({ success: false, message: "Item ID is required." });
+            }
 
-        // Ensure I_Id exists in the database
-        const itemCheckSql = `SELECT * FROM Item WHERE I_Id = ?`;
-        const [itemCheckResult] = await db.query(itemCheckSql, [I_Id]);
+            // ✅ Check if the item exists
+            const itemCheckSql = `SELECT * FROM Item WHERE I_Id = ?`;
+            const [itemCheckResult] = await db.query(itemCheckSql, [I_Id]);
 
-        if (itemCheckResult.length === 0) {
-            return res.status(404).json({ success: false, message: "Item not found." });
-        }
+            if (itemCheckResult.length === 0) {
+                return res.status(404).json({ success: false, message: "Item not found." });
+            }
 
-        // Handle image files, if any
-        // const imgBuffer = req.files["img"]?.[0]?.buffer || null;
-        // const img1Buffer = req.files["img1"]?.[0]?.buffer || null;
-        // const img2Buffer = req.files["img2"]?.[0]?.buffer || null;
-        // const img3Buffer = req.files["img3"]?.[0]?.buffer || null;
-        // const imgBuffer = req.files["img"][0].buffer;
-        // const img1Buffer = req.files["img1"][0].buffer;
-        // const img2Buffer = req.files["img2"][0].buffer ;
-        // const img3Buffer = req.files["img3"][0].buffer;
+            // ✅ Parse numeric values
+            const parsedPrice = parseFloat(price) || 0;
+
+            // ✅ Handle images (Only update images that were provided)
+            const imgBuffer = req.files["img"]?.[0]?.buffer || null;
+            const img1Buffer = req.files["img1"]?.[0]?.buffer || null;
+            const img2Buffer = req.files["img2"]?.[0]?.buffer || null;
+            const img3Buffer = req.files["img3"]?.[0]?.buffer || null;
+
+            // ✅ Construct dynamic update query for `Item` table
+            let updateFields = [];
+            let updateValues = [];
+
+            if (I_name) updateFields.push("I_name = ?");
+            if (Ty_id) updateFields.push("Ty_id = ?");
+            if (descrip) updateFields.push("descrip = ?");
+            if (color) updateFields.push("color = ?");
+            if (material) updateFields.push("material = ?");
+            if (parsedPrice) updateFields.push("price = ?");
+            if (availableQty !== undefined) updateFields.push("availableQty = ?");
+            if (bookedQty !== undefined) updateFields.push("bookedQty = ?");
+            if (stockQty !== undefined) updateFields.push("stockQty = ?");
+            if (warrantyPeriod) updateFields.push("warrantyPeriod = ?");
+            if (imgBuffer) updateFields.push("img = ?");
+            if (img1Buffer) updateFields.push("img1 = ?");
+            if (img2Buffer) updateFields.push("img2 = ?");
+            if (img3Buffer) updateFields.push("img3 = ?");
 
-        // console.log(imgBuffer,img1Buffer,img2Buffer,img3Buffer);
+            updateValues = [
+                I_name,
+                Ty_id,
+                descrip,
+                color,
+                material,
+                parsedPrice,
+                availableQty,
+                bookedQty,
+                stockQty,
+                warrantyPeriod,
+                imgBuffer,
+                img1Buffer,
+                img2Buffer,
+                img3Buffer
+            ].filter((value) => value !== undefined);
+           // console.log(updateFields);
 
-        // Update `Item` table with regular fields
-        const itemUpdateSql = `
-            UPDATE Item
-            SET I_name = ?, Ty_id = ?, descrip = ?, color = ?, material = ?, price = ?, availableQty = ?, bookedQty = ?, stockQty = ?, img = ?, warrantyPeriod = ?
-            WHERE I_Id = ?;
-        `;
-        const itemValues = [
-            I_name, Ty_id, descrip, color, material, parsedPrice, availableQty, bookedQty, stockQty, imgBuffer, warrantyPeriod, I_Id
-        ];
-         console.log(itemValues);
-        // await db.query(itemUpdateSql, itemValues);
-        // **Handle Suppliers (Array of suppliers from formData)**
-        if (suppliers && Array.isArray(suppliers)) {
-            console.log("pass");
-            for (const supplier of suppliers) {
-
-                const { s_ID, unit_cost } = supplier;
-                console.log(supplier);
-                const parsedUnitCost = parseFloat(unit_cost) || 0;
+            if (updateFields.length > 0) {
+                const updateQuery = `UPDATE Item SET ${updateFields.join(", ")} WHERE I_Id = ?`;
+                console.log(updateQuery);
+                updateValues.push(I_Id);
+                await db.query(updateQuery, updateValues);
+            }
+
+            // ✅ Handle `suppliers` (Ensure it's an array)
+            if (suppliers) {
+                if (typeof suppliers === "string") {
+                    suppliers = JSON.parse(suppliers); // Convert string to JSON if necessary
+                    console.log(suppliers);
+                }
+                if (Array.isArray(suppliers)) {
+                    for (const supplier of suppliers) {
+                        const { s_ID, unit_cost } = supplier;
+                        const parsedUnitCost = parseFloat(unit_cost) || 0;
 
-                // Update or insert supplier cost data
-                const supplierUpdateSql = `
-                    INSERT INTO item_supplier (I_Id, s_ID, unit_cost)
-                    VALUES (?, ?, ?)
-                        ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost);
-                `;
-                const supplierValues = [
-                    I_Id, s_ID, parsedUnitCost
-                ];
-                console.log(supplierValues);
-                // await db.query(supplierUpdateSql, supplierValues);
-            }
-        }
-
-        // // Handle image updates for `Item_img` table (if any images are provided)
-        // if (img1Buffer || img2Buffer || img3Buffer) {
-        //     const imgUpdateSql = `
-        //         UPDATE Item_img
-        //         SET img1 = ?, img2 = ?, img3 = ?
-        //         WHERE I_Id = ?;
-        //     `;
-        //     const imgValues = [
-        //         img1Buffer, img2Buffer, img3Buffer, I_Id
-        //     ];
-        //     console.log(imgValues);
-        //     // await db.query(imgUpdateSql, imgValues);
-        // }
-
-
+                        const supplierUpdateSql = `
+                            INSERT INTO item_supplier (I_Id, s_ID, unit_cost)
+                            VALUES (?, ?, ?)
+                            ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost);
+                        `;
+                        await db.query(supplierUpdateSql, [I_Id, s_ID, parsedUnitCost]);
+                    }
+                }
+            }
 
-        // Respond with success
-        res.status(200).json({
-            success: true,
-            message: "Item updated successfully",
-            data: {
-                I_Id,
-                I_name,
-                Ty_id,
-                descrip,
-                color,
-                material,
-                price: parsedPrice,
-                warrantyPeriod,
-                availableQty,
-                bookedQty,
-                stockQty
-            }
-        });
-
-    } catch (err) {
-        console.error("❌ Error updating item data:", err.message);
-        res.status(500).json({ success: false, message: "Error updating data into database", details: err.message });
+            // ✅ Respond with success message
+            res.status(200).json({
+                success: true,
+                message: "Item updated successfully",
+                data: {
+                    I_Id,
+                    I_name,
+                    Ty_id,
+                    descrip,
+                    color,
+                    material,
+                    price: parsedPrice,
+                    warrantyPeriod,
+                    availableQty,
+                    bookedQty,
+                    stockQty,
+                },
+            });
+        } catch (err) {
+            console.error("❌ Error updating item data:", err.message);
+            res.status(500).json({ success: false, message: "Error updating data", details: err.message });
+        }
     }
-});
+);
+
+// Update exit item
+// router.put("/update-item", upload.fields([{ name: "img", maxCount: 1 }, { name: "img1", maxCount: 1 }, { name: "img2", maxCount: 1 }, { name: "img3", maxCount: 1 }]), async (req, res) => {
+//     try {
+//         // Extract request body and parse incoming form data
+//         const { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty  } = req.body;
+//
+//         // Parse price and cost fields to float
+//         const parsedPrice = parseFloat(price) || 0;
+//         const parsedCost = parseFloat(cost) || 0;
+//
+//          // console.log("🔹 Request Data:", { I_Id, I_name, Ty_id, descrip, color, price, warrantyPeriod, cost, material, suppliers, availableQty, bookedQty, stockQty });
+//
+//         // Ensure I_Id exists in the database
+//         const itemCheckSql = `SELECT * FROM Item WHERE I_Id = ?`;
+//         const [itemCheckResult] = await db.query(itemCheckSql, [I_Id]);
+//
+//         if (itemCheckResult.length === 0) {
+//             return res.status(404).json({ success: false, message: "Item not found." });
+//         }
+//
+//         // Handle image files, if any
+//         // const imgBuffer = req.files["img"]?.[0]?.buffer || null;
+//         // const img1Buffer = req.files["img1"]?.[0]?.buffer || null;
+//         // const img2Buffer = req.files["img2"]?.[0]?.buffer || null;
+//         // const img3Buffer = req.files["img3"]?.[0]?.buffer || null;
+//         const imgBuffer = req.files["img"][0].buffer;
+//         const img1Buffer = req.files["img1"][0].buffer;
+//         const img2Buffer = req.files["img2"][0].buffer ;
+//         const img3Buffer = req.files["img3"][0].buffer;
+//
+//         console.log(imgBuffer,img1Buffer,img2Buffer,img3Buffer);
+//
+
+
+
+//
+//         // Handle image updates for `Item_img` table (if any images are provided)
+//         if (img1Buffer || img2Buffer || img3Buffer) {
+//             const imgUpdateSql = `
+//                 UPDATE Item_img
+//                 SET img1 = ?, img2 = ?, img3 = ?
+//                 WHERE I_Id = ?;
+//             `;
+//             const imgValues = [
+//                 img1Buffer, img2Buffer, img3Buffer, I_Id
+//             ];
+//              console.log(imgValues);
+//             // await db.query(imgUpdateSql, imgValues);
+//         }
+//
+//  // ✅ Construct dynamic `UPDATE` query for `Item` table
+//           //   let updateFields = [];
+//           //   let updateValues = [];
+//           //
+//           //   if (I_name) updateFields.push("I_name = ?");
+//           //   if (Ty_id) updateFields.push("Ty_id = ?");
+//           //   if (descrip) updateFields.push("descrip = ?");
+//           //   if (color) updateFields.push("color = ?");
+//           //   if (material) updateFields.push("material = ?");
+//           //   if (parsedPrice) updateFields.push("price = ?");
+//           //   if (availableQty) updateFields.push("availableQty = ?");
+//           //   if (bookedQty) updateFields.push("bookedQty = ?");
+//           //   if (stockQty) updateFields.push("stockQty = ?");
+//           //   if (warrantyPeriod) updateFields.push("warrantyPeriod = ?");
+//           //   if (imgBuffer) updateFields.push("img = ?");
+//           //   if (img1Buffer) updateFields.push("img1 = ?");
+//           //   if (img2Buffer) updateFields.push("img2 = ?");
+//           //   if (img3Buffer) updateFields.push("img3 = ?");
+//           //
+//           //   updateValues = [
+//           //       I_name,
+//           //       Ty_id,
+//           //       descrip,
+//           //       color,
+//           //       material,
+//           //       parsedPrice,
+//           //       availableQty,
+//           //       bookedQty,
+//           //       stockQty,
+//           //       warrantyPeriod,
+//           //       imgBuffer,
+//           //       img1Buffer,
+//           //       img2Buffer,
+//           //       img3Buffer,
+//           //   ].filter((value) => value !== undefined);
+//           //
+//           //   if (updateFields.length > 0) {
+//           //       const updateQuery = `UPDATE Item SET ${updateFields.join(", ")} WHERE I_Id = ?`;
+//           //       updateValues.push(I_Id);
+//           //       await db.query(updateQuery, updateValues);
+//           //   }
+//           //
+//           //   // ✅ Handle suppliers update (Insert or update in `item_supplier`)
+//           //   if (suppliers && Array.isArray(suppliers)) {
+//           //       for (const supplier of suppliers) {
+//           //           const { s_ID, unit_cost } = supplier;
+//           //           const parsedUnitCost = parseFloat(unit_cost) || 0;
+//           //
+//           //           const supplierUpdateSql = `
+//           //     INSERT INTO item_supplier (I_Id, s_ID, unit_cost)
+//           //     VALUES (?, ?, ?)
+//           //     ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost);
+//           // `;
+//           //           await db.query(supplierUpdateSql, [I_Id, s_ID, parsedUnitCost]);
+//           //       }
+//           //   }
+//
+//         // Respond with success
+//         res.status(200).json({
+//             success: true,
+//             message: "Item updated successfully",
+//             data: {
+//                 I_Id,
+//                 I_name,
+//                 Ty_id,
+//                 descrip,
+//                 color,
+//                 material,
+//                 price: parsedPrice,
+//                 warrantyPeriod,
+//                 availableQty,
+//                 bookedQty,
+//                 stockQty
+//             }
+//         });
+//
+//     } catch (err) {
+//         console.error("❌ Error updating item data:", err.message);
+//         res.status(500).json({ success: false, message: "Error updating data into database", details: err.message });
+//     }
+// });
 
 
 // Get all orders
@@ -351,30 +503,58 @@
     }
 });
 
-// Save Supplier
+//add a new supplier and items
 router.post("/supplier", async (req, res) => {
-    const sql = `INSERT INTO Supplier (s_ID,name,contact) VALUES (?, ?,?)`;
-    const values = [
-        req.body.s_ID,
-        req.body.name,
-        req.body.contact,
+    const { name, contact, contact2, address, items } = req.body;
+
+    // Generate new supplier ID
+    const s_ID = await generateNewIds("Supplier", "s_ID", "S");
+    console.log(s_ID);
+    const sqlInsertSupplier = `
+        INSERT INTO Supplier (s_ID, name, address, contact, contact2)
+        VALUES (?, ?, ?, ?, ?)
+    `;
+    const valuesSupplier = [
+        s_ID,
+        name,
+        address,
+        contact,
+        contact2 || "", // If contact2 is empty, set it as an empty string
     ];
+
     try {
-        // Execute the query and retrieve the result
-        const [result] = await db.query(sql, values);
+        // Insert the supplier into the Supplier table
+        await db.query(sqlInsertSupplier, valuesSupplier);
+
+        // Insert items into the item_supplier table
+        if (items && items.length > 0) {
+            // Prepare the insert query for items
+            const itemQueries = items.map((item) => {
+                return db.query(
+                    "INSERT INTO item_supplier (I_Id, s_ID, unit_cost) VALUES (?, ?, ?)",
+                    [item.I_Id, s_ID, item.cost]
+                );
+            });
 
-        // Return success response with inserted data details
+            // Execute all insert queries for items in parallel
+            await Promise.all(itemQueries);
+        }
+
+        // Respond with success message and new supplier details
         return res.status(201).json({
             success: true,
-            message: "Suppplier added successfully",
+            message: "Supplier and items added successfully",
             data: {
-                s_ID: req.body.s_ID,
-                name: req.body.name,
-                contact : req.body.contact
+                s_ID,
+                name,
+                contact,
+                contact2,
+                address,
+                items, // Including the items linked to the supplier
             },
         });
     } catch (err) {
-        console.error("Error inserting supplier data:", err.message);
+        console.error("Error inserting supplier or item data:", err.message);
 
         // Respond with error details
         return res.status(500).json({
@@ -665,11 +845,11 @@
             return res.status(400).json({ success: false, message: "Item ID is required" });
         }
 
-        // Fetch item details along with Type and Category information
+        // ✅ Fetch item details along with Type and Category information
         const itemQuery = `
             SELECT
                 I.I_Id, I.I_name, I.Ty_id, I.descrip, I.price, I.stockQty, I.bookedQty, I.availableQty,
-                I.warrantyPeriod, I.img, I.color, I.material,
+                I.warrantyPeriod, I.img, I.img1, I.img2, I.img3, I.color, I.material,
                 T.sub_one, T.sub_two, C.Ca_Id, C.name AS category_name
             FROM Item I
             JOIN Type T ON I.Ty_id = T.Ty_Id
@@ -684,24 +864,13 @@
 
         const itemData = itemResult[0];
 
-        // Fetch additional images from Item_img table
-        const imageQuery = `SELECT img1, img2, img3 FROM Item_img WHERE I_Id = ?`;
-        const [imageResult] = await db.query(imageQuery, [I_Id]);
-
-        let imgData = { img1: null, img2: null, img3: null };
-
-        if (imageResult.length > 0) {
-            imgData = {
-                img1: imageResult[0].img1 ? Buffer.from(imageResult[0].img1).toString("base64") : null,
-                img2: imageResult[0].img2 ? Buffer.from(imageResult[0].img2).toString("base64") : null,
-                img3: imageResult[0].img3 ? Buffer.from(imageResult[0].img3).toString("base64") : null,
-            };
-        }
-
-        // Convert the main image from Item table to Base64
+        // ✅ Convert images to Base64
         const mainImgBase64 = itemData.img ? Buffer.from(itemData.img).toString("base64") : null;
+        const img1Base64 = itemData.img1 ? Buffer.from(itemData.img1).toString("base64") : null;
+        const img2Base64 = itemData.img2 ? Buffer.from(itemData.img2).toString("base64") : null;
+        const img3Base64 = itemData.img3 ? Buffer.from(itemData.img3).toString("base64") : null;
 
-        // Fetch all suppliers that provide this item along with unit_cost
+        // ✅ Fetch all suppliers that provide this item along with unit_cost
         const supplierQuery = `
             SELECT S.s_ID, S.name, S.contact, ISUP.unit_cost
             FROM Supplier S
@@ -717,7 +886,7 @@
             unit_cost: supplier.unit_cost // Include unit cost
         }));
 
-        // Construct final response
+        // ✅ Construct final response
         const responseData = {
             success: true,
             item: {
@@ -732,10 +901,10 @@
                 availableQty: itemData.availableQty,
                 bookedQty: itemData.bookedQty,
                 warrantyPeriod: itemData.warrantyPeriod,
-                img: mainImgBase64, // Main image from Item table
-                img1: imgData.img1, // Additional Image 1
-                img2: imgData.img2, // Additional Image 2
-                img3: imgData.img3, // Additional Image 3
+                img: mainImgBase64,  // Main image from Item table
+                img1: img1Base64,     // Additional Image 1
+                img2: img2Base64,     // Additional Image 2
+                img3: img3Base64,     // Additional Image 3
                 category_id: itemData.Ca_Id, // Category ID
                 category_name: itemData.category_name, // Category name
                 subcategory_one: itemData.sub_one, // Subcategory One
@@ -747,11 +916,12 @@
         return res.status(200).json(responseData);
 
     } catch (error) {
-        console.error("Error fetching item details:", error.message);
+        console.error("❌ Error fetching item details:", error.message);
         return res.status(500).json({ success: false, message: "Server error", error: error.message });
     }
 });
 
+
 // Get all orders by status= pending
 router.get("/orders-pending", async (req, res) => {
     try {
@@ -2528,14 +2698,229 @@
     }
 });
 
+// Fetch all coupons
+router.get("/coupon-details", async (req, res) => {
+    try {
+        const query = `
+            SELECT 
+                sc.cpID AS coupon_code,
+                sc.discount,
+                st.stID AS sales_team_id,
+                e.name AS employee_name
+            FROM sales_coupon sc
+            JOIN sales_team st ON sc.stID = st.stID
+            JOIN Employee e ON st.E_Id = e.E_Id
+        `;
+
+        const [results] = await db.query(query);
+
+        if (results.length === 0) {
+            return res.status(404).json({ success: false, message: "No coupon details found" });
+        }
+
+        return res.status(200).json({
+            success: true,
+            message: "Coupon details retrieved successfully",
+            data: results,
+        });
+    } catch (error) {
+        console.error("Error fetching coupon details:", error.message);
+        return res.status(500).json({
+            success: false,
+            message: "Error fetching coupon details",
+            error: error.message,
+        });
+    }
+});
+
+// Fetch all coupons
+router.get("/delivery-rates", async (req, res) => {
+    try {
+        const query = `SELECT * FROM deli_rates`;
+
+        const [results] = await db.query(query);
+
+        if (results.length === 0) {
+            return res.status(404).json({ success: false, message: "No rates details found" });
+        }
+
+        return res.status(200).json({
+            success: true,
+            message: "Rates details retrieved successfully",
+            data: results,
+        });
+    } catch (error) {
+        console.error("Error fetching  details:", error.message);
+        return res.status(500).json({
+            success: false,
+            message: "Error fetching details",
+            error: error.message,
+        });
+    }
+});
+
+// GET API to fetch delivery schedule by district
+router.get("/delivery-schedule", async (req, res) => {
+    const { district } = req.query; // Get district from query parameter
+
+    if (!district) {
+        return res.status(400).json({ message: "District is required" });
+    }
+
+    try {
+        // Fetch all delivery dates for the given district
+        const [result] = await db.query(
+            "SELECT ds_date FROM delivery_schedule WHERE district = ?",
+            [district]
+        );
+        console.log(result);
+
+        if (result.length === 0) {
+            return res.status(404).json({ message: "District not found" });
+        }
+
+        // Get the current date (yyyy-mm-dd format)
+        const currentDate = new Date().toISOString().split("T")[0];
+
+        // Filter and sort dates
+        const upcomingDates = result
+            .map(row => {
+                // Convert ds_date to a string in yyyy-mm-dd format (ignoring time part)
+                const date = new Date(row.ds_date).toISOString().split("T")[0];
+                return date;
+            })
+            .filter(date => date >= currentDate) // Keep only upcoming dates
+            .sort((a, b) => new Date(a) - new Date(b)); // Sort in ascending order
+
+        if (upcomingDates.length === 0) {
+            return res.status(404).json({ message: "No upcoming delivery dates available" });
+        }
+
+        return res.status(200).json({
+            message: "Upcoming delivery dates found",
+            district: district,
+            upcomingDates: upcomingDates,
+        });
+    } catch (error) {
+        console.error("Error fetching delivery schedule:", error.message);
+        return res.status(500).json({ message: "Error fetching delivery schedule" });
+    }
+});
+
+// Save a order
+router.post("/orders", async (req, res) => {
+    try {
+        const {
+            dvStatus,
+            address,
+            city,
+            district,
+            email,
+            customerName,
+            phoneNumber,
+            otherNumber,
+            items,
+            totalBillPrice,
+            deliveryPrice,
+            discountAmount,
+            couponCode,
+            expectedDate,
+            specialNote
+        } = req.body;
+        console.log(items);
+        // Generate unique order ID
+        const orID = `ORD_${Date.now()}`;
+        const orderDate = new Date().toISOString().split("T")[0]; // Get current date
+
+        // Initialize stID to null
+        let stID = null;
+
+        // Check if a coupon is provided, if yes fetch associated stID
+        if (couponCode) {
+            // Fetch the stID associated with the provided coupon ID (cpID)
+            const couponQuery = `SELECT stID FROM sales_coupon WHERE cpID = ?`;
+            const [couponResult] = await db.query(couponQuery, [couponCode]);
+
+            if (couponResult.length === 0) {
+                return res.status(400).json({
+                    success: false,
+                    message: "Invalid coupon code"
+                });
+            }
+
+            // Set the sales team ID (stID) from the coupon
+            stID = couponResult[0].stID;
+        }
+        // Insert Order
+        let orderQuery = `
+            INSERT INTO Orders (OrID, orDate,custName, customerEmail,contact1,contact2, orStatus, dvStatus,city, dvPrice, disPrice, totPrice, stID, expectedDate, specialNote,order_type)
+            VALUES (?, ?,?, ?,?,?, 'Pending', ?, ?, ?, ?, ?, ?, ?,?,'on-site')`;
+        let orderParams = [orID, orderDate,customerName, email,phoneNumber,otherNumber, dvStatus,city, deliveryPrice, discountAmount, totalBillPrice, stID, expectedDate, specialNote];
+
+        await db.query(orderQuery, orderParams);
+
+        // Insert Order Details
+        for (const item of items) {
+            let orderDetailQuery = `
+                INSERT INTO Order_Detail (orID, I_Id, qty, tprice)
+                VALUES (?, ?, ?, ?)`;
+            let orderDetailParams = [orID, item.I_Id, item.qty, item.price];
+
+            await db.query(orderDetailQuery, orderDetailParams);
+        }
+
+        // Insert Delivery Info if delivery is selected
+        if (dvStatus === "Delivery") {
+            const dvID = `DLV_${Date.now()}`;
+            let deliveryQuery = `
+                INSERT INTO delivery (dv_id, orID, address, district, contact, status,schedule_Date)
+                VALUES (?, ?, ?, ?, ?, 'Pending',?)`;
+            let deliveryParams = [dvID, orID, address, district, phoneNumber, expectedDate];
+
+            await db.query(deliveryQuery, deliveryParams);
+        }
+
+        // Insert Coupon Info if a coupon is used
+        if (couponCode) {
+            const ocID = `OCP_${Date.now()}`;
+            let couponQuery = `
+                INSERT INTO order_coupon (ocID, orID, cpID)
+                VALUES (?, ?, ?)`;
+            let couponParams = [ocID, orID, couponCode];
+
+            await db.query(couponQuery, couponParams);
+        }
+
+        return res.status(201).json({
+            success: true,
+            message: "Order placed successfully",
+            data: {
+                orID: orID,
+                orderDate: orderDate,
+                expectedDate: expectedDate
+            },
+        });
+
+    } catch (error) {
+        console.error("Error inserting order data:", error.message);
+
+        return res.status(500).json({
+            success: false,
+            message: "Error inserting data into database",
+            details: error.message,
+        });
+    }
+});
 // Function to generate new ida
 const generateNewId = async (table, column, prefix) => {
     const [rows] = await db.query(`SELECT ${column} FROM ${table} ORDER BY ${column} DESC LIMIT 1`);
     if (rows.length === 0) return `${prefix}_001`; // First entry
     const lastId = rows[0][column]; // Get last ID
+    console.log(lastId);
     const lastNum = parseInt(lastId.split("_")[1], 10) + 1; // Extract number and increment
+    console.log(lastNum);
+    console.log(`${prefix}_${String(lastNum).padStart(3, "0")}`);
     return `${prefix}_${String(lastNum).padStart(3, "0")}`;
 };
 
-
 export default router;
