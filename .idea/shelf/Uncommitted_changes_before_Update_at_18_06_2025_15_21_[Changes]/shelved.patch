Index: adminBackend/Routes/mainRoutes.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import express from 'express';\r\nimport upload from \"../middlewares/upload.js\";\r\nimport db from '../utils/db.js';\r\nimport bwipjs from 'bwip-js';\r\nimport path from \"path\";\r\nimport fs from \"fs\";\r\nimport moment from 'moment';\r\nimport mysql from \"mysql2\";\r\nimport { console } from 'inspector';\r\nconst router = express.Router();\r\n// const fs = require('fs');\r\n\r\n// Save  new item\r\nrouter.post(\"/add-item\", upload.fields([{ name: \"img\", maxCount: 1 }, { name: \"img1\", maxCount: 1 }, { name: \"img2\", maxCount: 1 }, { name: \"img3\", maxCount: 1 }]), async (req, res) => {\r\n    try {\r\n        const { I_Id, I_name, descrip, color, price, warrantyPeriod, cost, material, s_Id, minQty, Ca_Id, sub_one, sub_two } = req.body;\r\n        const parsedPrice = parseFloat(price) || 0;\r\n        const parsedCost = parseFloat(cost) || 0;\r\n\r\n        // ✅ Check if main category exists\r\n        const [mainCatCheck] = await db.query(`SELECT name FROM Category WHERE Ca_Id = ?`, [Ca_Id]);\r\n        if (mainCatCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Main Category: ${Ca_Id}` });\r\n        }\r\n        const mainCategoryName = mainCatCheck[0].name;\r\n\r\n        // ✅ Check if subCat_one exists\r\n        const [subCatOneCheck] = await db.query(`SELECT subcategory FROM subCat_one WHERE sb_c_id = ?`, [sub_one]);\r\n        if (subCatOneCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Sub Category One: ${sub_one}` });\r\n        }\r\n        const subCatOneName = subCatOneCheck[0].subcategory;\r\n\r\n        // ✅ Check if subCat_two exists or set as 'None'\r\n        let subCatTwoName = 'None';\r\n        if (sub_two !== 'None') {\r\n            const [subCatTwoCheck] = await db.query(`SELECT subcategory FROM subCat_two WHERE sb_cc_id = ?`, [sub_two]);\r\n            if (subCatTwoCheck.length === 0) {\r\n                return res.status(400).json({ success: false, message: `Invalid Sub Category Two: ${sub_two}` });\r\n            }\r\n            subCatTwoName = subCatTwoCheck[0].subcategory;\r\n        }\r\n\r\n        // ✅ Check if supplier exists\r\n        const [supplierCheck] = await db.query(`SELECT s_ID FROM Supplier WHERE s_ID = ?`, [s_Id]);\r\n        if (supplierCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Supplier ID: ${s_Id}` });\r\n        }\r\n\r\n        // ✅ Extract image buffers (only main image required)\r\n        const imgBuffer = req.files[\"img\"]?.[0]?.buffer || null;\r\n        const img1Buffer = req.files[\"img1\"]?.[0]?.buffer || null;\r\n        const img2Buffer = req.files[\"img2\"]?.[0]?.buffer || null;\r\n        const img3Buffer = req.files[\"img3\"]?.[0]?.buffer || null;\r\n\r\n        if (!imgBuffer) {\r\n            return res.status(400).json({ success: false, message: \"Main image (img) is required.\" });\r\n        }\r\n\r\n        // ✅ Insert into `Item` table\r\n        const itemSql = `\r\n            INSERT INTO Item (I_Id, I_name, descrip, color, material, price, stockQty, bookedQty, availableQty,reservedQty,dispatchedQty,damageQty, minQTY, img, img1, img2, img3, warrantyPeriod, mn_Cat, sb_catOne, sb_catTwo)\r\n            VALUES (?, ?, ?, ?, ?, ?, 0, 0, 0,0,0,0, ?, ?, ?, ?, ?, ?, ?, ?, ?);\r\n        `;\r\n        await db.query(itemSql, [\r\n            I_Id,\r\n            I_name,\r\n            descrip,\r\n            color,\r\n            material,\r\n            parsedPrice,\r\n            minQty,\r\n            imgBuffer,\r\n            img1Buffer,\r\n            img2Buffer,\r\n            img3Buffer,\r\n            warrantyPeriod,\r\n            mainCategoryName,\r\n            subCatOneName,\r\n            subCatTwoName\r\n        ]);\r\n\r\n        // ✅ Insert into `Item_supplier` table\r\n        const supplierSql = `INSERT INTO item_supplier (I_Id, s_ID, unit_cost) VALUES (?, ?, ?);`;\r\n        await db.query(supplierSql, [I_Id, s_Id, parsedCost]);\r\n\r\n        res.status(201).json({\r\n            success: true,\r\n            message: \"✅ Item added successfully!\",\r\n            data: {\r\n                I_Id,\r\n                I_name,\r\n                descrip,\r\n                color,\r\n                material,\r\n                price: parsedPrice,\r\n                warrantyPeriod,\r\n                cost: parsedCost,\r\n                mn_Cat: mainCategoryName,\r\n                sb_catOne: subCatOneName,\r\n                sb_catTwo: subCatTwoName\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"❌ Error inserting item data:\", err.message);\r\n        res.status(500).json({ success: false, message: \"Error inserting data into database\", details: err.message });\r\n    }\r\n});\r\n\r\n// Update item\r\nrouter.put(\"/update-item\", upload.fields([{ name: \"img\", maxCount: 1 }, { name: \"img1\", maxCount: 1 }, { name: \"img2\", maxCount: 1 }, { name: \"img3\", maxCount: 1 },]), async (req, res) => {\r\n    try {\r\n        const {previousId,I_Id, I_name, descrip, color, material, price, warrantyPeriod, stockQty, bookedQty, availableQty, maincategory, sub_one, sub_two, suppliers,} = req.body;\r\n\r\n        if (!previousId) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required.\" });\r\n        }\r\n\r\n        // ✅ Log received files and form data\r\n        const [itemCheckResult] = await db.query(`SELECT * FROM Item WHERE I_Id = ?`, [previousId]);\r\n        if (itemCheckResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found.\" });\r\n        }\r\n\r\n        const parsedPrice = parseFloat(price) || 0;\r\n\r\n        // ✅ Properly extract image buffers\r\n        const imgBuffer = req.files[\"img\"]?.[0]?.buffer || null;\r\n        const img1Buffer = req.files[\"img1\"]?.[0]?.buffer || null;\r\n        const img2Buffer = req.files[\"img2\"]?.[0]?.buffer || null;\r\n        const img3Buffer = req.files[\"img3\"]?.[0]?.buffer || null;\r\n\r\n        // ✅ Fetch subcategory names\r\n        let subCatOneName = null;\r\n        let subCatTwoName = sub_two !== \"None\" ? null : \"None\";\r\n\r\n        if (sub_one) {\r\n            const [subOneResult] = await db.query(`SELECT subcategory FROM subCat_one WHERE sb_c_id = ?`, [sub_one]);\r\n            subCatOneName = subOneResult[0]?.subcategory || null;\r\n        }\r\n\r\n        if (sub_two !== \"None\") {\r\n            const [subTwoResult] = await db.query(`SELECT subcategory FROM subCat_two WHERE sb_cc_id = ?`, [sub_two]);\r\n            subCatTwoName = subTwoResult[0]?.subcategory || null;\r\n        }\r\n\r\n        let updateFields = [];\r\n        let updateValues = [];\r\n\r\n        // ✅ Dynamic field updates\r\n        const fields = {\r\n           I_Id, I_name, descrip, color, material, price: parsedPrice, warrantyPeriod, stockQty, bookedQty, availableQty, mn_Cat: maincategory, sb_catOne: subCatOneName, sb_catTwo: subCatTwoName, img: imgBuffer, img1: img1Buffer, img2: img2Buffer, img3: img3Buffer,\r\n        };\r\n\r\n        for (const key in fields) {\r\n            if (fields[key] !== undefined && fields[key] !== null) {\r\n                updateFields.push(`${key} = ?`);\r\n                updateValues.push(fields[key]);\r\n            }\r\n        }\r\n\r\n        if (updateFields.length > 0) {\r\n            const updateQuery = `UPDATE Item SET ${updateFields.join(\", \")} WHERE I_Id = ?`;\r\n            updateValues.push(previousId);\r\n            await db.query(updateQuery, updateValues);\r\n        }\r\n\r\n        // ✅ Handle suppliers\r\n        if (suppliers) {\r\n            let supplierData = typeof suppliers === \"string\" ? JSON.parse(suppliers) : suppliers;\r\n            if (Array.isArray(supplierData)) {\r\n                for (const { s_ID, unit_cost } of supplierData) {\r\n                    const parsedUnitCost = parseFloat(unit_cost) || 0;\r\n                    await db.query(\r\n                        `INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n                         VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost)`,\r\n                        [previousId, s_ID, parsedUnitCost]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        res.status(200).json({\r\n            success: true,\r\n            message: \"Item updated successfully\",\r\n            data: { I_Id, I_name },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"❌ Error updating item:\", err.message);\r\n        res.status(500).json({ success: false, message: \"Error updating item\", details: err.message });\r\n    }\r\n});\r\n\r\n// Save a order\r\nrouter.post(\"/orders\", async (req, res) => {\r\n    const {\r\n        FtName, SrName, address, c_ID, category, newAddress, isAddressChanged,\r\n        couponCode, deliveryPrice, discountAmount, district, dvStatus,orderDate,\r\n        expectedDate, id, isNewCustomer, items, occupation, otherNumber = \"\",\r\n        phoneNumber = \"\", specialNote, title, totalItemPrice,issuable,totalBillPrice,\r\n        dvtype, type, workPlace, t_name, orderType, specialdiscountAmount,previousbalance,\r\n        advance, balance ,payment,subPayment,customerBalanceDecision,finalCustomerBalance,paymentAmount,cashReturn,\r\n        cardPayment={},chequePayment={},cashCardPayment={},tranferPayment={},creditPayment={},combinedChequePayment={},\r\n        combinedCreditPayment={},combinedTransferPayment={},\r\n    } = req.body;\r\n\r\n    if (!items || !Array.isArray(items) || items.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Invalid or missing items.\" });\r\n    }\r\n\r\n    try {\r\n        let Cust_id = c_ID;\r\n        let Occupation = \"-\", WorkPlace = \"-\", tType = \"-\";\r\n        let stID = null;\r\n        if (type === 'Walking' || type === 'On site') {\r\n            Occupation = occupation;\r\n            WorkPlace = workPlace;\r\n        } else {\r\n            tType = t_name;\r\n        }\r\n\r\n        const trimmedPhone = phoneNumber.trim();\r\n        const trimmedOther = otherNumber.trim();\r\n\r\n        // ✅ Handle New Customer\r\n        if (isNewCustomer) {\r\n            Cust_id = await generateNewId(\"Customer\", \"c_ID\", \"Cus\");\r\n\r\n            // \uD83D\uDD0D Safe and flexible contact search\r\n            let customerSearchQuery = `SELECT c_ID FROM Customer WHERE `;\r\n            let searchParams = [];\r\n\r\n            if (trimmedPhone && trimmedOther) {\r\n                customerSearchQuery += `(contact1 = ? OR contact2 = ? OR contact1 = ? OR contact2 = ?) LIMIT 1`;\r\n                searchParams = [trimmedPhone, trimmedPhone, trimmedOther, trimmedOther];\r\n            } else if (trimmedPhone) {\r\n                customerSearchQuery += `(contact1 = ? OR contact2 = ?) LIMIT 1`;\r\n                searchParams = [trimmedPhone, trimmedPhone];\r\n            } else if (trimmedOther) {\r\n                customerSearchQuery += `(contact1 = ? OR contact2 = ?) LIMIT 1`;\r\n                searchParams = [trimmedOther, trimmedOther];\r\n            }\r\n\r\n            if (searchParams.length > 0) {\r\n                const [existingCustomer] = await db.query(customerSearchQuery, searchParams);\r\n                if (existingCustomer.length > 0) {\r\n                    return res.status(400).json({ success: false, message: \"Customer already exists.\" });\r\n                }\r\n            }\r\n\r\n            const sqlInsertCustomer = `\r\n                INSERT INTO Customer (c_ID, title, FtName, SrName, address, contact1, contact2, id, balance, type, category, t_name, occupation, workPlace)\r\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\r\n\r\n            const valuesCustomer = [\r\n                Cust_id, title, FtName, SrName, address,\r\n                trimmedPhone || \"-\", trimmedOther || \"-\", id,\r\n                0, type, category, tType, Occupation, WorkPlace\r\n            ];\r\n\r\n            await db.query(sqlInsertCustomer, valuesCustomer);\r\n        }\r\n\r\n        const advance1 = parseFloat(advance) || 0;\r\n        const balance1 = parseFloat(balance) || 0;\r\n        const newTotalOrder = parseFloat(totalItemPrice) - parseFloat(discountAmount);\r\n        const TotalOrder = parseFloat(totalItemPrice) + parseFloat(deliveryPrice);\r\n        const customerBalance = parseFloat(finalCustomerBalance);\r\n        const billPrice = parseFloat(totalBillPrice) || 0;\r\n        const payAmount = parseFloat(paymentAmount);\r\n        let billBalance = 0;\r\n\r\n        if (billPrice === payAmount || billPrice < payAmount) {\r\n            billBalance = 0;\r\n        } else if (billPrice > payAmount) {\r\n            billBalance = billPrice - payAmount;\r\n        }\r\n\r\n        const orID = `ORD_${Date.now()}`;\r\n\r\n        if (couponCode) {\r\n            const couponQuery = `SELECT stID FROM sales_coupon WHERE cpID = ?`;\r\n            const [couponResult] = await db.query(couponQuery, [couponCode]);\r\n\r\n            if (couponResult.length === 0) {\r\n                return res.status(400).json({ success: false, message: \"Invalid coupon code.\" });\r\n            }\r\n\r\n            stID = couponResult[0].stID;\r\n\r\n            const updateSalesTeamQuery = `UPDATE sales_team SET totalOrder = totalOrder + ? WHERE stID = ?`;\r\n            await db.query(updateSalesTeamQuery, [newTotalOrder, stID]);\r\n        }\r\n\r\n        let orderStatus = null;\r\n\r\n        if (type === 'On site') {\r\n            orderStatus = \"Pending\";\r\n        } else {\r\n            // ✅ Set order status for Walking to 'Delivered' 0r 'Issued'\r\n             orderStatus = dvStatus === \"Delivery\" ?  \"Delivered\" : \"Issued\";\r\n        }\r\n        \r\n        const orderQuery = `\r\n            INSERT INTO Orders (OrID, orDate, c_ID, orStatus, delStatus, delPrice, discount, specialdic, netTotal, total, stID, expectedDate, specialNote, ordertype, advance, balance, payStatus)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'Pending')`;\r\n\r\n        const orderParams = [\r\n            orID, orderDate, Cust_id, orderStatus, dvStatus,\r\n            parseFloat(deliveryPrice) || 0,\r\n            parseFloat(discountAmount) || 0,\r\n            parseFloat(specialdiscountAmount) || 0,\r\n            parseFloat(totalItemPrice) || 0,\r\n            parseFloat(TotalOrder) || 0,\r\n            stID, expectedDate, specialNote, orderType, advance1, billBalance\r\n        ];\r\n\r\n        await db.query(orderQuery, orderParams);\r\n\r\n        if (stID) {\r\n            const currentDate = new Date();\r\n            const currentYear = currentDate.getFullYear();\r\n            const currentMonth = currentDate.toLocaleString(\"default\", { month: \"long\" }); // e.g., \"May\"\r\n\r\n            const netTotal = parseFloat(totalItemPrice) || 0;\r\n\r\n            const checkReviewQuery = `\r\n        SELECT * FROM ST_order_review WHERE stID = ? AND year = ? AND month = ?\r\n    `;\r\n            const [reviewResult] = await db.query(checkReviewQuery, [stID, currentYear, currentMonth]);\r\n\r\n            if (reviewResult.length > 0) {\r\n                // Record exists → update totalOrder\r\n                const updateReviewQuery = `\r\n            UPDATE ST_order_review \r\n            SET totalOrder = totalOrder + ? \r\n            WHERE stID = ? AND year = ? AND month = ?\r\n        `;\r\n                await db.query(updateReviewQuery, [netTotal, stID, currentYear, currentMonth]);\r\n            } else {\r\n                // Record does not exist → insert new row\r\n                const insertReviewQuery = `\r\n            INSERT INTO ST_order_review (stID, year, month, totalOrder, totalIssued)\r\n            VALUES (?, ?, ?, ?, 0)\r\n        `;\r\n                await db.query(insertReviewQuery, [stID, currentYear, currentMonth, netTotal]);\r\n            }\r\n        }\r\n\r\n        if (issuable === 'Now'){\r\n            // Expand each item into multiple rows based on its quantity\r\n            const orderDetailValues = items.flatMap(item =>\r\n                Array.from({ length: item.qty }).map(() => [\r\n                    orID, item.I_Id, 1, parseFloat(item.price)/item.qty, parseFloat(item.discount), item.material\r\n                ])\r\n            );\r\n\r\n            // Insert query\r\n            const orderDetailQuery = `INSERT INTO Order_Detail (orID, I_Id, qty, tprice, discount, material) VALUES ?`;\r\n            await db.query(orderDetailQuery, [orderDetailValues]);\r\n        }\r\n        \r\n        if (dvStatus === \"Delivery\") {\r\n            const dvID = `DLV_${Date.now()}`;\r\n            const deliveryQuery = `\r\n                INSERT INTO delivery (dv_id, orID, address, district, c_ID, status, schedule_Date, type, driverBalance)\r\n                VALUES (?, ?, ?, ?, ?, 'Pending', ?, ?, 0)`;\r\n\r\n            const addressToUse = isAddressChanged ? newAddress : address;\r\n            await db.query(deliveryQuery, [dvID, orID, addressToUse, district, Cust_id, expectedDate, dvtype]);\r\n        }\r\n\r\n        if (couponCode) {\r\n            const ocID = `OCP_${Date.now()}`;\r\n            const couponQuery = `INSERT INTO order_coupon (ocID, orID, cpID) VALUES (?, ?, ?)`;\r\n            await db.query(couponQuery, [ocID, orID, couponCode]);\r\n        }\r\n        const op_ID = await generateNewId(\"order_payment\", \"op_ID\", \"OP\");\r\n        // ✅ Insert cash balance if advance exists\r\n        if (advance1 > 0) {\r\n            const returnBalnce = parseFloat(cashReturn) * (-1);\r\n            // Insert into cash_balance and get insert ID\r\n            const [cashResult] = await db.query(\r\n                `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount) VALUES (?, ?, 'order', NOW(), ?)`,\r\n                ['Order Advance', orID, advance1]\r\n            );\r\n            const cashId = cashResult.insertId;\r\n\r\n            // Handle customer balance decision\r\n            if (customerBalanceDecision === \"pass\") {\r\n                await db.query(\r\n                    `UPDATE Customer SET balance = ? WHERE c_ID = ?`,\r\n                    [customerBalance, Cust_id]\r\n                );\r\n            } else if (customerBalanceDecision === \"handover\") {\r\n                await db.query(\r\n                    `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)\r\n             VALUES (?, ?, ?, NOW(), ?)`,\r\n                    ['Cash Handover', orID, 'order', returnBalnce]\r\n                );\r\n            } else if (customerBalanceDecision === \"ignore\") {\r\n                await db.query(\r\n                    `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)\r\n             VALUES (?, ?, ?, NOW(), ?)`,\r\n                    ['Order Loss', orID, 'order', finalCustomerBalance]\r\n                );\r\n            }\r\n\r\n            // Validate payment fields\r\n            if (!op_ID || !orID || isNaN(advance1) || !stID || !issuable) {\r\n                return res.status(400).json({ message: \"Missing or invalid order payment fields\" });\r\n            }\r\n\r\n            // Insert into order_payment\r\n            await db.query(\r\n                `INSERT INTO order_payment\r\n         (op_ID, orID, amount, dateTime, or_status, netTotal, stID, issuable, c_ID, balance, otherCharges, fullPaidAmount)\r\n         VALUES (?, ?, ?, NOW(), ?, ?, ?, ?, ?, ?, ?, ?)`,\r\n                [op_ID, orID, advance1, orderStatus, billPrice, stID, issuable, Cust_id, billBalance, 0, advance1]\r\n            );\r\n\r\n            // Payment type handler\r\n            const insertPayType = async () => {\r\n                const [result] = await db.query(\r\n                    `INSERT INTO ord_Pay_type (orID, type, subType) VALUES (?, ?, ?)`,\r\n                    [orID, payment, subPayment]\r\n                );\r\n                return result.insertId;\r\n            };\r\n\r\n            const updateOrderPayment = async (charges, fullPaid) => {\r\n                await db.query(\r\n                    `UPDATE order_payment SET otherCharges = ?, fullPaidAmount = ? WHERE op_ID = ?`,\r\n                    [charges, fullPaid, op_ID]\r\n                );\r\n            };\r\n\r\n            // === Payment Types ===\r\n            if (payment === 'Cash') {\r\n                const optId = await insertPayType();\r\n                if (subPayment === 'Transfer' && tranferPayment) {\r\n                    await db.query(\r\n                        `INSERT INTO ord_Transfer_Pay (optId, amount, bank) VALUES (?, ?, ?)`,\r\n                        [optId, advance1, tranferPayment.bank]\r\n                    );\r\n                } else {\r\n                    await db.query(\r\n                        `INSERT INTO ord_Cash_Pay (optId, amount) VALUES (?, ?)`,\r\n                        [optId, advance1]\r\n                    );\r\n                }\r\n                await updateOrderPayment(0, advance1);\r\n            }\r\n\r\n            else if (payment === 'Card' && cardPayment) {\r\n                const optId = await insertPayType();\r\n                await db.query(\r\n                    `INSERT INTO ord_Card_Pay (optId, type, amount, intrestValue)\r\n             VALUES (?, ?, ?, ?)`,\r\n                    [optId, cardPayment.type, advance1, cardPayment.interestValue || 0]\r\n                );\r\n                await updateOrderPayment(cardPayment.interestValue || 0, cardPayment.netAmount);\r\n                await db.query(\r\n                    `UPDATE cash_balance SET amount = ? WHERE Id = ?`,\r\n                    [cardPayment.netAmount, cashId]\r\n                );\r\n            }\r\n\r\n            else if (payment === 'Cheque' && chequePayment) {\r\n                const optId = await insertPayType();\r\n                for (const chq of chequePayment.cheques || []) {\r\n                    await db.query(\r\n                        `INSERT INTO ord_Cheque_Pay (optId, amount, bank, branch, accountNumber, chequeNumber, date,status)\r\n                 VALUES (?, ?, ?, ?, ?, ?, ?)`,\r\n                        [optId, chq.amount || 0, chq.bank || '', chq.branch || '', chq.accountNumber || '', chq.chequeNumber || '', chq.chequeDate || null,'received']\r\n                    );\r\n                }\r\n                await db.query(\r\n                    `UPDATE cash_balance SET amount = ? WHERE Id = ?`,\r\n                    [chequePayment.total || 0, cashId]\r\n                );\r\n                await updateOrderPayment(0, advance1);\r\n            }\r\n\r\n            else if (payment === 'Credit' && creditPayment) {\r\n                const optId = await insertPayType();\r\n                await db.query(\r\n                    `INSERT INTO ord_Credit_Pay (optId, amount, balance, c_ID, expectedDate)\r\n             VALUES (?, ?, ?, ?, ?)`,\r\n                    [optId, creditPayment.amount || 0, creditPayment.balance || 0, Cust_id, creditPayment.expectdate || null]\r\n                );\r\n                await updateOrderPayment(0, advance1);\r\n            }\r\n\r\n            else if (payment === 'Combined') {\r\n                const optId = await insertPayType();\r\n\r\n                if (subPayment === 'Cash & Card' && cashCardPayment) {\r\n                    await db.query(\r\n                        `INSERT INTO ord_Card_Pay (optId, type, amount, intrestValue)\r\n                 VALUES (?, ?, ?, ?)`,\r\n                        [optId, cashCardPayment.type, cashCardPayment.cardBalance, cashCardPayment.interestValue || 0]\r\n                    );\r\n                    await db.query(\r\n                        `UPDATE cash_balance SET amount = ? WHERE Id = ?`,\r\n                        [cashCardPayment.fullpaidAmount, cashId]\r\n                    );\r\n                    await updateOrderPayment(cashCardPayment.interestValue, cashCardPayment.fullpaidAmount);\r\n                }\r\n\r\n                else if (subPayment === 'Cash & Cheque' && combinedChequePayment) {\r\n                    for (const chq of combinedChequePayment.cheques || []) {\r\n                        await db.query(\r\n                            `INSERT INTO ord_Cheque_Pay (optId, amount, bank, branch, accountNumber, chequeNumber, date,status)\r\n                     VALUES (?, ?, ?, ?, ?, ?, ?)`,\r\n                            [optId, chq.amount || 0, chq.bank || '', chq.branch || '', chq.accountNumber || '', chq.chequeNumber || '', chq.chequeDate || null,'received']\r\n                        );\r\n                    }\r\n                    await db.query(\r\n                        `UPDATE cash_balance SET amount = ? WHERE Id = ?`,\r\n                        [combinedChequePayment.total || 0, cashId]\r\n                    );\r\n                    await updateOrderPayment(0, advance1);\r\n                }\r\n\r\n                else if (subPayment === 'Cash & Credit' && combinedCreditPayment) {\r\n                    await db.query(\r\n                        `INSERT INTO ord_Credit_Pay (optId, amount, balance, c_ID, expectedDate)\r\n                 VALUES (?, ?, ?, ?, ?)`,\r\n                        [optId, combinedCreditPayment.creditBalance || 0, combinedCreditPayment.cashBalance || 0, Cust_id, combinedCreditPayment.expectedDate || null]\r\n                    );\r\n                    await updateOrderPayment(0, advance1);\r\n                }\r\n\r\n                else if (subPayment === 'Cash & Transfer' && combinedTransferPayment) {\r\n                    await db.query(\r\n                        `INSERT INTO ord_Transfer_Pay (optId, amount, bank) VALUES (?, ?, ?)`,\r\n                        [optId, combinedTransferPayment.transferAmount, combinedTransferPayment.bank]\r\n                    );\r\n                    await updateOrderPayment(0, advance1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Order placed successfully\",\r\n            data: { orderId: orID,  orderDate, expectedDate }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error inserting order data:\", error);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\nrouter.post(\"/later-order\", async (req, res) => {\r\n    const {\r\n        FtName, SrName, address, c_ID, category, newAddress, isAddressChanged,couponCode, deliveryPrice, discountAmount, district, dvStatus, orderDate,dvtype,totalBillPrice,\r\n        expectedDate, id, isNewCustomer, items, occupation, otherNumber = \"\",phoneNumber = \"\", specialNote, title, totalItemPrice, type, workPlace, t_name, orderType, specialdiscountAmount,\r\n        advance, balance, processedItems = [],payment,subPayment,cardPayment={},chequePayment={},cashCardPayment={},tranferPayment={},creditPayment={},combinedChequePayment={},\r\n        combinedCreditPayment={},combinedTransferPayment={},issuable,customerBalanceDecision,finalCustomerBalance,paymentAmount,cashReturn\r\n    } = req.body;\r\n\r\n    if (!items || !Array.isArray(items) || items.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Invalid or missing items.\" });\r\n    }\r\n\r\n    try {\r\n        let Cust_id = c_ID;\r\n        let Occupation = \"-\", WorkPlace = \"-\", tType = \"-\";\r\n        let stID = null;\r\n\r\n        if (type === 'Walking' || type === 'On site') {\r\n            Occupation = occupation;\r\n            WorkPlace = workPlace;\r\n        } else {\r\n            tType = t_name;\r\n        }\r\n\r\n        const trimmedPhone = phoneNumber.trim();\r\n        const trimmedOther = otherNumber.trim();\r\n\r\n        if (isNewCustomer) {\r\n            Cust_id = await generateNewId(\"Customer\", \"c_ID\", \"Cus\");\r\n\r\n            // Construct dynamic customer search query\r\n            let customerSearchQuery = `SELECT c_ID FROM Customer WHERE `;\r\n            let searchParams = [];\r\n\r\n            if (trimmedPhone && trimmedOther) {\r\n                customerSearchQuery += `(contact1 = ? OR contact2 = ? OR contact1 = ? OR contact2 = ?) LIMIT 1`;\r\n                searchParams = [trimmedPhone, trimmedPhone, trimmedOther, trimmedOther];\r\n            } else if (trimmedPhone) {\r\n                customerSearchQuery += `(contact1 = ? OR contact2 = ?) LIMIT 1`;\r\n                searchParams = [trimmedPhone, trimmedPhone];\r\n            } else if (trimmedOther) {\r\n                customerSearchQuery += `(contact1 = ? OR contact2 = ?) LIMIT 1`;\r\n                searchParams = [trimmedOther, trimmedOther];\r\n            }\r\n\r\n            // Check for existing customer if phone info is present\r\n            if (searchParams.length > 0) {\r\n                const [existingCustomer] = await db.query(customerSearchQuery, searchParams);\r\n                if (existingCustomer.length > 0) {\r\n                    return res.status(400).json({\r\n                        success: false,\r\n                        message: \"Customer already exists with provided contact details.\"\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Insert new customer\r\n            const sqlInsertCustomer = `\r\n        INSERT INTO Customer \r\n            (c_ID, title, FtName, SrName, address, contact1, contact2, id, balance, type, category, t_name, occupation, workPlace)\r\n        VALUES \r\n            (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `;\r\n            const valuesCustomer = [\r\n                Cust_id,title, FtName, SrName,address,trimmedPhone || \"-\",trimmedOther || \"-\", id,0,type,category,tType,Occupation,WorkPlace\r\n            ];\r\n            await db.query(sqlInsertCustomer, valuesCustomer);\r\n        }\r\n\r\n        const advance1 = parseFloat(advance) || 0;\r\n        const balance1 = parseFloat(balance) || 0;\r\n        const newTotalOrder = parseFloat(totalItemPrice) - parseFloat(discountAmount);\r\n        const TotalOrder = parseFloat(totalItemPrice) + parseFloat(deliveryPrice);\r\n        const customerBalance = parseFloat(finalCustomerBalance);\r\n        const billPrice = parseFloat(totalBillPrice) || 0;\r\n        const payAmount = parseFloat(paymentAmount);\r\n        let billBalance = 0;\r\n\r\n        if (billPrice === payAmount || billPrice < payAmount) {\r\n            billBalance = 0;\r\n        } else if (billPrice > payAmount) {\r\n            billBalance = billPrice - payAmount;\r\n        }\r\n\r\n        const orID = `ORD_${Date.now()}`;\r\n\r\n        if (couponCode) {\r\n            const couponQuery = `SELECT stID FROM sales_coupon WHERE cpID = ?`;\r\n            const [couponResult] = await db.query(couponQuery, [couponCode]);\r\n\r\n            if (couponResult.length === 0) {\r\n                return res.status(400).json({ success: false, message: \"Invalid coupon code.\" });\r\n            }\r\n\r\n            stID = couponResult[0].stID;\r\n\r\n            const updateSalesTeamQuery = `UPDATE sales_team SET totalOrder = totalOrder + ? WHERE stID = ?`;\r\n            await db.query(updateSalesTeamQuery, [newTotalOrder, stID]);\r\n        }\r\n        let orderStatus = null;\r\n\r\n        if (type === 'On site') {\r\n            // ✅ Always set On-site orders as Pending\r\n            orderStatus = \"Pending\";\r\n        } else {\r\n            // \uD83D\uDEE0 For other types, determine dynamically\r\n            const hasProduction = processedItems.some(item => item.status === \"Production\");\r\n            orderStatus = hasProduction ? \"Processing\" : \"Accepted\";\r\n        }\r\n\r\n    \r\n        const orderQuery = `INSERT INTO Orders (OrID, orDate, c_ID, orStatus, delStatus, delPrice, discount, specialdic, netTotal, total, stID, expectedDate, specialNote, ordertype, advance, balance, payStatus)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'Pending')`;\r\n\r\n        const orderParams = [\r\n            orID, orderDate, Cust_id, orderStatus, dvStatus,parseFloat(deliveryPrice) || 0,parseFloat(discountAmount) || 0,parseFloat(specialdiscountAmount) || 0,parseFloat(totalItemPrice) || 0,parseFloat(TotalOrder) || 0,\r\n            stID, expectedDate, specialNote, orderType, advance1, billBalance\r\n        ];\r\n\r\n        await db.query(orderQuery, orderParams);\r\n\r\n        // \uD83D\uDD01 Handle Sales Team Order Review\r\n        if (stID) {\r\n            const currentDate = new Date();\r\n            const currentYear = currentDate.getFullYear();\r\n            const currentMonth = currentDate.toLocaleString(\"default\", { month: \"long\" });\r\n\r\n            const netTotal = parseFloat(totalItemPrice) || 0;\r\n            const checkReviewQuery = `SELECT * FROM ST_order_review WHERE stID = ? AND year = ? AND month = ?`;\r\n            const [reviewResult] = await db.query(checkReviewQuery, [stID, currentYear, currentMonth]);\r\n\r\n            if (reviewResult.length > 0) {\r\n                await db.query(` UPDATE ST_order_review   SET totalOrder = totalOrder + ? WHERE stID = ? AND year = ? AND month = ?`,\r\n                    [netTotal, stID, currentYear, currentMonth]);\r\n            } else {\r\n                await db.query(`INSERT INTO ST_order_review (stID, year, month, totalOrder, totalIssued) VALUES (?, ?, ?, ?, 0)`,\r\n                    [stID, currentYear, currentMonth, netTotal]);\r\n            }\r\n        }\r\n        \r\n    // Store UID and new orderDetailId pairs\r\n        const orderDetailMap = []; // Will hold { uid, orderDetailId }\r\n\r\n        for (const item of processedItems) {\r\n            const qty = parseInt(item.qty) || 1;\r\n            const unitPrice = parseFloat(item.unitPrice || 0);\r\n            const discount = parseFloat(item.discount || 0);\r\n            const material = item.material;\r\n            const uid = item.uid;\r\n\r\n            const insertQuery = `INSERT INTO Order_Detail (orID, I_Id, qty, tprice, discount, material) VALUES (?, ?, ?, ?, ?, ?)`;\r\n\r\n            const [result] = await db.query(insertQuery, [\r\n                orID, item.I_Id,qty, unitPrice,discount,material\r\n            ]);\r\n\r\n            // Store UID and the newly created orderDetail ID\r\n            orderDetailMap.push({\r\n                uid,\r\n                orderDetailId: result.insertId // This is the auto-increment ID from Order_Detail\r\n            });\r\n        }\r\n        const bookedItems = [];\r\n        const reservedItems = [];\r\n        const productionItems = [];\r\n\r\n        processedItems.forEach(item => {\r\n            const qty = item.qty || 1;\r\n            const unitPrice = parseFloat(item.unitPrice || 0);\r\n            const discount = parseFloat(item.discount) || 0;\r\n            const material = item.material;\r\n\r\n            const row = [orID, item.I_Id, qty, unitPrice, discount, material];\r\n\r\n            switch (item.status) {\r\n               case 'Booked':\r\n                    bookedItems.push({\r\n                        orID, I_Id: item.I_Id,qty, unitPrice, discount, material\r\n                    });\r\n                    break;\r\n\r\n                case 'Reserved':\r\n                    reservedItems.push({\r\n                        orID, I_Id: item.I_Id,qty,unitPrice,discount,material, pid_Id: item.pid_Id,uid: item.uid\r\n                    });\r\n                    break;\r\n                case 'Production':\r\n                    const pd = item.productionData || {};\r\n                    productionItems.push({\r\n                        orID,I_Id: item.I_Id, qty,unitPrice,discount, material, uid: item.uid || null,\r\n                        expectdate: pd.expectdate || null, itemId: pd.itemId || null,\r\n                        supplierId: pd.supplierId || null, specialnote: pd.specialnote || null\r\n                    });\r\n                    break;\r\n                default:\r\n                    console.warn(`⚠\uFE0F Unknown status '${item.status}' for item:`, item);\r\n                    break;\r\n            }\r\n        });\r\n        if (bookedItems.length > 0) {\r\n            const acceptItemQuery = `INSERT INTO accept_orders (orID, I_Id, itemReceived, status) VALUES ?`;\r\n            const bookedItemQuery = `INSERT INTO booked_item (orID, I_Id, qty) VALUES ?`;\r\n\r\n            const bookedItemValues1 = bookedItems.map(item => [\r\n                item.orID,item.I_Id,'Yes','Complete'\r\n            ]);\r\n\r\n            const bookedItemValues2 = bookedItems.map(item => [\r\n                item.orID,item.I_Id,item.qty || 1\r\n            ]);\r\n\r\n\r\n            // Insert into accept_orders\r\n            await db.query(acceptItemQuery, [bookedItemValues1]);\r\n\r\n            // Insert into booked_item\r\n            await db.query(bookedItemQuery, [bookedItemValues2]);\r\n                for (const item of bookedItems) {\r\n                const qty = item.qty || 1;\r\n                const I_Id = item.I_Id;\r\n\r\n                const updateItemQuery = `UPDATE Item SET bookedQty = bookedQty + ?, availableQty = availableQty - ? WHERE I_Id = ? `;\r\n\r\n                await db.query(updateItemQuery, [qty, qty, I_Id]);\r\n            }\r\n\r\n        }\r\n        if (reservedItems.length > 0) {\r\n            // Prepare values for accept_orders and booked_item\r\n            const acceptItemValues = reservedItems.map(item => [\r\n                item.orID, item.I_Id, 'Yes','Complete'\r\n            ]);\r\n\r\n            const bookedItemValues = reservedItems.map(item => [\r\n                item.orID,item.I_Id,item.qty || 1\r\n            ]);\r\n\r\n            // Insert into accept_orders\r\n            await db.query(`INSERT INTO accept_orders (orID, I_Id, itemReceived, status) VALUES ?`, [acceptItemValues]);\r\n\r\n            // Insert into booked_item\r\n            await db.query(`INSERT INTO booked_item (orID, I_Id, qty) VALUES ?`, [bookedItemValues]);\r\n\r\n            // Handle Special_Reservation, p_i_detail update, and Order_Detail status\r\n            for (const item of reservedItems) {\r\n                const match = orderDetailMap.find(entry => entry.uid === item.uid);\r\n                if (match) {\r\n                    // Insert into Special_Reservation\r\n                    await db.query(`\r\n                        INSERT INTO Special_Reservation (orID, pid_Id, orderDetailId) VALUES (?, ?, ?)`,\r\n                        [item.orID, item.pid_Id, match.orderDetailId]\r\n                    );\r\n\r\n                    // Update p_i_detail\r\n                    await db.query(`\r\n                        UPDATE p_i_detail SET status = 'Reserved', orID = ?, datetime = NOW() WHERE pid_Id = ?`,\r\n                        [item.orID, item.pid_Id]\r\n                    );\r\n\r\n                    // Update Item stock\r\n                    await db.query(` UPDATE Item SET bookedQty = bookedQty - ?, reservedQty = reservedQty + ? WHERE I_Id = ?`,\r\n                        [item.qty, item.qty, item.I_Id]\r\n                    );\r\n\r\n                    // Update Order_Detail status\r\n                    await db.query(` UPDATE Order_Detail  SET status = 'Reserved' WHERE id = ?`,\r\n                        [match.orderDetailId]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        if (productionItems.length > 0) {\r\n            const acceptItemQuery = `INSERT INTO accept_orders (orID, I_Id, itemReceived, status) VALUES ?`;\r\n            const acceptValues = productionItems.map(item => [\r\n                item.orID,item.I_Id, 'No', 'Incomplete'\r\n            ]);\r\n\r\n            // Insert into accept_orders\r\n            await db.query(acceptItemQuery, [acceptValues]);\r\n\r\n            // Insert into production table\r\n            const productionInsertQuery = `INSERT INTO production (p_ID, I_Id, qty, s_ID, expectedDate, specialNote, status) VALUES (?, ?, ?, ?, ?, ?, 'Incomplete')`;\r\n\r\n            for (const item of productionItems) {\r\n                const p_ID = `InP_${Date.now()}`; // Unique p_ID\r\n\r\n                await db.query(productionInsertQuery, [\r\n                    p_ID,item.I_Id,item.qty,item.supplierId,item.expectdate,item.specialnote\r\n                ]);\r\n            }\r\n        }\r\n        if (couponCode) {\r\n            const ocID = `OCP_${Date.now()}`;\r\n            const couponQuery = `INSERT INTO order_coupon (ocID, orID, cpID) VALUES (?, ?, ?)`;\r\n            await db.query(couponQuery, [ocID, orID, couponCode]);\r\n        }\r\n\r\n        if (dvStatus === \"Delivery\") {\r\n            const dvID = `DLV_${Date.now()}`;\r\n            const deliveryQuery = `\r\n                INSERT INTO delivery (dv_id, orID, address, district, c_ID, status, schedule_Date, type, driverBalance)\r\n                VALUES (?, ?, ?, ?, ?, 'Pending', ?, ?, 0)`;\r\n\r\n            const addressToUse = isAddressChanged ? newAddress : address;\r\n            await db.query(deliveryQuery, [dvID, orID, addressToUse, district, Cust_id, expectedDate, dvtype]);\r\n        }\r\n        const op_ID = await generateNewId(\"order_payment\", \"op_ID\", \"OP\");\r\n\r\n        if (advance1 > 0) {\r\n            const returnBalnce = parseFloat(cashReturn) * (-1);\r\n            // Insert into cash_balance for order advance\r\n            const [cashResult] = await db.query(\r\n                `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)\r\n        VALUES (?, ?, 'order', NOW(), ?)`,\r\n                ['Order Advance', orID, advance1]\r\n            );\r\n            const cashId = cashResult.insertId;\r\n\r\n            // Handle customer balance decision\r\n            if (customerBalanceDecision === \"pass\") {\r\n                await db.query(\r\n                    `UPDATE Customer SET balance = ? WHERE c_ID = ?`,\r\n                    [customerBalance, Cust_id]\r\n                );\r\n            } else if (customerBalanceDecision === \"handover\") {\r\n                await db.query(\r\n                    `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)\r\n            VALUES (?, ?, ?, NOW(), ?)`,\r\n                    ['Cash Handover', orID, 'order', returnBalnce]\r\n                );\r\n            } else if (customerBalanceDecision === \"ignore\") {\r\n                await db.query(\r\n                    `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)\r\n            VALUES (?, ?, ?, NOW(), ?)`,\r\n                    ['Order Loss', orID, 'order', finalCustomerBalance]\r\n                );\r\n            }\r\n\r\n            // Ensure all required fields are present\r\n            if (!op_ID || !orID || isNaN(advance1) || !stID || !issuable) {\r\n                return res.status(400).json({ message: \"Missing or invalid order payment fields\" });\r\n            }\r\n\r\n            // Insert into order_payment table\r\n            await db.query(\r\n                `INSERT INTO order_payment \r\n            (op_ID, orID, amount, dateTime, or_status, netTotal, stID, issuable, c_ID, balance, otherCharges, fullPaidAmount) \r\n        VALUES \r\n            (?, ?, ?, NOW(), ?, ?, ?, ?, ?, ?, ?, ?)`,\r\n                [\r\n                    op_ID, orID, advance1, orderStatus, billPrice, stID, issuable, Cust_id, billBalance, 0, advance1\r\n                ]\r\n            );\r\n\r\n            // Handle Payment Types\r\n            const insertPayType = async () => {\r\n                const [result] = await db.query(\r\n                    `INSERT INTO ord_Pay_type (orID, type, subType) VALUES (?, ?, ?)`,\r\n                    [orID, payment, subPayment]\r\n                );\r\n                return result.insertId;\r\n            };\r\n\r\n            const updateOrderPayment = async (amount, otherCharges = 0) => {\r\n                await db.query(\r\n                    `UPDATE order_payment SET otherCharges = ?, fullPaidAmount = ? WHERE op_ID = ?`,\r\n                    [otherCharges, amount, op_ID]\r\n                );\r\n            };\r\n\r\n            if (payment === 'Cash') {\r\n                const optId = await insertPayType();\r\n                await updateOrderPayment(advance1);\r\n                // Insert into ord_Cash_Pay\r\n                await db.query(\r\n                    `INSERT INTO ord_Cash_Pay (optId, amount) VALUES (?, ?)`,\r\n                    [optId, advance1]\r\n                );\r\n            }\r\n\r\n            if (payment === 'Card' && cardPayment) {\r\n                const optId = await insertPayType();\r\n                await db.query(\r\n                    `INSERT INTO ord_Card_Pay (optId, type, amount, intrestValue)\r\n            VALUES (?, ?, ?, ?)`,\r\n                    [optId, cardPayment.type, advance1, cardPayment.interestValue || 0]\r\n                );\r\n                await updateOrderPayment(cardPayment.netAmount, cardPayment.interestValue || 0);\r\n                await db.query(`UPDATE cash_balance SET amount = ? WHERE Id = ?`, [cardPayment.netAmount, cashId]);\r\n            }\r\n\r\n            if (payment === 'Cheque' && chequePayment) {\r\n                const optId = await insertPayType();\r\n\r\n                // Loop through each cheque in the cheque payment array\r\n                let totalChequeAmount = 0;\r\n                for (const chq of chequePayment.cheques || []) {\r\n                    totalChequeAmount += parseFloat(chq.amount || 0); // Calculate the total cheque amount\r\n                    await db.query(\r\n                        `INSERT INTO ord_Cheque_Pay (optId, amount, bank, branch, accountNumber, chequeNumber, date, status)\r\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\r\n                        [\r\n                            optId, chq.amount || 0, chq.bank || '', chq.branch || '', chq.accountNumber || '',\r\n                            chq.chequeNumber || '', chq.chequeDate || null, 'received'\r\n                        ]\r\n                    );\r\n                }\r\n\r\n                // Update the cash_balance with the total cheque amount\r\n                await db.query(`UPDATE cash_balance SET amount = ? WHERE Id = ?`, [totalChequeAmount, cashId]);\r\n\r\n                // Update the order payment with the advance amount\r\n                await updateOrderPayment(advance1);\r\n            }\r\n\r\n            if (payment === 'Credit' && creditPayment) {\r\n                const optId = await insertPayType();\r\n                await db.query(\r\n                    `INSERT INTO ord_Credit_Pay (optId, amount, balance, c_ID, expectedDate)\r\n            VALUES (?, ?, ?, ?, ?)`,\r\n                    [optId, creditPayment.amount || 0, creditPayment.balance || 0, Cust_id, creditPayment.expectdate || null]\r\n                );\r\n                await updateOrderPayment(advance1);\r\n            }\r\n\r\n            if (payment === 'Combined') {\r\n                if (subPayment === 'Cash & Card' && cashCardPayment) {\r\n                    const optId = await insertPayType();\r\n                    await db.query(\r\n                        `INSERT INTO ord_Card_Pay (optId, type, amount, intrestValue)\r\n                VALUES (?, ?, ?, ?)`,\r\n                        [optId, cashCardPayment.type, cashCardPayment.cardBalance, cashCardPayment.interestValue || 0]\r\n                    );\r\n                    await updateOrderPayment(cashCardPayment.fullpaidAmount, cashCardPayment.interestValue || 0);\r\n                    await db.query(`UPDATE cash_balance SET amount = ? WHERE Id = ?`, [cashCardPayment.fullpaidAmount, cashId]);\r\n                }\r\n\r\n                if (subPayment === 'Cash & Cheque' && combinedChequePayment) {\r\n                    const optId = await insertPayType();\r\n                    let totalChequeAmount = 0;\r\n                    for (const chq of combinedChequePayment.cheques || []) {\r\n                        totalChequeAmount += parseFloat(chq.amount || 0); // Calculate total of all cheques\r\n                        await db.query(\r\n                            `INSERT INTO ord_Cheque_Pay (optId, amount, bank, branch, accountNumber, chequeNumber, date, status)\r\n                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\r\n                            [\r\n                                optId, chq.amount || 0, chq.bank || '', chq.branch || '', chq.accountNumber || '',\r\n                                chq.chequeNumber || '', chq.chequeDate || null, 'received'\r\n                            ]\r\n                        );\r\n                    }\r\n                    // Update the cash_balance with the total cheque amount\r\n                    await db.query(`UPDATE cash_balance SET amount = ? WHERE Id = ?`, [totalChequeAmount, cashId]);\r\n\r\n                    await updateOrderPayment(advance1);\r\n                }\r\n\r\n                if (subPayment === 'Cash & Credit' && combinedCreditPayment) {\r\n                    const optId = await insertPayType();\r\n                    await db.query(\r\n                        `INSERT INTO ord_Credit_Pay (optId, amount, balance, c_ID, expectedDate)\r\n                VALUES (?, ?, ?, ?, ?)`,\r\n                        [\r\n                            optId,\r\n                            combinedCreditPayment.creditBalance || 0,\r\n                            combinedCreditPayment.cashBalance || 0,\r\n                            Cust_id,\r\n                            combinedCreditPayment.expectedDate || null\r\n                        ]\r\n                    );\r\n                    await updateOrderPayment(advance1);\r\n                }\r\n\r\n                if (subPayment === 'Cash & Transfer' && combinedTransferPayment) {\r\n                    const optId = await insertPayType();\r\n                    await db.query(\r\n                        `INSERT INTO ord_Transfer_Pay (optId, amount, bank)\r\n                VALUES (?, ?, ?)`,\r\n                        [optId, combinedTransferPayment.transferAmount, combinedTransferPayment.bank]\r\n                    );\r\n                    await updateOrderPayment(advance1);\r\n                }\r\n            }\r\n\r\n            if (payment === 'Cash' && subPayment === 'Transfer' && tranferPayment) {\r\n                const optId = await insertPayType();\r\n                await db.query(\r\n                    `INSERT INTO ord_Transfer_Pay (optId, amount, bank)\r\n            VALUES (?, ?, ?)`,\r\n                    [optId, advance1, tranferPayment.bank]\r\n                );\r\n                await updateOrderPayment(advance1);\r\n            }\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Order placed successfully\",\r\n            data: { orderId: orID, orderDate, expectedDate }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error inserting order data:\", error);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get all orders\r\nrouter.get(\"/orders\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all Orders\r\n        const [orders] = await db.query(\"SELECT * FROM Orders\");\r\n\r\n        // If no promotions found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Orders found\" });\r\n        }\r\n\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID : order.OrID, // Assuming you have an id column\r\n            orDate : order.orDate,\r\n            customer : order.c_ID,\r\n            ordertype : order.ordertype,\r\n            orStatus : order.orStatus,\r\n            delStatus : order.delStatus,\r\n            delPrice : order.delPrice,\r\n            disPrice : order.discount,\r\n            totPrice : order.total,\r\n            advance : order.advance,\r\n            balance : order.balance,\r\n            payStatus : order.payStatus,\r\n            stID:  order.stID,\r\n            expectedDeliveryDate: order.expectedDate\r\n        }));\r\n\r\n        // Send the formatted promotions as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Orders are founded.\",\r\n            data : formattedOrders,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching promotions:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching promotions\" });\r\n    }\r\n});\r\n\r\n// Get all items\r\nrouter.get(\"/allitems\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [items] = await db.query(\"SELECT * FROM Item\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (items.length === 0) {\r\n            return res.status(404).json({ message: \"No items found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedItems = items.map(item => ({\r\n            I_Id: item.I_Id, // Item ID\r\n            I_name: item.I_name, // Item name\r\n            descrip: item.descrip, // Item description\r\n            material:item.material, // Item material\r\n            price: item.price, // Price\r\n            stockQty: item.stockQty, // Quantity\r\n            availableQty : item.availableQty, // available stock\r\n            warrantyPeriod: item.warrantyPeriod,\r\n            img: `data:image/png;base64,${item.img.toString(\"base64\")}`, // Convert LONGBLOB image to Base64\r\n            color: item.color,\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedItems);\r\n    } catch (error) {\r\n        console.error(\"Error fetching items:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching items\" });\r\n    }\r\n});\r\n\r\n// Get all purchase notes\r\nrouter.get(\"/allPurchasenote\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all purchase notes\r\n        const [notes] = await db.query(\"SELECT * FROM purchase\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (notes.length === 0) {\r\n            return res.status(404).json({ message: \"No purchase notes found\" });\r\n        }\r\n\r\n        // Format the purchase notes\r\n        const formattedNotes = notes.map(item => ({\r\n            noteId: item.pc_Id,\r\n            supId: item.s_ID,\r\n            date: item.rDate,\r\n            total: item.total,\r\n            pay: item.pay,\r\n            balance: item.balance,\r\n            deliveryCharge: item.deliveryCharge,\r\n            invoiceId: item.invoiceId,\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedNotes);\r\n    } catch (error) {\r\n        console.error(\"Error fetching purchase notes:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching purchase notes\" });\r\n    }\r\n});\r\n\r\n// Get all customers with filters for balance conditions\r\nrouter.get(\"/allcustomers\", async (req, res) => {\r\n    try {\r\n        const { filter } = req.query; // Get filter type from query params\r\n        let query = \"SELECT * FROM Customer\";\r\n\r\n        // Apply filters based on balance conditions\r\n        if (filter === \"Cash\") {\r\n            query += \" WHERE category = 'Cash'\";\r\n        } else if (filter === \"Credit\") {\r\n            query += \" WHERE category = 'Credit'\";\r\n        } else if (filter === \"Loyal\") {\r\n            query += \" WHERE category = 'Loyal'\";\r\n        }\r\n\r\n        const [customers] = await db.query(query);\r\n\r\n        // If no customers found, return a 404 status\r\n        if (customers.length === 0) {\r\n            return res.status(200).json({ message: \"No customers found\",data:[] });\r\n        }\r\n\r\n        // Format the customer data\r\n        const formattedCustomers = customers.map(customer => ({\r\n            c_ID: customer.c_ID, // Customer ID\r\n            title: customer.title,\r\n            FtName: customer.FtName,\r\n            SrName: customer.SrName,\r\n            id: customer.id, // NIC or identifier\r\n            email: customer.email || \"\", // Email (nullable)\r\n            address: customer.address, // Address\r\n            contact1: customer.contact1, // Primary contact\r\n            contact2: customer.contact2 || \"\", // Secondary contact (nullable)\r\n            balance: customer.balance, // Account balance\r\n            category: customer.category,\r\n            type: customer.type,\r\n            t_name: customer.t_name,\r\n            occupation: customer.occupation,\r\n            workPlace: customer.workPlace,\r\n        }));\r\n        // Send the formatted customers as a JSON response\r\n        return res.status(200).json(formattedCustomers);\r\n    } catch (error) {\r\n        console.error(\"Error fetching customers:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching customers\" });\r\n    }\r\n});\r\n\r\n// Get all delivery notes\r\nrouter.get(\"/alldeliverynotes\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [deliveryNotes] = await db.query(\"SELECT * FROM delivery_note\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (deliveryNotes.length === 0) {\r\n            return res.status(404).json({ message: \"No deliveries found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedDeliveryNotes = deliveryNotes.map(deliverynote => ({\r\n            delNoID: deliverynote.delNoID,\r\n            driverName: deliverynote.driverName,\r\n            date: deliverynote.date,\r\n            status: deliverynote.status,\r\n            district: deliverynote.district\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedDeliveryNotes);\r\n    } catch (error) {\r\n        console.error(\"Error fetching deliveries:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching deliveries\" });\r\n    }\r\n});\r\n\r\n// Get all delivery notes for spefic driver\r\nrouter.get(\"/alldeliverynotes-stid\", async (req, res) => {\r\n    try {\r\n        const { eid } = req.query;\r\n        let query = `\r\n            SELECT dn.delNoID, dn.driverName, dn.date, dn.status, dn.district\r\n            FROM delivery_note dn\r\n            JOIN driver d ON dn.devID = d.devID\r\n        `;\r\n\r\n        const params = [];\r\n\r\n        if (eid) {\r\n            query += ` WHERE d.E_ID = ?`;\r\n            params.push(eid);\r\n        }\r\n\r\n        const [deliveryNotes] = await db.query(query, params);\r\n\r\n        if (deliveryNotes.length === 0) {\r\n            return res.status(404).json({ message: \"No deliveries found\" });\r\n        }\r\n\r\n        const formattedDeliveryNotes = deliveryNotes.map(deliverynote => ({\r\n            delNoID: deliverynote.delNoID,\r\n            driverName: deliverynote.driverName,\r\n            date: deliverynote.date,\r\n            status: deliverynote.status,\r\n            district: deliverynote.district\r\n        }));\r\n\r\n        return res.status(200).json(formattedDeliveryNotes);\r\n    } catch (error) {\r\n        console.error(\"Error fetching deliveries:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching deliveries\" });\r\n    }\r\n});\r\n\r\n// Get all deliveries\r\nrouter.get(\"/alldeliveries\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [deliveries] = await db.query(\"SELECT * FROM delivery\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (deliveries.length === 0) {\r\n            return res.status(404).json({ message: \"No deliveries found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedDeliveries = deliveries.map(delivery => ({\r\n            dv_id: delivery.dv_id,\r\n            orID: delivery.orID,\r\n            district: delivery.district,\r\n            status: delivery.status,\r\n            schedule_Date: formatDate(delivery.schedule_Date),\r\n            delivery_Date: formatDate(delivery.delivery_Date),\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedDeliveries);\r\n    } catch (error) {\r\n        console.error(\"Error fetching deliveries:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching deliveries\" });\r\n    }\r\n});\r\n\r\n//add a new supplier\r\nrouter.post(\"/supplier\", async (req, res) => {\r\n    const { name, contact, contact2, address} = req.body;\r\n\r\n    // Generate new supplier ID\r\n    const s_ID = await generateNewId(\"supplier\", \"s_ID\", \"S\");\r\n    const sqlInsertSupplier = `\r\n        INSERT INTO Supplier (s_ID, name, address, contact, contact2)\r\n        VALUES (?, ?, ?, ?, ?)`;\r\n    const valuesSupplier = [\r\n        s_ID,\r\n        name,\r\n        address,\r\n        contact,\r\n        contact2 || \"\", // If contact2 is empty, set it as an empty string\r\n    ];\r\n\r\n    try {\r\n        // Insert the supplier into the Supplier table\r\n        await db.query(sqlInsertSupplier, valuesSupplier);\r\n\r\n        // Respond with success message and new supplier details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Supplier  added successfully\",\r\n            data: {\r\n                s_ID,\r\n                name,\r\n                contact,\r\n                contact2,\r\n                address,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting supplier  data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//add a new customer\r\nrouter.post(\"/customer\", async (req, res) => {\r\n    const {title,FtName,SrName,id,email,contact,contact2, address, type, category, t_name,occupation, workPlace } = req.body;\r\n\r\n    try {\r\n        const c_ID = await generateNewId(\"Customer\", \"c_ID\", \"Cus\");\r\n\r\n        const sqlInsertCustomer = `\r\n            INSERT INTO Customer (\r\n                c_ID, title, FtName, SrName, address, contact1, contact2, email, id, balance, type, category, t_name, occupation, workPlace\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n        `;\r\n\r\n        const valuesCustomer = [\r\n            c_ID, title, FtName, SrName, address, contact, contact2 || \"\",\r\n            email, id, 0, type, category, t_name, occupation, workPlace\r\n        ];\r\n\r\n        await db.query(sqlInsertCustomer, valuesCustomer);\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Customer added successfully\",\r\n            data: {\r\n                c_ID, FtName,contact,contact2,id\r\n            }\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error inserting customer data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get Customer Details \r\nrouter.get(\"/customer-details&orders\", async (req, res) => {\r\n    const { c_ID } = req.query;\r\n    if (!c_ID) {\r\n        return res.status(400).json({ message: \"Missing customer ID (c_ID)\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch customer details\r\n        const [customerRows] = await db.query(\"SELECT * FROM Customer WHERE c_ID = ?\", [c_ID]);\r\n\r\n        if (customerRows.length === 0) {\r\n            return res.status(404).json({ message: \"Customer not found\" });\r\n        }\r\n\r\n        const customer = customerRows[0];\r\n\r\n        // Fetch order counts grouped by status\r\n        const [orderCounts] = await db.query(`\r\n            SELECT orStatus, COUNT(*) AS count\r\n            FROM Orders\r\n            WHERE c_ID = ?\r\n            GROUP BY orStatus\r\n        `, [c_ID]);\r\n\r\n        // Initialize order status counts\r\n        const statusCounts = {\r\n            Accepted: 0,\r\n            Pending: 0,\r\n            Delivered: 0,\r\n            Issued: 0,\r\n            Production: 0\r\n        };\r\n\r\n        // Populate status counts with actual data\r\n        orderCounts.forEach(row => {\r\n            const status = row.orStatus;\r\n            if (statusCounts.hasOwnProperty(status)) {\r\n                statusCounts[status] = row.count;\r\n            }\r\n        });\r\n\r\n        // Construct the response object\r\n        const response = {\r\n            c_ID: customer.c_ID,\r\n            title: customer.title,\r\n            FtName: customer.FtName,\r\n            SrName: customer.SrName,\r\n            id: customer.id,\r\n            address: customer.address,\r\n            contact1: customer.contact1,\r\n            contact2: customer.contact2,\r\n            balance: customer.balance,\r\n            category: customer.category,\r\n            type: customer.type,\r\n            t_name: customer.t_name,\r\n            occupation: customer.occupation,\r\n            workPlace: customer.workPlace,\r\n            orders: [statusCounts]\r\n        };\r\n\r\n        return res.status(200).json(response);\r\n    } catch (error) {\r\n        console.error(\"Error fetching customer details:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching customer details\" });\r\n    }\r\n});\r\n\r\n// Get customer payments and balance summary\r\nconst groupByDate = (records, dateField) => {\r\n    const map = {};\r\n    for (const record of records) {\r\n        const date = new Date(record[dateField]).toISOString().split(\"T\")[0];\r\n        if (!map[date]) map[date] = [];\r\n        map[date].push(record);\r\n    }\r\n    return map;\r\n};\r\n\r\nrouter.get(\"/customer-ledger\", async (req, res) => {\r\n    try {\r\n        const { c_ID, startDate, endDate } = req.query;\r\n        if (!c_ID || !startDate || !endDate) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"Customer ID (c_ID), startDate, and endDate are required\",\r\n            });\r\n        }\r\n\r\n        const formattedStartDate = parseDate1(startDate);\r\n        const formattedEndDate = parseDate1(endDate);\r\n\r\n        // Fetch payments\r\n        const [paymentRecords] = await db.query(\r\n            `SELECT \r\n                op.op_ID, op.orID, op.dateTime AS paymentDate,\r\n                op.amount AS paidAmount, op.balance,\r\n                op.netTotal\r\n            FROM order_payment op\r\n            WHERE op.c_ID = ? AND op.dateTime BETWEEN ? AND ?\r\n            ORDER BY op.dateTime ASC`,\r\n            [c_ID, formattedStartDate, formattedEndDate]\r\n        );\r\n\r\n        // Attach payment type info\r\n        for (const record of paymentRecords) {\r\n            const [types] = await db.query(`\r\n                SELECT \r\n                    opt.type,\r\n                    opt.subType,\r\n                    COALESCE(oc.amount, occ.amount, ocr.amount, ot.amount, 0) AS amount,\r\n                    occ.bank AS chequeBank,\r\n                    occ.chequeNumber,\r\n                    occ.status AS chequeStatus,\r\n                    ocr.expectedDate AS creditExpectedDate,\r\n                    ot.bank AS transferBank\r\n                FROM ord_Pay_type opt\r\n                LEFT JOIN ord_Card_Pay oc ON opt.optId = oc.optId\r\n                LEFT JOIN ord_Cheque_Pay occ ON opt.optId = occ.optId\r\n                LEFT JOIN ord_Credit_Pay ocr ON opt.optId = ocr.optId\r\n                LEFT JOIN ord_Transfer_Pay ot ON opt.optId = ot.optId\r\n                WHERE opt.orID = ?\r\n            `, [record.orID]);\r\n\r\n            record.paymentTypes = types;\r\n        }\r\n\r\n        // Fetch bills\r\n        const [billRecords] = await db.query(\r\n            `SELECT \r\n                orID, orDate AS billDate, netTotal, balance\r\n            FROM Orders\r\n            WHERE c_ID = ? AND orDate BETWEEN ? AND ?\r\n            ORDER BY orDate ASC`,\r\n            [c_ID, formattedStartDate, formattedEndDate]\r\n        );\r\n\r\n        // Grouping\r\n        const groupedPayments = groupByDate(paymentRecords, \"paymentDate\");\r\n        const groupedBills = groupByDate(billRecords, \"billDate\");\r\n\r\n        const allDates = Array.from(new Set([\r\n            ...Object.keys(groupedBills),\r\n            ...Object.keys(groupedPayments)\r\n        ])).sort();\r\n\r\n        const datewiseLedger = allDates.map(date => ({\r\n            date,\r\n            bills: groupedBills[date] || [],\r\n            payments: groupedPayments[date] || []\r\n        }));\r\n\r\n        res.status(200).json({\r\n            success: true,\r\n            message: \"Grouped ledger retrieved successfully\",\r\n            data: datewiseLedger\r\n        });\r\n    } catch (err) {\r\n        console.error(\"❌ Ledger Error:\", err);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            details: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Check if customer exists by phone number\r\nrouter.get(\"/customer/check-customer\", async (req, res) => {\r\n    const { phone } = req.query;\r\n\r\n    if (!phone) {\r\n        return res.status(400).json({\r\n            exists: false,\r\n            message: \"Phone number is required.\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        const likePhone = `%${phone}%`; // Add wildcard for partial matching\r\n\r\n        const [customer] = await db.query(\r\n            `SELECT * FROM Customer WHERE contact1 LIKE ? OR contact2 LIKE ?`,\r\n            [likePhone, likePhone]\r\n        );\r\n\r\n        if (customer.length > 0) {\r\n            return res.status(200).json({\r\n                exists: true,\r\n                customerName: `${customer[0].FtName} ${customer[0].SrName}`,\r\n                data: customer[0]\r\n            });\r\n        } else {\r\n            return res.status(200).json({\r\n                exists: false,\r\n                message: \"Customer not found.\",\r\n            });\r\n        }\r\n    } catch (err) {\r\n        console.error(\"Error checking customer:\", err.message);\r\n        return res.status(500).json({\r\n            exists: false,\r\n            message: \"Database error.\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get one accept order in-detail\r\nrouter.get(\"/accept-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, c.title, c.FtName, c.SrName, c.address, c.contact1, c.contact2,o.netTotal,\r\n                o.advance, o.balance, o.payStatus, o.orStatus, o.delStatus, o.delPrice, o.discount, o.total,o.specialdic,\r\n                o.ordertype, o.expectedDate, o.specialNote, s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n            LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            LEFT JOIN sales_team s ON o.stID = s.stID\r\n            LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.id, od.I_Id, i.I_name, i.color, od.qty, od.tprice,\r\n                od.discount AS unitDiscount,\r\n                i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty, i.stockQty\r\n            FROM Order_Detail od\r\n            JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Booked Items\r\n        const bookedItemsQuery = `\r\n            SELECT bi.I_Id, i.I_name, bi.qty\r\n            FROM booked_item bi\r\n            JOIN Item i ON bi.I_Id = i.I_Id\r\n            WHERE bi.orID = ?`;\r\n        const [bookedItemsResult] = await db.query(bookedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Fetch Accepted Orders\r\n        const acceptedOrdersQuery = `\r\n            SELECT ao.I_Id, i.I_name, ao.itemReceived, ao.status\r\n            FROM accept_orders ao\r\n            JOIN Item i ON ao.I_Id = i.I_Id\r\n            WHERE ao.orID = ?`;\r\n        const [acceptedOrdersResult] = await db.query(acceptedOrdersQuery, [orID]);\r\n\r\n        // 5\uFE0F⃣ Format Customer Name\r\n        const customerName = [orderData.title, orderData.FtName, orderData.SrName].filter(Boolean).join(\" \");\r\n\r\n        // 6\uFE0F⃣ Base Order Object\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate: formatDate(orderData.orDate),\r\n            customerId: orderData.c_ID,\r\n            customerName: customerName,\r\n            address: orderData.address,\r\n            ordertype: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            specialdiscount: orderData.specialdic,\r\n            totalPrice: orderData.total,\r\n            netTotal: orderData.netTotal,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            expectedDeliveryDate: formatDate(orderData.expectedDate),\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: itemsResult.map(item => ({\r\n                id: item.id,\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                color: item.color,\r\n                quantity: item.qty,\r\n                unitPrice: item.unitPrice,\r\n                discount: item.unitDiscount,\r\n                amountBeforeDiscount: item.unitPrice * item.qty,\r\n                totalDiscountAmount: item.unitDiscount * item.qty,\r\n                amount: item.tprice,\r\n                booked: item.bookedQty > 0,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty,\r\n                stockQuantity: item.stockQty\r\n            })),\r\n            bookedItems: bookedItemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty\r\n            })),\r\n            acceptedOrders: acceptedOrdersResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                itemReceived: item.itemReceived,\r\n                status: item.status\r\n            }))\r\n        };\r\n\r\n        // 7\uFE0F⃣ If Delivery, Fetch Delivery Info\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, status, schedule_Date, delivery_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: formatDate(deliveryData.schedule_Date),\r\n                    deliveryDate: deliveryData.delivery_Date ? formatDate(deliveryData.delivery_Date) : null\r\n                };\r\n            }\r\n        }\r\n\r\n        // 8\uFE0F⃣ Fetch Payment History\r\n        const paymentQuery = `\r\n            SELECT op_ID, amount, netTotal, or_status, stID, dateTime, otherCharges,\r\n                   fullPaidAmount, issuable, c_ID, balance\r\n            FROM order_payment\r\n            WHERE orID = ?\r\n            ORDER BY dateTime ASC`;\r\n        const [paymentResult] = await db.query(paymentQuery, [orID]);\r\n\r\n        orderResponse.paymentHistory = paymentResult.map(p => ({\r\n            paymentId: p.op_ID,\r\n            amount: p.amount,\r\n            netTotal: p.netTotal,\r\n            orderStatus: p.or_status,\r\n            salesTeamId: p.stID,\r\n            dateTime: formatDateTime(p.dateTime),\r\n            otherCharges: p.otherCharges,\r\n            fullPaidAmount: p.fullPaidAmount,\r\n            issuable: p.issuable,\r\n            customerId: p.c_ID,\r\n            balance: p.balance\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get Details of isssued order\r\nrouter.get(\"/issued-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info with Customer Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.orStatus, o.delStatus, o.delPrice, o.discount, o.netTotal, o.total,\r\n                o.advance, o.balance, o.payStatus, o.stID, o.expectedDate, o.specialNote, o.ordertype,o.specialdic,\r\n                c.title, c.FtName, c.SrName, c.contact1, c.contact2, c.balance AS customerBalance,\r\n                c.category, c.type, c.t_name, c.occupation, c.workPlace\r\n            FROM Orders o\r\n                     LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, i.color, od.qty, od.tprice,\r\n                od.discount AS unitDiscount,\r\n                i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty, i.stockQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Issued Items with barcode and issue date\r\n        const issuedItemsQuery = `\r\n            SELECT\r\n                ii.delNoID, ii.orID, ii.pid_Id, ii.status, ii.date AS issuedDate, \r\n                p.barcode_img, p.stock_Id, p.pc_Id\r\n            FROM issued_items ii\r\n                     JOIN p_i_detail p ON ii.pid_Id = p.pid_Id\r\n            WHERE ii.orID = ?`;\r\n\r\n        const [issuedItemsResult] = await db.query(issuedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Fetch Order Payment History\r\n        const paymentHistoryQuery = `\r\n            SELECT op.op_ID, op.orID, op.amount, op.dateTime\r\n            FROM order_payment op\r\n            WHERE op.orID = ?`;\r\n\r\n        const [paymentHistoryResult] = await db.query(paymentHistoryQuery, [orID]);\r\n\r\n        // 5\uFE0F⃣ Format Customer Name\r\n        const customerName = [orderData.title, orderData.FtName, orderData.SrName].filter(Boolean).join(\" \");\r\n\r\n        // 6\uFE0F⃣ Prepare Response Data\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,orderDate: formatDate(orderData.orDate),\r\n            customerId: orderData.c_ID, customerName: customerName,\r\n            customerPhone: orderData.contact1,customerOptionalPhone: orderData.contact2,\r\n            customerBalance: orderData.customerBalance,\r\n            customerCategory: orderData.category,customerType: orderData.type,\r\n            customerOccupation: orderData.occupation,customerWorkplace: orderData.workPlace,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,specialdiscount: orderData.specialdic,\r\n            totalPrice: orderData.total,netTotal: orderData.netTotal,\r\n            advance: orderData.advance,balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            expectedDeliveryDate: formatDate(orderData.expectedDate),\r\n            specialNote: orderData.specialNote,\r\n            items: itemsResult.map(item => {\r\n                const { qty, unitPrice, unitDiscount } = item;\r\n                const amountBeforeDiscount = unitPrice * qty;\r\n                const totalDiscountAmount = unitDiscount * qty;\r\n                const finalAmount = item.tprice;\r\n\r\n                return {\r\n                    itemId: item.I_Id,itemName: item.I_name,color: item.color,\r\n                    quantity: qty,unitPrice: unitPrice,\r\n                    discount: unitDiscount,amountBeforeDiscount: amountBeforeDiscount,\r\n                    totalDiscountAmount: totalDiscountAmount,amount: finalAmount,\r\n                    booked: item.bookedQty > 0,bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty, stockQuantity: item.stockQty\r\n                };\r\n            }),\r\n            issuedItems: issuedItemsResult.map(item => ({\r\n                pid_Id: item.pid_Id, stockId: item.stock_Id,\r\n                BatchId: item.pc_Id,status: item.status,issuedDate: formatDate(item.issuedDate),\r\n            })),\r\n            paymentHistory: paymentHistoryResult.map(payment => ({\r\n                paymentId: payment.op_ID,amount: payment.amount,paymentDate: formatDate(payment.dateTime)\r\n            }))\r\n        };\r\n\r\n        // 7\uFE0F⃣ Fetch Delivery Info If Applicable\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT \r\n                    dv.dv_id, dv.address, dv.district, dv.status, dv.schedule_Date, dv.delivery_Date, \r\n                    dv.type, dv.devID, dv.driverBalance, c.contact1 AS customerContact\r\n                FROM delivery dv\r\n                LEFT JOIN Customer c ON dv.c_ID = c.c_ID\r\n                WHERE dv.orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: new Date(deliveryData.schedule_Date).toISOString().split(\"T\")[0],\r\n                    deliveryDate: deliveryData.delivery_Date ? formatDate(deliveryData.delivery_Date) : null,\r\n                    type: deliveryData.type,\r\n                    driverId: deliveryData.devID,\r\n                    driverBalance: deliveryData.driverBalance,\r\n                    customerContact: deliveryData.customerContact\r\n                };\r\n            }\r\n        }\r\n\r\n        // 8\uFE0F⃣ Fetch Payment Type and Sub Payment Details\r\n        const payTypeQuery = `SELECT * FROM ord_Pay_type WHERE orID = ?`;\r\n        const [payTypeResult] = await db.query(payTypeQuery, [orID]);\r\n\r\n        const paymentDetails = [];\r\n\r\n        for (const payType of payTypeResult) {\r\n            const { optId, type, subType } = payType;\r\n            const paymentInfo = { optId, type, subType };\r\n\r\n            if (type === \"Card\") {\r\n                const [cardRows] = await db.query(`SELECT * FROM ord_Card_Pay WHERE optId = ?`, [optId]);\r\n                paymentInfo.card = cardRows;\r\n            } else if (type === \"Cheque\") {\r\n                const [chequeRows] = await db.query(`SELECT * FROM ord_Cheque_Pay WHERE optId = ?`, [optId]);\r\n                paymentInfo.cheque = chequeRows;\r\n            } else if (type === \"Credit\") {\r\n                const [creditRows] = await db.query(`SELECT * FROM ord_Credit_Pay WHERE optId = ?`, [optId]);\r\n                paymentInfo.credit = creditRows;\r\n            } else if (type === \"Transfer\") {\r\n                const [transferRows] = await db.query(`SELECT * FROM ord_Transfer_Pay WHERE optId = ?`, [optId]);\r\n                paymentInfo.transfer = transferRows;\r\n            } else if (type === \"Combined\") {\r\n                // Depending on subType like \"Cash & Card\", fetch multiple sets\r\n                if (subType.includes(\"Card\")) {\r\n                    const [cardRows] = await db.query(`SELECT * FROM ord_Card_Pay WHERE optId = ?`, [optId]);\r\n                    paymentInfo.card = cardRows;\r\n                }\r\n                if (subType.includes(\"Cheque\")) {\r\n                    const [chequeRows] = await db.query(`SELECT * FROM ord_Cheque_Pay WHERE optId = ?`, [optId]);\r\n                    paymentInfo.cheque = chequeRows;\r\n                }\r\n                if (subType.includes(\"Credit\")) {\r\n                    const [creditRows] = await db.query(`SELECT * FROM ord_Credit_Pay WHERE optId = ?`, [optId]);\r\n                    paymentInfo.credit = creditRows;\r\n                }\r\n                if (subType.includes(\"Transfer\")) {\r\n                    const [transferRows] = await db.query(`SELECT * FROM ord_Transfer_Pay WHERE optId = ?`, [optId]);\r\n                    paymentInfo.transfer = transferRows;\r\n                }\r\n            }\r\n\r\n            paymentDetails.push(paymentInfo);\r\n        }\r\n\r\n        orderResponse.paymentDetails = paymentDetails;\r\n\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Get Details of returned orders\r\nrouter.get(\"/returned-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info with Customer, Sales Team, and Return Reason\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.orStatus, o.delStatus, o.delPrice, o.discount, o.total, \r\n                o.netTotal, o.advance, o.balance, o.payStatus, o.expectedDate, o.specialNote, o.ordertype,o.specialdic,\r\n                c.title, c.FtName, c.SrName, c.email, c.contact1, c.contact2, c.address,\r\n                s.stID, e.name AS salesEmployeeName, ro.detail AS returnReason\r\n            FROM Orders o\r\n            LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            LEFT JOIN sales_team s ON o.stID = s.stID\r\n            LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            LEFT JOIN return_orders ro ON o.OrID = ro.OrID\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, i.color, od.qty, od.tprice,\r\n                od.discount AS unitDiscount,\r\n                i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty, i.stockQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Issued Items from `p_i_detail` and `issued_items`\r\n        const issuedItemsQuery = `\r\n            SELECT\r\n                ii.delNoID, ii.orID, ii.pid_Id, ii.status, ii.date AS issuedDate, \r\n                p.I_Id, i.I_name, p.stock_Id, p.pc_Id, p.barcode_img\r\n            FROM issued_items ii\r\n            JOIN p_i_detail p ON ii.pid_Id = p.pid_Id\r\n            JOIN Item i ON p.I_Id = i.I_Id\r\n            WHERE ii.orID = ?`;\r\n\r\n        const [issuedItemsResult] = await db.query(issuedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Format Customer Name with Title\r\n        const customerName = [orderData.title, orderData.FtName, orderData.SrName].filter(Boolean).join(\" \");\r\n\r\n        // 5\uFE0F⃣ Prepare Response Data\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate: formatDate(orderData.orDate),\r\n            customerId: orderData.c_ID,\r\n            customerName: customerName,\r\n            customerEmail: orderData.email,\r\n            address: orderData.address,\r\n            orderType: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            specialdiscount: orderData.specialdic,\r\n            totalPrice: orderData.total,\r\n            netTotal: orderData.netTotal,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            expectedDeliveryDate: formatDate(orderData.expectedDate),\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            returnReason: orderData.returnReason || null,\r\n            items: itemsResult.map(item => {\r\n                const { qty, unitPrice, unitDiscount } = item;\r\n                const amountBeforeDiscount = unitPrice * qty;\r\n                const totalDiscountAmount = unitDiscount * qty;\r\n                const finalAmount = item.tprice;\r\n\r\n                return {\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    color: item.color,\r\n                    quantity: qty,\r\n                    unitPrice: unitPrice,\r\n                    discount: unitDiscount,\r\n                    amountBeforeDiscount: amountBeforeDiscount,\r\n                    totalDiscountAmount: totalDiscountAmount,\r\n                    amount: finalAmount,\r\n                    booked: item.bookedQty > 0,\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty,\r\n                    stockQuantity: item.stockQty\r\n                };\r\n            }),\r\n            issuedItems: issuedItemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                stockId: item.stock_Id,\r\n                BatchId: item.pc_Id,\r\n                barcodeImage: item.barcode_img.toString(\"base64\"), // Convert LONGBLOB to base64\r\n                status: item.status,\r\n                issuedDate: formatDate(item.issuedDate),\r\n            }))\r\n        };\r\n\r\n        // 6\uFE0F⃣ Fetch Delivery Info If Applicable\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT \r\n                    dv.dv_id, dv.address, dv.district, dv.status, dv.schedule_Date, dv.delivery_Date, \r\n                    dv.type, dv.devID, dv.driverBalance, c.contact1 AS customerContact\r\n                FROM delivery dv\r\n                LEFT JOIN Customer c ON dv.c_ID = c.c_ID\r\n                WHERE dv.orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: formatDate(deliveryData.schedule_Date),\r\n                    deliveryDate: deliveryData.delivery_Date ? formatDate(deliveryData.delivery_Date) : null,\r\n                    type: deliveryData.type,\r\n                    driverId: deliveryData.devID,\r\n                    driverBalance: deliveryData.driverBalance,\r\n                    customerContact: deliveryData.customerContact\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Returned order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching returned order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching returned order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get one order in-detail\r\nrouter.get(\"/order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // Fetch Order Info along with Customer and Sales Team details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, c.title, c.FtName, c.SrName, c.address, c.contact1, c.contact2,\r\n                o.orStatus, o.delStatus, o.delPrice, o.discount, o.netTotal, o.total,o.specialdic,\r\n                o.advance, o.balance, o.payStatus, o.expectedDate, o.specialNote, o.ordertype,\r\n                s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        const orderData = orderResult[0];\r\n\r\n        // Fetch Ordered Items\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.id, od.I_Id, i.I_name, i.color, od.qty, od.tprice,\r\n                od.discount AS unitDiscount,\r\n                i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty, i.stockQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // Format customer name with title\r\n        const customerName = [orderData.title, orderData.FtName, orderData.SrName].filter(Boolean).join(\" \");\r\n\r\n        // Prepare Order Response\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate:  formatDate(orderData.orDate),\r\n            ordertype: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            specialdiscount: orderData.specialdic,\r\n            netTotal: orderData.netTotal,\r\n            totalPrice: orderData.total,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            customerId: orderData.c_ID,\r\n            name: customerName, // Title added to the name\r\n            address: orderData.address,\r\n            expectedDeliveryDate: formatDate(orderData.expectedDate),\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: itemsResult.map(item => {\r\n                const { qty, unitPrice, unitDiscount } = item;\r\n                const amountBeforeDiscount = unitPrice * qty;\r\n                const totalDiscountAmount = unitDiscount * qty;\r\n                const finalAmount = item.tprice;\r\n\r\n                return {\r\n                    id: item.id,\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    color: item.color,\r\n                    quantity: qty,\r\n                    unitPrice: unitPrice,\r\n                    discount: unitDiscount,\r\n                    amountBeforeDiscount: amountBeforeDiscount,\r\n                    totalDiscountAmount: totalDiscountAmount,\r\n                    amount: finalAmount,\r\n                    booked: item.bookedQty > 0,\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty,\r\n                    stockQuantity: item.stockQty\r\n                };\r\n            }),\r\n        };\r\n\r\n        // Fetch Delivery Info if it's a delivery order\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, status, schedule_Date, delivery_Date, c_ID\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: formatDate(deliveryData.schedule_Date),\r\n                    deliveryDate: deliveryData.delivery_Date ? formatDate(deliveryData.delivery_Date) : null\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// GET Item Details by Item ID\r\nrouter.get(\"/item-details\", async (req, res) => {\r\n    try {\r\n        const { I_Id } = req.query;\r\n\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // ✅ Fetch item details from Item table\r\n        const itemQuery = `\r\n            SELECT\r\n                I.I_Id, I.I_name, I.descrip, I.price, I.stockQty, I.bookedQty, I.availableQty, I.minQTY,\r\n                I.warrantyPeriod, I.img, I.img1, I.img2, I.img3, I.color, I.material, I.mn_Cat, I.sb_catOne, I.sb_catTwo\r\n            FROM Item I\r\n            WHERE I.I_Id = ?`;\r\n\r\n        const [itemResult] = await db.query(itemQuery, [I_Id]);\r\n\r\n        if (itemResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found\" });\r\n        }\r\n\r\n        const itemData = itemResult[0];\r\n\r\n        // ✅ Convert images to Base64\r\n        const mainImgBase64 = itemData.img ? Buffer.from(itemData.img).toString(\"base64\") : null;\r\n        const img1Base64 = itemData.img1 ? Buffer.from(itemData.img1).toString(\"base64\") : null;\r\n        const img2Base64 = itemData.img2 ? Buffer.from(itemData.img2).toString(\"base64\") : null;\r\n        const img3Base64 = itemData.img3 ? Buffer.from(itemData.img3).toString(\"base64\") : null;\r\n\r\n        // ✅ Fetch suppliers providing this item\r\n        const supplierQuery = `\r\n            SELECT S.s_ID, S.name, S.contact, ISUP.unit_cost\r\n            FROM Supplier S\r\n                     JOIN item_supplier ISUP ON S.s_ID = ISUP.s_ID\r\n            WHERE ISUP.I_Id = ?`;\r\n\r\n        const [suppliersResult] = await db.query(supplierQuery, [I_Id]);\r\n\r\n        const suppliers = suppliersResult.map(supplier => ({\r\n            s_ID: supplier.s_ID,\r\n            name: supplier.name,\r\n            contact: supplier.contact,\r\n            unit_cost: supplier.unit_cost\r\n        }));\r\n\r\n        // ✅ Fetch stock details from `p_i_detail` table\r\n        const stockQuery = `\r\n            SELECT pid_Id, stock_Id, pc_Id, status, orID, datetime\r\n            FROM p_i_detail\r\n            WHERE I_Id = ?\r\n              AND status IN ('Available', 'Damage', 'Reserved')\r\n            ORDER BY pid_Id ASC, FIELD(status, 'Available', 'Reserved', 'Damage')`;\r\n\r\n        const [stockResults] = await db.query(stockQuery, [I_Id]);\r\n\r\n        const stockDetails = stockResults.map(stock => ({\r\n            pid_Id: stock.pid_Id,\r\n            stock_Id: stock.stock_Id,\r\n            pc_Id: stock.pc_Id,\r\n            status: stock.status,\r\n            orID: stock.orID,\r\n            datetime: stock.datetime\r\n        }));\r\n\r\n        // ✅ Construct final response\r\n        const responseData = {\r\n            success: true,\r\n            item: {\r\n                I_Id: itemData.I_Id,\r\n                I_name: itemData.I_name,\r\n                descrip: itemData.descrip,\r\n                color: itemData.color,\r\n                material: itemData.material,\r\n                price: itemData.price,\r\n                stockQty: itemData.stockQty,\r\n                availableQty: itemData.availableQty,\r\n                bookedQty: itemData.bookedQty,\r\n                warrantyPeriod: itemData.warrantyPeriod,\r\n                minQTY: itemData.minQTY,\r\n                maincategory: itemData.mn_Cat,\r\n                sub_one: itemData.sb_catOne,\r\n                sub_two: itemData.sb_catTwo,\r\n                img: mainImgBase64,\r\n                img1: img1Base64,\r\n                img2: img2Base64,\r\n                img3: img3Base64,\r\n                suppliers: suppliers,\r\n                stockDetails: stockDetails // Only 'Available', 'Reserved', 'Damage'\r\n            }\r\n        };\r\n\r\n        return res.status(200).json(responseData);\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Error fetching item details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= pending\r\nrouter.get(\"/orders-pending\", async (req, res) => {\r\n    try {\r\n        // Join Orders with Customer to get contact numbers\r\n        const query = `\r\n            SELECT \r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, \r\n                o.delPrice, o.discount, o.total, o.advance, o.balance, o.payStatus,\r\n                o.stID, o.expectedDate,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'pending'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No pending orders found\" });\r\n        }\r\n\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID: order.OrID,\r\n            orDate: order.orDate,\r\n            customer: order.c_ID,\r\n            ordertype: order.ordertype,\r\n            orStatus: order.orStatus,\r\n            dvStatus: order.delStatus,\r\n            dvPrice: order.delPrice,\r\n            disPrice: order.discount,\r\n            totPrice: order.total,\r\n            advance: order.advance,\r\n            balance: order.balance,\r\n            payStatus: order.payStatus,\r\n            stID: order.stID,\r\n            expectedDeliveryDate: order.expectedDate,\r\n            contact1: order.contact1,\r\n            contact2: order.contact2\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching pending orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= pending & specific sale team\r\nrouter.get(\"/orders-pending-stid\", async (req, res) => {\r\n    try {\r\n        const Eid = req.query.eid;\r\n\r\n        // Step 1: Get sales team ID (stID) for this employee\r\n        const [salesResult] = await db.query(\r\n            \"SELECT stID FROM sales_team WHERE E_Id = ?\",\r\n            [Eid]\r\n        );\r\n\r\n        if (salesResult.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team entry found for this employee.\" });\r\n        }\r\n\r\n        const stID = salesResult[0].stID;\r\n\r\n        // Step 2: Get pending orders assigned to this sales team with customer contact info\r\n        const [orders] = await db.query(\r\n            `SELECT \r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus,\r\n                o.delPrice, o.discount, o.total, o.advance, o.balance, o.payStatus,\r\n                o.stID, o.expectedDate,\r\n                c.contact1, c.contact2\r\n             FROM Orders o\r\n             JOIN Customer c ON o.c_ID = c.c_ID\r\n             WHERE o.orStatus = 'pending' AND o.stID = ?`,\r\n            [stID]\r\n        );\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No pending orders found for this sales team.\" });\r\n        }\r\n\r\n        // Step 3: Format and send orders\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID: order.OrID,\r\n            orDate: order.orDate,\r\n            customer: order.c_ID,\r\n            ordertype: order.ordertype,\r\n            orStatus: order.orStatus,\r\n            dvStatus: order.delStatus,\r\n            dvPrice: order.delPrice,\r\n            disPrice: order.discount,\r\n            totPrice: order.total,\r\n            advance: order.advance,\r\n            balance: order.balance,\r\n            payStatus: order.payStatus,\r\n            stID: order.stID,\r\n            expectedDeliveryDate: order.expectedDate,\r\n            contact1: order.contact1,\r\n            contact2: order.contact2,\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= accepting\r\n// \uD83D\uDCCC Categorize orders into booked and unbooked\r\nfunction categorizeOrders(orders) {\r\n    const groupedOrders = {};\r\n\r\n    orders.forEach(order => {\r\n        if (!groupedOrders[order.OrID]) {\r\n            groupedOrders[order.OrID] = {\r\n                OrID: order.OrID,\r\n                orDate: order.orDate,\r\n                customer: order.c_ID,\r\n                ordertype: order.ordertype,\r\n                orStatus: order.orStatus,\r\n                dvStatus: order.delStatus,\r\n                dvPrice: order.delPrice,\r\n                disPrice: order.discount,\r\n                totPrice: order.total,\r\n                advance: order.advance,\r\n                balance: order.balance,\r\n                payStatus: order.payStatus,\r\n                stID: order.stID,\r\n                expectedDeliveryDate: order.expectedDeliveryDate,\r\n                itemReceived: order.itemReceived,\r\n                contact1: order.contact1,\r\n                contact2: order.contact2,\r\n                acceptanceStatuses: []\r\n            };\r\n        }\r\n\r\n        groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n    });\r\n\r\n    const bookedOrders = [];\r\n    const unbookedOrders = [];\r\n\r\n    Object.values(groupedOrders).forEach(order => {\r\n        const allComplete = order.acceptanceStatuses.every(status => status === \"Complete\");\r\n        order.acceptanceStatus = allComplete ? \"Complete\" : \"Incomplete\";\r\n\r\n        if (allComplete) {\r\n            bookedOrders.push(order);\r\n        } else {\r\n            unbookedOrders.push(order);\r\n        }\r\n    });\r\n\r\n    return { bookedOrders, unbookedOrders };\r\n}\r\n\r\nrouter.get(\"/orders-accepting\", async (req, res) => {\r\n    try {\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus,\r\n                o.delPrice, o.discount, o.advance, o.balance, o.payStatus,\r\n                o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived, ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Accepted'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        const { bookedOrders, unbookedOrders } = categorizeOrders(orders);\r\n\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            data: { bookedOrders, unbookedOrders }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n//Get all orders by status= accepting & specific sale team\r\nrouter.get(\"/orders-accepting-stid\", async (req, res) => {\r\n    try {\r\n        const Eid = req.query.eid;\r\n        if (!Eid) return res.status(400).json({ message: \"Missing 'eid' in query params\" });\r\n\r\n        // Step 1: Get sales team ID (stID) for this employee\r\n        const [salesResult] = await db.query(\"SELECT stID FROM sales_team WHERE E_Id = ?\", [Eid]);\r\n        if (salesResult.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team entry found for this employee.\" });\r\n        }\r\n\r\n        const stID = salesResult[0].stID;\r\n\r\n        // Step 2: Fetch accepted orders assigned to this stID with customer contacts\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Accepted' AND o.stID = ?\r\n        `;\r\n\r\n        const [orders] = await db.query(query, [stID]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found for this sales team.\" });\r\n        }\r\n\r\n        const categorized = categorizeOrders(orders);\r\n\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            data: categorized\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= Processing\r\nrouter.get(\"/orders-Processing\", async (req, res) => {\r\n    try {\r\n        // Query to fetch processing orders with customer contacts\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Processing'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Processing orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    contact1: order.contact1,\r\n                    contact2: order.contact2,\r\n                    acceptanceStatus: \"Complete\", // default\r\n                    acceptanceStatuses: []\r\n                };\r\n            }\r\n\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        return res.status(200).json({\r\n            message: \"Processing orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching Processing orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching Processing orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= completed & specific sale team\r\nrouter.get(\"/orders-Processing-stid\", async (req, res) => {\r\n    try {\r\n        const Eid = req.query.eid;\r\n\r\n        if (!Eid) {\r\n            return res.status(400).json({ message: \"Missing 'eid' in query params\" });\r\n        }\r\n\r\n        // Step 1: Get sales team ID (stID) for this employee\r\n        const [salesResult] = await db.query(\"SELECT stID FROM sales_team WHERE E_Id = ?\", [Eid]);\r\n\r\n        if (salesResult.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team entry found for this employee.\" });\r\n        }\r\n\r\n        const stID = salesResult[0].stID;\r\n\r\n        // Step 2: Query to fetch processing orders with customer contacts\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Processing' AND o.stID = ?\r\n        `;\r\n\r\n        const [orders] = await db.query(query, [stID]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Processing orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    contact1: order.contact1,\r\n                    contact2: order.contact2,\r\n                    acceptanceStatus: \"Complete\",\r\n                    acceptanceStatuses: []\r\n                };\r\n            }\r\n\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        return res.status(200).json({\r\n            message: \"Processing orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching Processing orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching Processing orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= completed\r\nrouter.get(\"/orders-completed\", async (req, res) => {\r\n    try {\r\n        // Query to fetch completed orders with customer contact information\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Completed'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Completed orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    contact1: order.contact1,\r\n                    contact2: order.contact2,\r\n                    acceptanceStatus: \"Complete\",\r\n                    acceptanceStatuses: []\r\n                };\r\n            }\r\n\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        return res.status(200).json({\r\n            message: \"Completed orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching completed orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= completed & specific sale team\r\nrouter.get(\"/orders-completed-stid\", async (req, res) => {\r\n    try {\r\n        const Eid = req.query.eid;\r\n\r\n        if (!Eid) {\r\n            return res.status(400).json({ message: \"Missing 'eid' in query params\" });\r\n        }\r\n\r\n        // Step 1: Get sales team ID (stID) for this employee\r\n        const [salesResult] = await db.query(\r\n            \"SELECT stID FROM sales_team WHERE E_Id = ?\",\r\n            [Eid]\r\n        );\r\n\r\n        if (salesResult.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team entry found for this employee.\" });\r\n        }\r\n\r\n        const stID = salesResult[0].stID;\r\n\r\n        // Query to fetch completed orders with customer contact info\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Completed' AND o.stID = ?\r\n        `;\r\n\r\n        const [orders] = await db.query(query, [stID]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Completed orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    contact1: order.contact1,\r\n                    contact2: order.contact2,\r\n                    acceptanceStatus: \"Complete\",\r\n                    acceptanceStatuses: []\r\n                };\r\n            }\r\n\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        return res.status(200).json({\r\n            message: \"Completed orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching completed orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= issued\r\nrouter.get(\"/orders-issued\", async (req, res) => {\r\n    try {\r\n        // Query to fetch issued orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Issued'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Issued orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    contact1: order.contact1,\r\n                    contact2: order.contact2,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Issued orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching issued orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching issued orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= issued & specific sale team\r\nrouter.get(\"/orders-issued-stid\", async (req, res) => {\r\n    try {\r\n        const Eid = req.query.eid;\r\n        // Step 1: Get sales team ID (stID) for this employee\r\n        const [salesResult] = await db.query(\r\n            \"SELECT stID FROM sales_team WHERE E_Id = ?\",\r\n            [Eid]\r\n        );\r\n\r\n        if (salesResult.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team entry found for this employee.\" });\r\n        }\r\n\r\n        const stID = salesResult[0].stID;\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2\r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Issued' AND stID = ?\r\n        `;\r\n\r\n        const [orders] = await db.query(query, [stID]);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Issued orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    contact1: order.contact1,\r\n                    contact2: order.contact2,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Issued orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching issued orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching issued orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= delivered\r\nrouter.get(\"/orders-delivered\", async (req, res) => {\r\n    try {\r\n        // Fetch delivered orders with acceptance statuses and customer contacts\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2 \r\n            FROM Orders o\r\n                LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n                LEFT JOIN Customer c ON o.c_ID = c.c_ID  \r\n            WHERE o.orStatus = 'Delivered'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        if (!orders.length) {\r\n            return res.status(404).json({ message: \"No Delivered orders found\" });\r\n        }\r\n\r\n        const groupedOrders = {};\r\n\r\n        for (const order of orders) {\r\n            const {\r\n                OrID, orDate, c_ID, ordertype, orStatus, delStatus, delPrice,\r\n                discount, advance, balance, payStatus, total, stID, expectedDeliveryDate,\r\n                itemReceived, acceptanceStatus, contact1, contact2\r\n            } = order;\r\n\r\n            if (!groupedOrders[OrID]) {\r\n                groupedOrders[OrID] = {\r\n                    OrID,\r\n                    orDate,\r\n                    customer: c_ID,\r\n                    ordertype,\r\n                    orStatus,\r\n                    dvStatus: delStatus,\r\n                    dvPrice: delPrice,\r\n                    disPrice: discount,\r\n                    totPrice: total,\r\n                    advance,\r\n                    balance,\r\n                    payStatus,\r\n                    stID,\r\n                    expectedDeliveryDate,\r\n                    contact1,\r\n                    contact2,\r\n                    acceptanceStatuses: [],\r\n                    acceptanceStatus: \"Complete\"\r\n                };\r\n            }\r\n\r\n            // Track individual item statuses\r\n            groupedOrders[OrID].acceptanceStatuses.push(acceptanceStatus);\r\n\r\n            // Update to \"Incomplete\" if any item is not fully accepted\r\n            if (acceptanceStatus === \"In Production\" || acceptanceStatus === \"None\") {\r\n                groupedOrders[OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        }\r\n\r\n        // Return structured response\r\n        return res.status(200).json({\r\n            message: \"Delivered orders found.\",\r\n            data: Object.values(groupedOrders),\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Error fetching delivered orders:\", error.message);\r\n        return res.status(500).json({\r\n            message: \"Error fetching delivered orders\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get all orders by status= delivered\r\nrouter.get(\"/orders-delivered-stid\", async (req, res) => {\r\n    try {\r\n        const Eid = req.query.eid;\r\n        if (!Eid) {\r\n            return res.status(400).json({ message: \"Employee ID (eid) is required\" });\r\n        }\r\n\r\n        // \uD83D\uDD0D Step 1: Get sales team ID (stID) for the employee\r\n        const [salesResult] = await db.query(\r\n            \"SELECT stID FROM sales_team WHERE E_Id = ?\",\r\n            [Eid]\r\n        );\r\n\r\n        if (!salesResult.length) {\r\n            return res.status(404).json({ message: \"No sales team entry found for this employee.\" });\r\n        }\r\n\r\n        const stID = salesResult[0].stID;\r\n\r\n        // \uD83D\uDCE6 Step 2: Fetch Delivered Orders belonging to this stID\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus,\r\n                c.contact1, c.contact2 \r\n            FROM Orders o\r\n            LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            LEFT JOIN Customer c ON o.c_ID = c.c_ID  \r\n            WHERE o.orStatus = 'Delivered' AND o.stID = ?\r\n        `;\r\n\r\n        const [orders] = await db.query(query, [stID]);\r\n\r\n        if (!orders.length) {\r\n            return res.status(404).json({ message: \"No Delivered orders found\" });\r\n        }\r\n\r\n        // \uD83E\uDDE0 Step 3: Group by Order ID\r\n        const groupedOrders = {};\r\n\r\n        for (const order of orders) {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    contact1: order.contact1,\r\n                    contact2: order.contact2,\r\n                    acceptanceStatus: \"Complete\",\r\n                    acceptanceStatuses: []\r\n                };\r\n            }\r\n\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        }\r\n\r\n        // \uD83E\uDDFE Step 4: Format response\r\n        return res.status(200).json({\r\n            message: \"Delivered orders found.\",\r\n            data: Object.values(groupedOrders),\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Error fetching delivered orders by stID:\", error.message);\r\n        return res.status(500).json({\r\n            message: \"Error fetching delivered orders\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get all orders by status= delivered & specific sale team\r\nrouter.get(\"/orders-returned\", async (req, res) => {\r\n    try {\r\n        // Query to fetch returned orders with their acceptance status, return reason, and customer contact numbers\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived, ao.status AS acceptanceStatus,\r\n                ro.detail AS returnReason,\r\n                c.contact1, c.contact2  -- Add customer contact numbers\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n                     LEFT JOIN return_orders ro ON o.OrID = ro.OrID\r\n                     LEFT JOIN customers c ON o.c_ID = c.c_ID  -- Join customers table to fetch contact numbers\r\n            WHERE o.orStatus = 'Returned'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No returned orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    returnReason: order.returnReason || \"No reason provided\", // Handle null reasons\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    contact1: order.contact1,  // Add contact1 to the response\r\n                    contact2: order.contact2,  // Add contact2 to the response\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Returned orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching returned orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching returned orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= returned & specific sale team\r\nrouter.get(\"/orders-returned-stid\", async (req, res) => {\r\n    try {\r\n        const Eid = req.query.eid;\r\n        // Step 1: Get sales team ID (stID) for this employee\r\n        const [salesResult] = await db.query(\r\n            \"SELECT stID FROM sales_team WHERE E_Id = ?\",\r\n            [Eid]\r\n        );\r\n\r\n        if (salesResult.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team entry found for this employee.\" });\r\n        }\r\n\r\n        const stID = salesResult[0].stID;\r\n        \r\n        // Query to fetch returned orders with their acceptance status, return reason, and customer contact numbers\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived, ao.status AS acceptanceStatus,\r\n                ro.detail AS returnReason,\r\n                c.contact1, c.contact2  -- Add customer contact numbers\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n                     LEFT JOIN return_orders ro ON o.OrID = ro.OrID\r\n                     LEFT JOIN customers c ON o.c_ID = c.c_ID  -- Join customers table to fetch contact numbers\r\n            WHERE o.orStatus = 'Returned' AND o.stID = ?\r\n        `;\r\n\r\n        const [orders] = await db.query(query, [stID]);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No returned orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    returnReason: order.returnReason || \"No reason provided\", // Handle null reasons\r\n                    contact1: order.contact1,  // Add contact1 to the response\r\n                    contact2: order.contact2,  // Add contact2 to the response\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Returned orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching returned orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching returned orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= canceled\r\nrouter.get(\"/orders-canceled\", async (req, res) => {\r\n    try {\r\n        // Query to fetch canceled orders with their acceptance status, return reason, and customer contact numbers\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived, ao.status AS acceptanceStatus,\r\n                ro.detail AS returnReason,\r\n                c.contact1, c.contact2  -- Add customer contact numbers\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n                     LEFT JOIN return_orders ro ON o.OrID = ro.OrID\r\n                     LEFT JOIN customers c ON o.c_ID = c.c_ID  -- Join customers table to fetch contact numbers\r\n            WHERE o.orStatus = 'Cancelled'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No canceled orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    returnReason: order.returnReason || \"No reason provided\", // Handle null reasons\r\n                    contact1: order.contact1,  // Add contact1 to the response\r\n                    contact2: order.contact2,  // Add contact2 to the response\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Canceled orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching canceled orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching canceled orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= canceled & specific sale team\r\nrouter.get(\"/orders-canceled-stid\", async (req, res) => {\r\n    try {\r\n        const Eid = req.query.eid;\r\n        // Step 1: Get sales team ID (stID) for this employee\r\n        const [salesResult] = await db.query(\r\n            \"SELECT stID FROM sales_team WHERE E_Id = ?\",\r\n            [Eid]\r\n        );\r\n\r\n        if (salesResult.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team entry found for this employee.\" });\r\n        }\r\n\r\n        const stID = salesResult[0].stID;\r\n\r\n        // Query to fetch canceled orders with their acceptance status, return reason, and customer contact numbers\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived, ao.status AS acceptanceStatus,\r\n                ro.detail AS returnReason,\r\n                c.contact1, c.contact2  -- Add customer contact numbers\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n                     LEFT JOIN return_orders ro ON o.OrID = ro.OrID\r\n                     LEFT JOIN customers c ON o.c_ID = c.c_ID  -- Join customers table to fetch contact numbers\r\n            WHERE o.orStatus = 'Cancelled' AND stID = ?\r\n        `;\r\n\r\n        const [orders] = await db.query(query, [stID]);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No canceled orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    returnReason: order.returnReason || \"No reason provided\", // Handle null reasons\r\n                    contact1: order.contact1,  // Add contact1 to the response\r\n                    contact2: order.contact2,  // Add contact2 to the response\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Canceled orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching canceled orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching canceled orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= inproduction\r\nrouter.get(\"/orders-inproduction\", async (req, res) => {\r\n    try {\r\n        // Query to fetch incomplete production orders along with unit cost\r\n        const query = `\r\n            SELECT \r\n                p.p_ID,\r\n                p.I_Id,\r\n                p.qty,\r\n                p.s_ID,\r\n                p.expectedDate,\r\n                p.specialNote,\r\n                p.status,\r\n                isup.unit_cost\r\n            FROM production p\r\n            LEFT JOIN item_supplier isup ON p.I_Id = isup.I_Id AND p.s_ID = isup.s_ID\r\n            WHERE p.status = 'Incomplete'\r\n        `;\r\n\r\n        const [suporders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (suporders.length === 0) {\r\n            return res.status(404).json({ message: \"No supplier orders found\" });\r\n        }\r\n\r\n        // Format orders\r\n        const formattedOrders = suporders.map(order => ({\r\n            p_ID: order.p_ID,\r\n            I_Id: order.I_Id,\r\n            qty: order.qty,\r\n            s_ID: order.s_ID,\r\n            expectedDate: order.expectedDate,\r\n            specialNote: order.specialNote,\r\n            status: order.status,\r\n            unit_cost: order.unit_cost !== null ? order.unit_cost : 0  // Handle missing unit cost\r\n        }));\r\n\r\n        // Send the formatted orders as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching pending orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all items where stock count is less than or equal to one\r\nrouter.get(\"/allitemslessone\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch items with qty <= 1\r\n        const [items] = await db.query(\r\n            \"SELECT I_Id, I_name, descrip, price,stockQty, availableQty, img FROM Item WHERE availableQty <= minQTY\"\r\n        );\r\n\r\n        // If no items found, return a 404 status with a descriptive message\r\n        if (items.length === 0) {\r\n            return res.status(404).json({ message: \"No items found with stock count less than or equal to 1\" });\r\n        }\r\n\r\n        // Format the items data with necessary fields\r\n        const formattedItems = items.map(item => ({\r\n            I_Id: item.I_Id,\r\n            I_name: item.I_name,\r\n            descrip: item.descrip,\r\n            price: item.price,\r\n            availableQty: item.availableQty,\r\n            stockQty: item.stockQty,\r\n            img: `data:image/png;base64,${item.img.toString(\"base64\")}`, // Convert image to base64\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedItems);\r\n    } catch (error) {\r\n        console.error(\"Error fetching items:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching items\" });\r\n    }\r\n});\r\n\r\n// get all suppliers for the item\r\nrouter.get(\"/item-suppliers\", async (req, res) => {\r\n    try {\r\n        const { I_Id } = req.query;\r\n\r\n        // Validate the input\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Step 1: Fetch the suppliers associated with the item from item_supplier table\r\n        const itemSuppliersQuery = `\r\n            SELECT s_ID\r\n            FROM item_supplier\r\n            WHERE I_Id = ?`;\r\n\r\n        const [itemSuppliersResult] = await db.query(itemSuppliersQuery, [I_Id]);\r\n\r\n        if (itemSuppliersResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No suppliers found for the given item\" });\r\n        }\r\n\r\n        // Step 2: Extract the supplier IDs from the result\r\n        const supplierIds = itemSuppliersResult.map(row => row.s_ID);\r\n\r\n        // Step 3: Fetch the supplier details using the supplier IDs\r\n        const suppliersQuery = `\r\n            SELECT s_ID, name, contact\r\n            FROM Supplier\r\n            WHERE s_ID IN (?)`;\r\n\r\n        const [suppliersResult] = await db.query(suppliersQuery, [supplierIds]);\r\n\r\n        // Step 4: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            suppliers: suppliersResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item suppliers:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// get all items for the supplier\r\nrouter.get(\"/supplier-items\", async (req, res) => {\r\n    try {\r\n        const { s_Id } = req.query;\r\n\r\n        // Validate input\r\n        if (!s_Id) {\r\n            return res.status(400).json({ success: false, message: \"Supplier ID is required\" });\r\n        }\r\n\r\n        // Query to fetch supplier's items along with cost, warranty period, and image\r\n        const query = `\r\n            SELECT\r\n                item_supplier.I_Id,\r\n                Item.I_name,\r\n                Item.color,\r\n                item_supplier.unit_cost,\r\n                Item.warrantyPeriod,\r\n                Item.img,\r\n                Item.material,\r\n                Item.price\r\n            FROM item_supplier\r\n                     JOIN Item ON Item.I_Id = item_supplier.I_Id\r\n            WHERE item_supplier.s_ID = ?\r\n        `;\r\n\r\n        const [itemsResult] = await db.query(query, [s_Id]);\r\n\r\n        // If no items found, return a 404 response\r\n        if (itemsResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No items found for the given supplier\" });\r\n        }\r\n\r\n        // Convert image binary data to Base64\r\n        const itemsWithImages = itemsResult.map(item => ({\r\n            ...item,\r\n            img: item.img ? `data:image/jpeg;base64,${item.img.toString('base64')}` : null  // Convert LONGBLOB to Base64\r\n        }));\r\n\r\n        // Return the supplier's items with cost, warranty period, and image\r\n        return res.status(200).json({\r\n            success: true,\r\n            items: itemsWithImages,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching supplier items:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// get all have to payment to supplier\r\nrouter.get(\"/unpaid-stock-details\", async (req, res) => {\r\n    try {\r\n        const { s_Id } = req.query;\r\n\r\n        // Validate input\r\n        if (!s_Id) {\r\n            return res.status(400).json({ success: false, message: \"Supplier ID is required\" });\r\n        }\r\n\r\n        // Query to fetch unpaid stock details from the purchase table\r\n        const query = `\r\n            SELECT pc_Id, rDate, total, pay, balance, deliveryCharge, invoiceId \r\n            FROM purchase \r\n            WHERE s_ID = ? AND balance > 0;\r\n        `;\r\n\r\n        const totalQuery = `\r\n            SELECT SUM(total) AS fullTotal \r\n            FROM purchase \r\n            WHERE s_ID = ? AND balance > 0;\r\n        `;\r\n\r\n        const [itemsResult] = await db.query(query, [s_Id]);\r\n        const [[totalResult]] = await db.query(totalQuery, [s_Id]);\r\n\r\n        // If no unpaid items found, return a 404 response\r\n        if (itemsResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No unpaid stock details found for the given supplier\" });\r\n        }\r\n\r\n        // Return the unpaid stock details along with the full total\r\n        return res.status(200).json({\r\n            success: true,\r\n            unpaidStockDetails: itemsResult,\r\n            fullTotal: totalResult.fullTotal || 0, // Ensure fullTotal is returned even if null\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching unpaid stock details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all suppliers\r\nrouter.get(\"/suppliers\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all suppliers\r\n        const suppliersQuery = `SELECT s_ID, name, contact,contact2,address FROM Supplier`;\r\n\r\n        const [suppliersResult] = await db.query(suppliersQuery);\r\n        // Step 2: Check if suppliers were found\r\n        if (suppliersResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No suppliers found\" });\r\n        }\r\n\r\n        // Step 3: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            suppliers: suppliersResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching suppliers:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all employees\r\nrouter.get(\"/employees\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all suppliers\r\n        const employeesQuery = `SELECT E_Id, name, nic, job, basic FROM Employee`;\r\n\r\n        const [employeesResult] = await db.query(employeesQuery);\r\n        // Step 2: Check if suppliers were found\r\n        if (employeesResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No employees found\" });\r\n        }\r\n\r\n        // Step 3: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            employees: employeesResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching employees:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get employee full details\r\nrouter.get(\"/employee-details\", async (req, res) => {\r\n    try {\r\n        const { E_Id } = req.query;\r\n        if (!E_Id) return res.status(400).json({ message: \"Missing E_Id parameter.\" });\r\n\r\n        // 1. Basic Employee Info\r\n        const empQuery = `SELECT * FROM Employee WHERE E_Id = ?`;\r\n        const [empResults] = await db.execute(empQuery, [E_Id]);\r\n\r\n        if (empResults.length === 0) {\r\n            return res.status(404).json({ message: \"Employee not found.\" });\r\n        }\r\n\r\n        const employee = empResults[0];\r\n\r\n        // 2. Check if Driver\r\n        const driverQuery = `\r\n            SELECT devID, balance, dailyTarget, monthlyTarget, lincenseDate, lincense\r\n            FROM driver\r\n            WHERE E_ID = ?\r\n        `;\r\n        const [driverResults] = await db.execute(driverQuery, [E_Id]);\r\n\r\n        let driverDetails = null;\r\n        if (driverResults.length > 0) {\r\n            const d = driverResults[0];\r\n            driverDetails = {\r\n                ...d,\r\n                lincense: d.lincense ? Buffer.from(d.lincense).toString(\"base64\") : null\r\n            };\r\n        }\r\n\r\n        // 3. Check if Sales Team Member\r\n        const salesQuery = `\r\n            SELECT stID, orderTarget, issuedTarget, totalOrder, totalIssued\r\n            FROM sales_team\r\n            WHERE E_Id = ?\r\n        `;\r\n        const [salesResults] = await db.execute(salesQuery, [E_Id]);\r\n\r\n        const salesDetails = salesResults.length > 0 ? salesResults[0] : null;\r\n\r\n        // 4. Compose response\r\n        const response = {\r\n            ...employee,\r\n            role: employee.job.toLowerCase(), // optional\r\n            driver: driverDetails,\r\n            sales: salesDetails\r\n        };\r\n\r\n        return res.status(200).json({ success: true, data: response });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching employee details:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching employee details.\" });\r\n    }\r\n});\r\n\r\n// Update employee detail\r\nrouter.put(\"/employees/:id\", async (req, res) => {\r\n    const E_Id = req.params.id;\r\n    console.log(E_Id);\r\n    const {\r\n        name,address,nic,dob,contact,job, basic,type,driver, sales} = req.body;\r\n\r\n    try {\r\n        // 1. Update Employee table\r\n        const updateEmployeeQuery = `\r\n            UPDATE Employee\r\n            SET name = ?, address = ?, nic = ?, dob = ?, contact = ?, job = ?, basic = ?, type = ?\r\n            WHERE E_Id = ?\r\n        `;\r\n        await db.execute(updateEmployeeQuery, [\r\n            name,\r\n            address,\r\n            nic,\r\n            dob,\r\n            contact,\r\n            job,\r\n            basic,\r\n            type,\r\n            E_Id\r\n        ]);\r\n\r\n        // 2. Handle driver role\r\n        if (job.toLowerCase() === \"driver\" && driver) {\r\n            const { devID, balance, dailyTarget, monthlyTarget } = driver;\r\n\r\n            const [driverCheck] = await db.execute(`SELECT * FROM driver WHERE E_ID = ?`, [E_Id]);\r\n\r\n            if (driverCheck.length > 0) {\r\n                const updateDriver = `\r\n                    UPDATE driver\r\n                    SET  balance = ?, dailyTarget = ?, monthlyTarget = ?\r\n                    WHERE devID = ?\r\n                `;\r\n                await db.execute(updateDriver, [ balance, dailyTarget, monthlyTarget, devID]);\r\n            } else {\r\n                const insertDriver = `\r\n                    INSERT INTO driver (devID, E_ID, balance, dailyTarget, monthlyTarget)\r\n                    VALUES (?, ?, ?, ?, ?)\r\n                `;\r\n                await db.execute(insertDriver, [devID, E_Id, balance, dailyTarget, monthlyTarget]);\r\n            }\r\n        } else {\r\n            // Optional: Delete driver if not a driver anymore\r\n            await db.execute(`DELETE FROM driver WHERE E_ID = ?`, [E_Id]);\r\n        }\r\n\r\n        // 3. Handle sales role\r\n        if (job.toLowerCase() === \"sales\" && sales) {\r\n            const { stID, orderTarget, issuedTarget, totalOrder, totalIssued } = sales;\r\n\r\n            const [salesCheck] = await db.execute(`SELECT * FROM sales_team WHERE E_Id = ?`, [E_Id]);\r\n\r\n            if (salesCheck.length > 0) {\r\n                const updateSales = `\r\n                    UPDATE sales_team\r\n                    SET  orderTarget = ?, issuedTarget = ?\r\n                    WHERE stID = ?\r\n                `;\r\n                await db.execute(updateSales, [orderTarget, issuedTarget, stID]);\r\n            } else {\r\n                const insertSales = `\r\n                    INSERT INTO sales_team (stID, E_Id, orderTarget, issuedTarget, totalOrder, totalIssued)\r\n                    VALUES (?, ?, ?, ?, 0,0)\r\n                `;\r\n                await db.execute(insertSales, [stID, E_Id, orderTarget, issuedTarget]);\r\n            }\r\n        } else {\r\n            // Optional: Delete sales data if not in sales anymore\r\n            await db.execute(`DELETE FROM sales_team WHERE E_Id = ?`, [E_Id]);\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Employee updated successfully.\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating employee:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Failed to update employee\", error: error.message });\r\n    }\r\n});\r\n\r\n// get Permanent employees\r\nrouter.get(\"/Permanent-employees\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all suppliers\r\n        const employeesQuery = `SELECT E_Id, name, nic, job, basic FROM Employee WHERE type='Permanent'`;\r\n\r\n        const [employeesResult] = await db.query(employeesQuery);\r\n        // Step 2: Check if suppliers were found\r\n        if (employeesResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No employees found\" });\r\n        }\r\n\r\n        // Step 3: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            employees: employeesResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching employees:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// get item detail in item table only\r\nrouter.get(\"/item-detail\", async (req, res) => {\r\n    try {\r\n        const { Id } = req.query;\r\n\r\n        if (!Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Step 1: Fetch Item details\r\n        const itemQuery = `\r\n            SELECT\r\n                I.I_Id, I.I_name, I.descrip, I.price, I.stockQty,I.bookedQty,I.availableQty,\r\n                I.warrantyPeriod, I.img\r\n            FROM Item I\r\n            WHERE I.I_Id = ?`;\r\n\r\n        const [itemResult] = await db.query(itemQuery, [Id]);\r\n\r\n        if (itemResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found\" });\r\n        }\r\n\r\n        const itemData1 = itemResult[0];\r\n        // Step 2: Construct final response\r\n        const responseData = {\r\n            success: true,\r\n            item: {\r\n                I_Id: itemData1.I_Id,\r\n                I_name: itemData1.I_name,\r\n                price: itemData1.price,\r\n                stockQty: itemData1.stockQty,\r\n                bookedQty: itemData1.bookedQty,\r\n                availableQty: itemData1.availableQty,\r\n            }\r\n        };\r\n\r\n        return res.status(200).json(responseData);\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// save in production\r\nrouter.post('/add-production', async (req, res) => {\r\n    const {itemId, qty, supplierId, expectedDate, specialnote} = req.body;\r\n\r\n    if (!itemId || !qty || !supplierId || !expectedDate) {\r\n        return res.status(400).json({error: 'All fields are required'});\r\n    }\r\n\r\n    const p_ID = `InP_${Date.now()}`;\r\n\r\n    const sql = `INSERT INTO production (p_ID, I_Id, qty, s_ID, expectedDate, specialNote,status)\r\n                 VALUES (?, ?, ?, ?, ?, ?,'Incomplete')`;\r\n    const [Result] = await db.query(sql, [p_ID, itemId, qty, supplierId, expectedDate, specialnote]);\r\n    return res.status(200).json({\r\n        success: true,\r\n        message: \"Order details fetched successfully\",\r\n        result: Result\r\n    });\r\n});\r\n\r\n// Get category namees\r\nrouter.get(\"/getcategory\", async (req, res) => {\r\n    const { category } = req.query;\r\n\r\n    // Check if category is provided\r\n    if (!category) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Category is required\",\r\n        });\r\n    }\r\n\r\n    // SQL query to join Category and subCat_one based on category name\r\n    const sql = `\r\n        SELECT sc.sb_c_id, sc.subcategory, sc.img, c.name AS category\r\n        FROM subCat_one sc\r\n                 INNER JOIN Category c ON sc.Ca_Id = c.Ca_Id\r\n        WHERE c.name = ?\r\n    `;\r\n\r\n    try {\r\n        const [rows] = await db.query(sql, [category]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No images found for the given category\",\r\n            });\r\n        }\r\n\r\n        // Send back the response with image data\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Category images retrieved successfully\",\r\n            data: rows.map(row => ({\r\n                id: row.sb_c_id,\r\n                category: row.category,\r\n                subcategory: row.subcategory,\r\n                img: row.img.toString(\"base64\"), // Convert binary image to Base64\r\n            })),\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Update stock\r\nrouter.post(\"/update-stock\", upload.single(\"image\"), async (req, res) => {\r\n    const { p_ID, rDate, recCount, cost, delivery, Invoice } = req.body;\r\n    const imageFile = req.file;\r\n\r\n    if (!p_ID || !rDate || !recCount || !cost) {\r\n        return res.status(400).json({ error: \"All fields are required\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch production order details\r\n        const [rows] = await db.query(\r\n            \"SELECT qty, I_Id, s_ID FROM production WHERE p_ID = ?\", [p_ID]\r\n        );\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({ error: \"Production order not found\" });\r\n        }\r\n\r\n        const { qty: currentQty, I_Id: itemId, s_ID: supId } = rows[0];\r\n        const receivedQty = parseInt(recCount);\r\n        const deliveryPrice = parseFloat(delivery) || 0;\r\n        const total = parseFloat(cost) * receivedQty;\r\n\r\n        // Validate that the item exists in `item` table\r\n        const [itemExists] = await db.query(\"SELECT I_Id FROM item WHERE I_Id = ?\", [itemId]);\r\n        if (itemExists.length === 0) {\r\n            return res.status(400).json({ error: \"Item ID does not exist in item table\" });\r\n        }\r\n\r\n        // Generate new purchase ID\r\n        const purchase_id = await generateNewId(\"purchase\", \"pc_Id\", \"PC\");\r\n\r\n        // Handle image upload if any\r\n        let imagePath = null;\r\n        if (imageFile) {\r\n            const imageName = `item_${purchase_id}_${Date.now()}.${imageFile.mimetype.split(\"/\")[1]}`;\r\n            const savePath = path.join(\"./uploads/images\", imageName);\r\n            fs.writeFileSync(savePath, imageFile.buffer);\r\n            imagePath = `/uploads/images/${imageName}`;\r\n        }\r\n\r\n        // Convert date format from 'DD/MM/YYYY' to 'YYYY-MM-DD'\r\n        const formattedDate = rDate.split('/').reverse().join('-');\r\n\r\n        // Insert into the purchase table\r\n        const insertPurchaseQuery = `\r\n            INSERT INTO purchase (pc_Id, s_ID, rDate, total, pay, balance, deliveryCharge, invoiceId)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?)\r\n        `;\r\n        await db.query(insertPurchaseQuery, [purchase_id, supId, formattedDate, total, 0, total, deliveryPrice, Invoice]);\r\n\r\n        // Check if the item already exists in `item_supplier`\r\n        const checkUnitPriceQuery = `SELECT unit_cost FROM item_supplier WHERE I_Id = ? AND s_ID = ?`;\r\n        const [unitPriceResult] = await db.query(checkUnitPriceQuery, [itemId, supId]);\r\n\r\n        if (unitPriceResult.length > 0) {\r\n            const existingUnitPrice = unitPriceResult[0].unit_cost;\r\n            if (parseFloat(existingUnitPrice) !== parseFloat(cost)) {\r\n                // Update unit price if changed\r\n                const updateUnitPriceQuery = `\r\n                    UPDATE item_supplier SET unit_cost = ? WHERE I_Id = ? AND s_ID = ?\r\n                `;\r\n                await db.query(updateUnitPriceQuery, [cost, itemId, supId]);\r\n            }\r\n        } else {\r\n            // Insert new record if it doesn't exist\r\n            const insertUnitPriceQuery = `\r\n                INSERT INTO item_supplier (I_Id, s_ID, unit_cost) VALUES (?, ?, ?)\r\n            `;\r\n            await db.query(insertUnitPriceQuery, [itemId, supId, cost]);\r\n        }\r\n\r\n        // Insert into purchase_detail\r\n        const purchaseDetailQuery = `\r\n            INSERT INTO purchase_detail (pc_Id, I_Id, rec_count, unitPrice, total, stock_range)\r\n            VALUES (?, ?, ?, ?, ?, ?)\r\n        `;\r\n        await db.query(purchaseDetailQuery, [purchase_id, itemId, receivedQty, cost, total, \"\"]);\r\n\r\n        // Barcode Generation\r\n        const barcodeFolderPath = path.join(\"./uploads/barcodes\");\r\n        if (!fs.existsSync(barcodeFolderPath)) {\r\n            fs.mkdirSync(barcodeFolderPath, { recursive: true });\r\n        }\r\n\r\n        const insertBarcodeQuery = `\r\n            INSERT INTO p_i_detail (pc_Id, I_Id, stock_Id, barcode_img, status, orID, datetime)\r\n            VALUES (?, ?, ?, ?, ?, ?,?)\r\n        `;\r\n\r\n        // Get last stock ID for the item\r\n        const [lastStockResult] = await db.query(\r\n            `SELECT MAX(stock_Id) AS lastStockId FROM p_i_detail WHERE I_Id = ?`, [itemId]\r\n        );\r\n        let lastStockId = lastStockResult[0]?.lastStockId || 0;\r\n\r\n        // Generate barcodes\r\n        const startStockId = lastStockId + 1;\r\n        for (let j = 1; j <= receivedQty; j++) {\r\n            lastStockId++;\r\n            const barcodeData = `${itemId}-${lastStockId}`;\r\n            const barcodeImageName = `barcode_${barcodeData}.png`;\r\n            const barcodeImagePath = path.join(barcodeFolderPath, barcodeImageName);\r\n\r\n            // Generate barcode image\r\n            const pngBuffer = await bwipjs.toBuffer({\r\n                bcid: \"code128\",\r\n                text: barcodeData,\r\n                scale: 3,\r\n                height: 10,\r\n                includetext: true,\r\n                textxalign: \"center\",\r\n            });\r\n\r\n            // Save barcode image\r\n            fs.writeFileSync(barcodeImagePath, pngBuffer);\r\n\r\n            // Insert barcode record\r\n            await db.query(insertBarcodeQuery, [purchase_id, itemId, lastStockId, barcodeImagePath, \"Available\", \"\", \"\"]);\r\n        }\r\n\r\n        // Update stock_range in purchase_detail\r\n        const stockRange = `${startStockId}-${lastStockId}`;\r\n        await db.query(\r\n            `UPDATE purchase_detail SET stock_range = ? WHERE pc_Id = ? AND I_Id = ?`,\r\n            [stockRange, purchase_id, itemId]\r\n        );\r\n\r\n        // Update stock in `Item` table\r\n        await db.query(\r\n            `UPDATE Item SET stockQty = stockQty + ?, availableQty = availableQty + ? WHERE I_Id = ?`,\r\n            [receivedQty, receivedQty, itemId]\r\n        );\r\n\r\n        // Determine new status\r\n        let newStatus = \"Incomplete\";\r\n        let newQty = currentQty - receivedQty;\r\n\r\n        if (receivedQty >= currentQty) {\r\n            newStatus = \"Complete\";\r\n            newQty = 0;\r\n        }\r\n\r\n        // Update production table\r\n        await db.query(`UPDATE production SET qty = ?, status = ? WHERE p_ID = ?`, [newQty, newStatus, p_ID]);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Stock received updated successfully\",\r\n            updatedStatus: newStatus,\r\n            remainingQty: newQty,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating stock received:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\", details: error.message });\r\n    }\r\n});\r\n\r\n// Update order in invoice part\r\nrouter.put(\"/update-invoice\", async (req, res) => {\r\n    try {\r\n        const {\r\n            orID,isPickup,netTotal,totalAdvance,previousAdvance,balance,addedAdvance, updatedDeliveryCharge,updatedDiscount,} = req.body;\r\n\r\n        if (!orID) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"Order ID is required\",\r\n            });\r\n        }\r\n\r\n        const op_ID = await generateNewId(\"order_payment\", \"op_ID\", \"OP\");\r\n\r\n        // \uD83D\uDD0D Fetch order details\r\n        const [orderResult] = await db.query(\r\n            `SELECT OrID, orStatus, stID, c_ID FROM Orders WHERE OrID = ?`, [orID]\r\n        );\r\n\r\n        const[issuableResult] = await db.query(\r\n            `SELECT issuable FROM order_payment WHERE OrID = ?`,[orID]\r\n        );\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"Order not found\",\r\n            });\r\n        }\r\n\r\n        const { orStatus, stID, c_ID } = orderResult[0];\r\n        const { issuable }= issuableResult[0];\r\n\r\n        // \uD83D\uDD04 Determine Payment Status\r\n        let payStatus = \"Pending\";\r\n        if (totalAdvance > 0) payStatus = \"Advanced\";\r\n        if (balance === 0) payStatus = \"Settled\";\r\n\r\n        // \uD83D\uDD04 Update Orders table\r\n        const orderUpdateQuery = `\r\n            UPDATE Orders\r\n            SET total = ?, discount = ?, delPrice = ?, advance = ?, balance = ?, payStatus = ? WHERE OrID = ?`;\r\n        await db.query(orderUpdateQuery, [\r\n            netTotal,updatedDiscount,updatedDeliveryCharge, totalAdvance, balance,payStatus,orID,\r\n        ]);\r\n\r\n        // \uD83D\uDED1 If pickup, remove delivery record\r\n        if (isPickup) {\r\n            await db.query(`DELETE FROM delivery WHERE orID = ?`, [orID]);\r\n        }\r\n\r\n        // \uD83D\uDCB0 Insert order payment + cash record\r\n        if (addedAdvance > 0) {\r\n            const fullPaid = parseFloat(previousAdvance || 0) + parseFloat(addedAdvance || 0);\r\n\r\n            await db.query(\r\n                `INSERT INTO order_payment (op_ID, orID, amount, dateTime, or_status, netTotal, stID,fullPaidAmount, balance, c_ID, issuable)\r\n                VALUES (?, ?, ?, NOW(), ?, ?, ?, ?, ?, ?, ?)`,\r\n                [\r\n                    op_ID, orID,addedAdvance,orStatus,netTotal,stID,fullPaid,balance,c_ID,issuable\r\n                ]\r\n            );\r\n\r\n            await db.query(\r\n                `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)\r\n                 VALUES (?, ?, ?, NOW(), ?)`,\r\n                [\"Order payment\", op_ID, \"order\", addedAdvance]\r\n            );\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order and payment updated successfully\",\r\n            payStatus,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"❌ Error updating invoice:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating invoice data\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Fetch Accept orders in booked-unbooked\r\nrouter.get(\"/orders-accept\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all the orders and their associated items' statuses from the accept_orders table.\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Accepted'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        const groupedOrders = {};\r\n        const bookedOrders = [];\r\n        const unbookedOrders = [];\r\n\r\n        // Step 3: Process each order and its items.\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    acceptanceStatuses: [],\r\n                    isUnbooked: false\r\n                };\r\n            }\r\n\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            if (order.acceptanceStatus !== \"Complete\") {\r\n                groupedOrders[order.OrID].isUnbooked = true;\r\n            }\r\n        });\r\n\r\n        // Step 4: Categorize orders.\r\n        Object.values(groupedOrders).forEach(order => {\r\n            if (order.isUnbooked) {\r\n                order.acceptanceStatus = \"Incomplete\";\r\n                unbookedOrders.push(order);\r\n            } else {\r\n                order.acceptanceStatus = \"Complete\";\r\n                bookedOrders.push(order);\r\n            }\r\n        });\r\n\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            bookedOrders: bookedOrders,\r\n            unbookedOrders: unbookedOrders\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// update return order status to other status\r\nrouter.put(\"/updateReturnOrder\", async (req, res) => {\r\n    try {\r\n        const { orderId,  orderStatus,deliveryStatus,  } = req.body;\r\n        // Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orderId]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        const orderUpdateQuery = `UPDATE orders SET orStatus = ?,delStatus = ? WHERE OrID = ?`;\r\n        await db.query(orderUpdateQuery, [\r\n            orderStatus, deliveryStatus, orderId\r\n        ]);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order updated successfully\",\r\n            data: {\r\n                orderId: orderId\r\n            },\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order data:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating data in database\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Update order\r\nrouter.put(\"/update-order-details\", async (req, res) => {\r\n    try {\r\n        const { orderId, orderDate, orderStatus,payStatus,phoneNumber,optionalNumber,netTotal,customerId,\r\n            deliveryStatus, deliveryCharge, discount, totalPrice,advance , balance , expectedDeliveryDate, specialNote } = req.body;\r\n        // Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orderId]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        if (advance === 0 && payStatus === 'Advanced'){\r\n\r\n            return res.status(404).json({ success: false, message: \"payement status cannot change to advance when advance is 0\" });\r\n        }\r\n        // if (advance === null){\r\n        //     const orderUpdateQuery = `\r\n        //     UPDATE orders SET orStatus = ?,delStatus = ? WHERE OrID = ?`;\r\n        //     await db.query(orderUpdateQuery, [\r\n        //          orderStatus, deliveryStatus, orderId\r\n        //     ]);\r\n        // }\r\n\r\n        //Update order details\r\n        const orderUpdateQuery = `\r\n            UPDATE orders SET c_ID =?, orStatus = ?, payStatus = ?,delStatus = ?, delPrice = ?, discount = ?,\r\n                              total = ?, advance = ?, balance = ?, specialNote = ?, netTotal=?\r\n            WHERE OrID = ?`;\r\n        await db.query(orderUpdateQuery, [\r\n            customerId, orderStatus, payStatus, deliveryStatus, deliveryCharge, discount, totalPrice,\r\n            advance, balance, specialNote,netTotal, orderId\r\n        ]);\r\n        // return res.status(200).json({ success: true, message: \"Order details updated successfully\" });\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order updated successfully\",\r\n            data: {\r\n                orderId: orderId,\r\n                orderDate: orderDate,\r\n                expectedDeliveryDate: expectedDeliveryDate,\r\n            },\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order data:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating data in database\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\nrouter.put(\"/update-order-items\", async (req, res) => {\r\n    try {\r\n        const { orderId, orderStatus, items } = req.body;\r\n\r\n        if (!items || items.length === 0) {\r\n            return res.status(400).json({ success: false, message: \"No items provided.\" });\r\n        }\r\n\r\n        const [existingRecords] = await db.query(\r\n            `SELECT I_Id FROM Order_Detail WHERE orID = ?`,\r\n            [orderId]\r\n        );\r\n        const existingItemIds = existingRecords.map(item => item.I_Id);\r\n        const newItemIds = items.map(item => item.itemId);\r\n\r\n        const itemsToRemove = existingItemIds.filter(id => !newItemIds.includes(id));\r\n\r\n        for (const itemId of itemsToRemove) {\r\n            await db.query(`DELETE FROM Order_Detail WHERE orID = ? AND I_Id = ?`, [orderId, itemId]);\r\n            await db.query(`DELETE FROM accept_orders WHERE orID = ? AND I_Id = ?`, [orderId, itemId]);\r\n        }\r\n\r\n        for (const item of items) {\r\n            const { itemId, quantity, amount, originalQuantity, originalAmount } = item;\r\n            const safePrice = amount !== undefined && amount !== null ? amount : 0;\r\n\r\n            const [orderDetailRecord] = await db.query(\r\n                `SELECT * FROM Order_Detail WHERE orID = ? AND I_Id = ?`,\r\n                [orderId, itemId]\r\n            );\r\n\r\n            if (orderDetailRecord.length > 0) {\r\n                const existingItem = orderDetailRecord[0];\r\n\r\n                // Only update qty and tprice if quantity or amount has changed\r\n                if (quantity !== existingItem.qty || safePrice !== existingItem.tprice) {\r\n                    await db.query(\r\n                        `UPDATE Order_Detail SET qty = ?, tprice = ? WHERE orID = ? AND I_Id = ?`,\r\n                        [quantity, safePrice, orderId, itemId]\r\n                    );\r\n                }\r\n            } else {\r\n                await db.query(\r\n                    `INSERT INTO Order_Detail (orID, I_Id, qty, tprice) VALUES (?, ?, ?, ?)`,\r\n                    [orderId, itemId, quantity, safePrice]\r\n                );\r\n            }\r\n        }\r\n\r\n        const isAnyItemBooked = items.some(item => item.booked);\r\n        if (isAnyItemBooked && orderStatus !== \"Accepted\") {\r\n            return res.status(400).json({ success: false, message: \"Order status must be 'Accepted' if any item is booked.\" });\r\n        }\r\n\r\n        // Now booking / unbooking logic\r\n        for (const item of items) {\r\n            const { itemId, quantity, booked } = item;\r\n            const itemReceived = booked ? \"Yes\" : \"No\";\r\n            const itemStatus = booked ? \"Complete\" : \"Incomplete\";\r\n\r\n            const [acceptRecord] = await db.query(\r\n                `SELECT * FROM accept_orders WHERE orID = ? AND I_Id = ?`,\r\n                [orderId, itemId]\r\n            );\r\n\r\n            if (acceptRecord.length > 0) {\r\n                await db.query(\r\n                    `UPDATE accept_orders SET itemReceived = ?, status = ? WHERE orID = ? AND I_Id = ?`,\r\n                    [itemReceived, itemStatus, orderId, itemId]\r\n                );\r\n            } else {\r\n                await db.query(\r\n                    `INSERT INTO accept_orders (orID, I_Id, itemReceived, status) VALUES (?, ?, ?, ?)`,\r\n                    [orderId, itemId, itemReceived, itemStatus]\r\n                );\r\n            }\r\n\r\n            if (booked) {\r\n                const [bookedItem] = await db.query(\r\n                    `SELECT * FROM booked_item WHERE orID = ? AND I_Id = ?`,\r\n                    [orderId, itemId]\r\n                );\r\n\r\n                if (bookedItem.length === 0) {\r\n                    await db.query(\r\n                        `INSERT INTO booked_item (orID, I_Id, qty) VALUES (?, ?, ?)`,\r\n                        [orderId, itemId, quantity]\r\n                    );\r\n                    await db.query(\r\n                        `UPDATE Item SET bookedQty = bookedQty + ?, availableQty = availableQty - ? WHERE I_Id = ?`,\r\n                        [quantity, quantity, itemId]\r\n                    );\r\n                }\r\n            } else {\r\n                await db.query(\r\n                    `DELETE FROM booked_item WHERE orID = ? AND I_Id = ?`,\r\n                    [orderId, itemId]\r\n                );\r\n                const [bookedCheck] = await db.query(\r\n                    `SELECT * FROM Item WHERE I_Id = ? AND bookedQty >= ?`,\r\n                    [itemId, quantity]\r\n                );\r\n\r\n                if (bookedCheck.length > 0) {\r\n                    await db.query(\r\n                        `UPDATE Item SET bookedQty = bookedQty - ?, availableQty = availableQty + ? WHERE I_Id = ?`,\r\n                        [quantity, quantity, itemId]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Order items updated successfully.\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order items:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Database update failed.\", details: error.message });\r\n    }\r\n});\r\nrouter.put(\"/update-delivery\", async (req, res) => {\r\n    try {\r\n        const { orderId, deliveryStatus, phoneNumber, deliveryInfo } = req.body;\r\n\r\n        if (!orderId || !deliveryStatus) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        if (deliveryStatus === \"Delivery\" && deliveryInfo) {\r\n            // Check if a delivery record already exists\r\n            const checkDeliveryQuery = `SELECT * FROM delivery WHERE orID = ?`;\r\n            const [existingDelivery] = await db.query(checkDeliveryQuery, [orderId]);\r\n\r\n            if (existingDelivery.length > 0) {\r\n                // Update existing delivery record\r\n                const deliveryUpdateQuery = `UPDATE delivery SET address = ?, district = ?, contact = ?, schedule_Date = ? WHERE orID = ?`;\r\n                await db.query(deliveryUpdateQuery, [deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate, orderId]);\r\n            } else {\r\n                // Insert new delivery record\r\n                const insertDeliveryQuery = `INSERT INTO delivery (orID, address, district, contact, schedule_Date) VALUES (?, ?, ?, ?, ?)`;\r\n                await db.query(insertDeliveryQuery, [orderId, deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate]);\r\n            }\r\n        }\r\n\r\n        if (deliveryStatus === \"Pick Up\") {\r\n            // Remove any existing delivery record\r\n            const deleteDeliveryQuery = `DELETE FROM delivery WHERE orID = ?`;\r\n            await db.query(deleteDeliveryQuery, [orderId]);\r\n\r\n            // Update the delivery price to 0 in orders\r\n            const updateDeliveryQuery = `UPDATE orders SET dvPrice = 0 WHERE orID = ?`;\r\n            await db.query(updateDeliveryQuery, [orderId]);\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Delivery information updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating delivery information:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Database update failed\", details: error.message });\r\n    }\r\n});\r\n\r\n//Get All sale team members\r\nrouter.get(\"/salesteam\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all sales team members with their details\r\n        const [salesTeam] = await db.query(`\r\n            SELECT\r\n                st.stID,\r\n                st.orderTarget,\r\n                st.issuedTarget,\r\n                st.totalOrder,\r\n                st.totalIssued,\r\n                e.E_Id,\r\n                e.name AS employeeName,\r\n                e.address,\r\n                e.nic,\r\n                e.dob,\r\n                e.contact,\r\n                e.job,\r\n                e.basic\r\n            FROM sales_team st\r\n                     JOIN Employee e ON st.E_Id = e.E_Id;\r\n        `);\r\n\r\n        // If no sales team members found, return a 404 status\r\n        if (salesTeam.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team members found\" });\r\n        }\r\n\r\n        // Query to fetch coupons for each sales team member\r\n        const [coupons] = await db.query(`\r\n            SELECT\r\n                sc.cpID,\r\n                sc.stID,\r\n                sc.discount\r\n            FROM sales_coupon sc;\r\n        `);\r\n\r\n        // Group coupons by stID\r\n        const couponMap = {};\r\n        coupons.forEach(coupon => {\r\n            if (!couponMap[coupon.stID]) {\r\n                couponMap[coupon.stID] = [];\r\n            }\r\n            couponMap[coupon.stID].push({\r\n                cpID: coupon.cpID,\r\n                discount: coupon.discount\r\n            });\r\n        });\r\n\r\n        // Format the response data\r\n        const formattedSalesTeam = salesTeam.map(member => ({\r\n            stID: member.stID,\r\n            E_Id: member.E_Id,\r\n            employeeName: member.employeeName,\r\n            address: member.address,\r\n            nic: member.nic,\r\n            dob: member.dob,\r\n            contact: member.contact,\r\n            job: member.job,\r\n            basic: member.basic,\r\n            orderTarget: member.orderTarget,\r\n            issuedTarget: member.issuedTarget,\r\n            totalOrder: member.totalOrder,\r\n            totalIssued: member.totalIssued,\r\n            coupons: couponMap[member.stID] || [] // Attach coupons or empty array if none exist\r\n        }));\r\n\r\n        // Send the formatted data as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Sales team members and their coupons retrieved successfully.\",\r\n            data: formattedSalesTeam\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching sales team members and coupons:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching sales team members and coupons\" });\r\n    }\r\n});\r\n\r\n//Get All driver members\r\nrouter.get(\"/drivers\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all drivers and their related employee details\r\n        const [drivers] = await db.query(`\r\n            SELECT\r\n                d.devID,d.balance,e.E_Id,\r\n                e.name AS employeeName,e.address,\r\n                e.nic,e.dob,e.contact,e.job,e.basic\r\n            FROM driver d\r\n                     JOIN Employee e ON d.E_ID = e.E_Id;\r\n        `);\r\n\r\n        // If no drivers are found, return a 404 status\r\n        if (drivers.length === 0) {\r\n            return res.status(404).json({ message: \"No drivers found\" });\r\n        }\r\n\r\n        // Format the response data\r\n        const formattedDrivers = drivers.map(driver => ({\r\n            devID: driver.devID,\r\n            E_Id: driver.E_Id,\r\n            employeeName: driver.employeeName,\r\n            address: driver.address,\r\n            nic: driver.nic,\r\n            dob: driver.dob,\r\n            contact: driver.contact,\r\n            job: driver.job,\r\n            basic: driver.basic,\r\n            balance: driver.balance\r\n        }));\r\n\r\n        // Send the formatted data as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Drivers found.\",\r\n            data: formattedDrivers\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching drivers:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching drivers\" });\r\n    }\r\n});\r\n\r\n// Get All other employee\r\nrouter.get(\"/grouped-employees\", async (req, res) => {\r\n    try {\r\n        // Get employees with job IN ('It', 'HR', 'Admin')\r\n        const [rows] = await db.query(\r\n            \"SELECT * FROM Employee WHERE job IN ('It', 'HR', 'Admin')\"\r\n        );\r\n\r\n        // Return all employees in a single array\r\n        return res.status(200).json({\r\n            success: true,\r\n            employees: rows // Send all employees regardless of their job type\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching grouped employees:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get orders for a specific sales team member (stID)\r\nrouter.get(\"/orders/by-sales-team\", async (req, res) => {\r\n    try {\r\n        const { stID } = req.query;\r\n\r\n        // Fetch sales team details\r\n        const [results] = await db.query(`\r\n            SELECT\r\n                e.E_Id AS employeeId,\r\n                e.name AS employeeName,\r\n                e.contact AS employeeContact,\r\n                e.nic AS employeeNic,\r\n                e.dob AS employeeDob,\r\n                e.address AS employeeAddress,\r\n                e.job AS employeeJob,\r\n                e.basic AS employeeBasic,\r\n                st.stID,\r\n                st.orderTarget,\r\n                st.issuedTarget,\r\n                st.totalOrder,\r\n                st.totalIssued,\r\n                COUNT(o.OrID) AS totalCount,\r\n                SUM(CASE WHEN o.orStatus = 'Issued' THEN 1 ELSE 0 END) AS issuedCount,\r\n                COALESCE(SUM(o.netTotal - o.discount), 0) AS totalOrderValue,\r\n                COALESCE(SUM(CASE WHEN o.orStatus = 'Issued' THEN o.netTotal - o.discount ELSE 0 END), 0) AS issuedOrderValue\r\n            FROM sales_team st\r\n            JOIN Employee e ON e.E_Id = st.E_Id\r\n            LEFT JOIN Orders o ON o.stID = st.stID\r\n            WHERE st.stID = ?\r\n            GROUP BY st.stID, e.E_Id, e.name, e.contact, e.nic, e.dob, e.address, e.job, e.basic,\r\n                     st.orderTarget, st.issuedTarget, st.totalOrder, st.totalIssued;\r\n        `, [stID]);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ message: \"No data found for this sales team member.\" });\r\n        }\r\n\r\n        const memberDetails = results[0];\r\n\r\n        // Get date ranges\r\n        const currentDate = new Date();\r\n        const currentYear = currentDate.getFullYear();\r\n        const currentMonth = currentDate.getMonth();\r\n        const firstDayOfCurrentMonth = new Date(currentYear, currentMonth, 1);\r\n        const firstDayOfLastMonth = new Date(currentYear, currentMonth - 1, 1);\r\n        const lastDayOfLastMonth = new Date(currentYear, currentMonth, 0);\r\n\r\n        // Fetch orders for the current month\r\n        const [ordersThisMonth] = await db.query(`\r\n            SELECT o.OrID AS orderId, o.orDate AS orderDate, o.netTotal - o.discount AS totalPrice, o.orStatus AS orderStatus\r\n            FROM Orders o\r\n            WHERE o.stID = ? AND o.orDate >= ? AND o.orDate <= ?\r\n        `, [stID, firstDayOfCurrentMonth, currentDate]);\r\n\r\n        // Fetch orders for the last month\r\n        const [ordersLastMonth] = await db.query(`\r\n            SELECT o.OrID AS orderId, o.orDate AS orderDate, o.netTotal - o.discount AS totalPrice, o.orStatus AS orderStatus\r\n            FROM Orders o\r\n            WHERE o.stID = ? AND o.orDate >= ? AND o.orDate <= ?\r\n        `, [stID, firstDayOfLastMonth, lastDayOfLastMonth]);\r\n\r\n        // Separate orders into Issued and Other types\r\n        const ordersThisMonthIssued = ordersThisMonth.filter(order => order.orderStatus === 'Issued');\r\n        const ordersThisMonthOther = ordersThisMonth.filter(order => order.orderStatus !== 'Issued');\r\n        const ordersLastMonthIssued = ordersLastMonth.filter(order => order.orderStatus === 'Issued');\r\n        const ordersLastMonthOther = ordersLastMonth.filter(order => order.orderStatus !== 'Issued');\r\n\r\n        // Fetch coupon separately for the sales team\r\n        const [coupons] = await db.query(`\r\n            SELECT sc.cpID AS couponId, sc.discount AS couponDiscount\r\n            FROM sales_coupon sc\r\n            WHERE sc.stID = ?;\r\n        `, [stID]);\r\n\r\n        // Fetch detailed advance records for the current month\r\n        const [advanceDetails] = await db.query(`\r\n            SELECT ad_ID AS advanceId, E_Id AS employeeId, amount, dateTime\r\n            FROM salary_advance\r\n            WHERE E_Id IN (SELECT E_Id FROM sales_team WHERE stID = ?)\r\n            AND MONTH(dateTime) = MONTH(CURDATE())\r\n            AND YEAR(dateTime) = YEAR(CURDATE());\r\n        `, [stID]);\r\n\r\n        // Calculate total advance amount\r\n        const totalAdvance = advanceDetails.reduce((sum, advance) => sum + advance.amount, 0);\r\n\r\n        return res.status(200).json({\r\n            message: \"Sales team details, orders for current and last month, coupons, and advance details fetched successfully.\",\r\n            data: {\r\n                memberDetails,\r\n                ordersThisMonthIssued: ordersThisMonthIssued.length > 0 ? ordersThisMonthIssued : [],\r\n                ordersThisMonthOther: ordersThisMonthOther.length > 0 ? ordersThisMonthOther : [],\r\n                ordersLastMonthIssued: ordersLastMonthIssued.length > 0 ? ordersLastMonthIssued : [],\r\n                ordersLastMonthOther: ordersLastMonthOther.length > 0 ? ordersLastMonthOther : [],\r\n                coupons: coupons.length > 0 ? coupons : [], // Return all coupons, not just one\r\n                advanceDetails: advanceDetails.length > 0 ? advanceDetails : [], // Pass detailed advances\r\n                totalAdvance // Pass total advance amount\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching data:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching data.\" });\r\n    }\r\n});\r\n\r\n//Get in detail for a specific driver (devID)\r\nrouter.get(\"/drivers/details\", async (req, res) => {\r\n    try {\r\n        const { devID } = req.query;\r\n        if (!devID) return res.status(400).json({ message: \"Missing devID parameter.\" });\r\n\r\n        // 1. Driver and Employee Info (now includes license-related fields)\r\n        const driverQuery = `\r\n            SELECT d.devID, d.balance, d.dailyTarget, d.monthlyTarget, d.lincenseDate, d.lincense,\r\n                   e.E_Id, e.name, e.address, e.nic, e.dob, e.contact, e.job, e.basic\r\n            FROM driver d\r\n            INNER JOIN Employee e ON d.E_ID = e.E_Id\r\n            WHERE d.devID = ?;\r\n        `;\r\n        const [driverResults] = await db.execute(driverQuery, [devID]);\r\n        if (driverResults.length === 0) return res.status(404).json({ message: \"Driver not found.\" });\r\n\r\n        const employeeId = driverResults[0].E_Id;\r\n\r\n        // Convert license blob to base64 if available\r\n        let licenseBase64 = null;\r\n        if (driverResults[0].lincense) {\r\n            licenseBase64 = Buffer.from(driverResults[0].lincense).toString(\"base64\");\r\n        }\r\n\r\n        // 2. Delivery Charges\r\n        const chargeQuery = `\r\n            SELECT dv_id AS deliveryId, delivery_Date AS date, driverBalance AS amount\r\n            FROM delivery\r\n            WHERE devID = ? AND driverBalance > 0\r\n              AND (\r\n                (MONTH(delivery_Date) = MONTH(CURDATE()) AND YEAR(delivery_Date) = YEAR(CURDATE()))\r\n                OR (MONTH(delivery_Date) = MONTH(CURDATE() - INTERVAL 1 MONTH) AND YEAR(delivery_Date) = YEAR(CURDATE()))\r\n              );\r\n        `;\r\n        const [chargeDetails] = await db.execute(chargeQuery, [devID]);\r\n\r\n        const today = new Date().toDateString();\r\n        const thisMonth = new Date().getMonth() + 1;\r\n        const lastMonth = new Date().getMonth();\r\n\r\n        const dailyCharges = chargeDetails.filter(c => new Date(c.date).toDateString() === today);\r\n        const monthlyCharges = chargeDetails.filter(c => new Date(c.date).getMonth() + 1 === thisMonth);\r\n\r\n        const dailyChargeTotal = dailyCharges.reduce((sum, c) => sum + c.amount, 0);\r\n        const monthlyChargeTotal = monthlyCharges.reduce((sum, c) => sum + c.amount, 0);\r\n\r\n        // 3. Delivery Notes\r\n        const deliveryNoteQuery = `\r\n            SELECT delNoID, district, hire, MONTH(date) AS month, YEAR(date) AS year\r\n            FROM delivery_note\r\n            WHERE devID = ? AND status = 'complete'\r\n              AND (\r\n                (MONTH(date) = MONTH(CURDATE()) AND YEAR(date) = YEAR(CURDATE()))\r\n                OR (MONTH(date) = MONTH(CURDATE() - INTERVAL 1 MONTH) AND YEAR(date) = YEAR(CURDATE()))\r\n              );\r\n        `;\r\n        const [deliveryNotes] = await db.execute(deliveryNoteQuery, [devID]);\r\n\r\n        const thisMonthNotes = deliveryNotes.filter(note => note.month === thisMonth);\r\n        const lastMonthNotes = deliveryNotes.filter(note => note.month === lastMonth);\r\n\r\n        const thisMonthNoteHireTotal = thisMonthNotes.reduce((sum, n) => sum + n.hire, 0);\r\n        const lastMonthNoteHireTotal = lastMonthNotes.reduce((sum, n) => sum + n.hire, 0);\r\n\r\n        // 4. Other Hires\r\n        const hireQuery = `\r\n            SELECT id, date, hire, MONTH(date) AS month\r\n            FROM otherHire\r\n            WHERE driverId = ?\r\n              AND (\r\n                (MONTH(date) = MONTH(CURDATE()) AND YEAR(date) = YEAR(CURDATE()))\r\n                OR (MONTH(date) = MONTH(CURDATE() - INTERVAL 1 MONTH) AND YEAR(date) = YEAR(CURDATE()))\r\n              );\r\n        `;\r\n        const [hires] = await db.execute(hireQuery, [devID]);\r\n\r\n        const thisMonthHires = hires.filter(h => h.month === thisMonth);\r\n        const lastMonthHires = hires.filter(h => h.month === lastMonth);\r\n\r\n        const thisMonthHireTotal = thisMonthHires.reduce((sum, h) => sum + h.hire, 0);\r\n        const lastMonthHireTotal = lastMonthHires.reduce((sum, h) => sum + h.hire, 0);\r\n\r\n        // 5. Advances\r\n        const advanceQuery = `\r\n            SELECT ad_ID AS advanceId, amount, dateTime\r\n            FROM salary_advance\r\n            WHERE E_Id = ?\r\n              AND MONTH(dateTime) = MONTH(CURDATE())\r\n              AND YEAR(dateTime) = YEAR(CURDATE());\r\n        `;\r\n        const [advanceDetails] = await db.execute(advanceQuery, [employeeId]);\r\n        const totalAdvance = advanceDetails.reduce((sum, a) => sum + a.amount, 0);\r\n\r\n        // 6. Loan Info\r\n        const loanQuery = `SELECT * FROM salary_loan WHERE E_Id = ?`;\r\n        const [loanDetails] = await db.execute(loanQuery, [employeeId]);\r\n\r\n        const responseData = {\r\n            ...driverResults[0],\r\n            lincense: licenseBase64,\r\n            deliveryCharges: {\r\n                dailyChargeTotal,\r\n                dailyCharges,\r\n                monthlyChargeTotal,\r\n                monthlyCharges\r\n            },\r\n            deliveryNotes: {\r\n                thisMonth: thisMonthNotes,\r\n                lastMonth: lastMonthNotes,\r\n                thisMonthNoteHireTotal,\r\n                lastMonthNoteHireTotal\r\n            },\r\n            hires: {\r\n                thisMonth: thisMonthHires,\r\n                lastMonth: lastMonthHires,\r\n                thisMonthHireTotal,\r\n                lastMonthHireTotal\r\n            },\r\n            advanceDetails,\r\n            totalAdvance,\r\n            loans: loanDetails\r\n        };\r\n\r\n        return res.status(200).json({ success: true, data: responseData });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching driver details:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching driver details.\" });\r\n    }\r\n});\r\n\r\n// Get all categories\r\nrouter.get(\"/categories\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all categories\r\n        const [categories] = await db.query(\"SELECT * FROM Category\");\r\n\r\n        // If no categories found, return a 404 status\r\n        if (categories.length === 0) {\r\n            return res.status(404).json({ message: \"No categories found\" });\r\n        }\r\n\r\n        // Map through categories to format the response\r\n        const formattedCategories = categories.map(category => ({\r\n            id: category.Ca_Id,  // Assuming you have a Ca_Id column for the category ID\r\n            name: category.name   // Assuming you have a name column for the category name\r\n        }));\r\n\r\n        // Send the formatted categories as a JSON response\r\n        return res.status(200).json(formattedCategories);\r\n    } catch (error) {\r\n        console.error(\"Error fetching categories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching categories\" });\r\n    }\r\n});\r\n\r\n//API to Get All Sub Categories (sub_one and sub_two) by Category ID (Ca_Id):\r\nrouter.get(\"/subcategories\", async (req, res) => {\r\n    try {\r\n        const { Ca_Id } = req.query;\r\n\r\n        if (!Ca_Id) {\r\n            return res.status(400).json({ message: \"Category ID is required.\" });\r\n        }\r\n\r\n        // Fetch subCat_one and related subCat_two details for the given Ca_Id\r\n        const [subCategories] = await db.query(`\r\n            SELECT\r\n                s1.sb_c_id AS subCatOneId,\r\n                s1.subcategory AS subCatOneName,\r\n                s1.img AS subCatOneImg,\r\n                s2.sb_cc_id AS subCatTwoId,\r\n                s2.subcategory AS subCatTwoName,\r\n                s2.img AS subCatTwoImg\r\n            FROM subCat_one s1\r\n                     LEFT JOIN subCat_two s2 ON s1.sb_c_id = s2.sb_c_id\r\n            WHERE s1.Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({ message: \"No subcategories found for this category.\" });\r\n        }\r\n\r\n        // Group subCat_two under corresponding subCat_one and set \"None\" if empty\r\n        const groupedData = subCategories.reduce((acc, curr) => {\r\n            const existingSubCatOne = acc.find(item => item.subCatOneId === curr.subCatOneId);\r\n\r\n            const subCatTwoItem = curr.subCatTwoId\r\n                ? {\r\n                    subCatTwoId: curr.subCatTwoId,\r\n                    subCatTwoName: curr.subCatTwoName,\r\n                    subCatTwoImg: curr.subCatTwoImg\r\n                }\r\n                : { subCatTwoId: \"None\", subCatTwoName: \"None\", subCatTwoImg: null };\r\n\r\n            if (existingSubCatOne) {\r\n                if (!existingSubCatOne.subCatTwo.some(item => item.subCatTwoId === subCatTwoItem.subCatTwoId)) {\r\n                    existingSubCatOne.subCatTwo.push(subCatTwoItem);\r\n                }\r\n            } else {\r\n                acc.push({\r\n                    subCatOneId: curr.subCatOneId,\r\n                    subCatOneName: curr.subCatOneName,\r\n                    subCatOneImg: curr.subCatOneImg,\r\n                    subCatTwo: [subCatTwoItem]\r\n                });\r\n            }\r\n\r\n            return acc;\r\n        }, []);\r\n\r\n        return res.status(200).json({\r\n            message: \"Subcategories fetched successfully.\",\r\n            data: groupedData\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching subcategories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching subcategories.\" });\r\n    }\r\n});\r\n\r\n// find subcat one and two data by category name\r\nrouter.get(\"/SubCatNames\", async (req, res) => {\r\n    try {\r\n        const { categoryName } = req.query;\r\n\r\n        if (!categoryName) {\r\n            return res.status(400).json({ message: \"Category name is required.\" });\r\n        }\r\n\r\n        // Fetch the Ca_Id based on the category name\r\n        const [categoryResult] = await db.query(`\r\n            SELECT Ca_Id FROM Category WHERE name = ?;\r\n        `, [categoryName]);\r\n\r\n        if (categoryResult.length === 0) {\r\n            return res.status(404).json({ message: \"Category not found.\" });\r\n        }\r\n\r\n        const Ca_Id = categoryResult[0].Ca_Id;\r\n\r\n        // Fetch subCat_one and related subCat_two details for the given Ca_Id\r\n        const [subCategories] = await db.query(`\r\n            SELECT\r\n                s1.sb_c_id AS subCatOneId,\r\n                s1.subcategory AS subCatOneName,\r\n                s1.img AS subCatOneImg,\r\n                s2.sb_cc_id AS subCatTwoId,\r\n                s2.subcategory AS subCatTwoName,\r\n                s2.img AS subCatTwoImg\r\n            FROM subCat_one s1\r\n                     LEFT JOIN subCat_two s2 ON s1.sb_c_id = s2.sb_c_id\r\n            WHERE s1.Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({ message: \"No subcategories found for this category.\" });\r\n        }\r\n\r\n        // Group subCat_two under corresponding subCat_one and set \"None\" if empty\r\n        const groupedData = subCategories.reduce((acc, curr) => {\r\n            const existingSubCatOne = acc.find(item => item.subCatOneId === curr.subCatOneId);\r\n\r\n            const subCatTwoItem = curr.subCatTwoId\r\n                ? {\r\n                    subCatTwoId: curr.subCatTwoId,\r\n                    subCatTwoName: curr.subCatTwoName,\r\n                    subCatTwoImg: curr.subCatTwoImg\r\n                }\r\n                : { subCatTwoId: \"None\", subCatTwoName: \"None\", subCatTwoImg: null };\r\n\r\n            if (existingSubCatOne) {\r\n                if (!existingSubCatOne.subCatTwo.some(item => item.subCatTwoId === subCatTwoItem.subCatTwoId)) {\r\n                    existingSubCatOne.subCatTwo.push(subCatTwoItem);\r\n                }\r\n            } else {\r\n                acc.push({\r\n                    subCatOneId: curr.subCatOneId,\r\n                    subCatOneName: curr.subCatOneName,\r\n                    subCatOneImg: curr.subCatOneImg,\r\n                    subCatTwo: [subCatTwoItem]\r\n                });\r\n            }\r\n\r\n            return acc;\r\n        }, []);\r\n\r\n        return res.status(200).json({\r\n            message: \"Subcategories fetched successfully.\",\r\n            data: groupedData\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching subcategories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching subcategories.\" });\r\n    }\r\n});\r\n\r\n// API endpoint to save item-supplier association\r\nrouter.post('/add-item-supplier', async (req, res) => {\r\n    const { I_Id, s_ID ,cost } = req.body;\r\n\r\n    // Check if I_Id and s_ID are provided\r\n    if (!I_Id || !s_ID ) {\r\n        return res.status(400).json({ success: false, message: 'Item ID and Supplier ID are required' });\r\n    }\r\n\r\n    try {\r\n        // Step 1: Check if the Item ID exists in the Item table\r\n        const [itemExists] = await db.query('SELECT * FROM Item WHERE I_Id = ?', [I_Id]);\r\n        if (itemExists.length === 0) {\r\n            return res.status(404).json({ success: false, message: 'Item not found' });\r\n        }\r\n\r\n        // Step 2: Check if the Supplier ID exists in the Supplier table\r\n        const [supplierExists] = await db.query('SELECT * FROM Supplier WHERE s_ID = ?', [s_ID]);\r\n        if (supplierExists.length === 0) {\r\n            return res.status(404).json({ success: false, message: 'Supplier not found' });\r\n        }\r\n\r\n        // Step 3: Insert the item-supplier relationship into the item_supplier table\r\n        const insertQuery = 'INSERT INTO item_supplier (I_Id, s_ID,unit_cost) VALUES (?, ?,?)';\r\n        const [result] = await db.query(insertQuery, [I_Id, s_ID,cost]);\r\n\r\n        // Step 4: Return success response\r\n        return res.status(200).json({ success: true, message: 'Item-Supplier relationship added successfully', data: result });\r\n    } catch (error) {\r\n        console.error('Error adding item-supplier:', error.message);\r\n        return res.status(500).json({ success: false, message: 'Server error', error: error.message });\r\n    }\r\n});\r\n\r\n// Route for adding stock with barcode generation\r\nrouter.post(\"/add-stock-received\", upload.single(\"image\"), async (req, res) => {\r\n    try {\r\n        const { supplierId, itemId, date, cost, stockCount, comment } = req.body;\r\n        const imageFile = req.file;\r\n\r\n        // Validate required fields\r\n        if (!supplierId || !itemId || !date || !stockCount) {\r\n            return res.status(400).json({ success: false, message: \"All fields are required!\" });\r\n        }\r\n\r\n        // Validate item existence\r\n        const [itemExists] = await db.query(\"SELECT I_Id FROM Item WHERE I_Id = ?\", [itemId]);\r\n        if (itemExists.length === 0) {\r\n            return res.status(400).json({ success: false, message: \"Invalid Item ID\" });\r\n        }\r\n\r\n        // Handle image upload\r\n        let imagePath = null;\r\n        if (imageFile) {\r\n            const imageName = `item_${itemId}_${Date.now()}.${imageFile.mimetype.split(\"/\")[1]}`;\r\n            const savePath = path.join(\"./uploads/images\", imageName);\r\n            fs.writeFileSync(savePath, imageFile.buffer);\r\n            imagePath = `/uploads/images/${imageName}`;\r\n        }\r\n\r\n        // Insert into `main_stock_received`\r\n        const insertQuery = `\r\n            INSERT INTO main_stock_received (s_ID, I_Id, rDate, rec_count, unitPrice, detail, payment)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?)`;\r\n        const [result] = await db.query(insertQuery, [\r\n            supplierId,\r\n            itemId,\r\n            date,\r\n            stockCount,\r\n            cost,\r\n            comment || \"\",\r\n            \"NotPaid\",\r\n        ]);\r\n        const receivedStockId = result.insertId;\r\n\r\n        // Update Item table stock\r\n        await db.query(\r\n            `UPDATE Item SET stockQty = stockQty + ?, availableQty = availableQty + ? WHERE I_Id = ?`,\r\n            [stockCount, stockCount, itemId]\r\n        );\r\n\r\n        // Get last `stock_Id`\r\n        const [lastStockResult] = await db.query(\r\n            `SELECT MAX(stock_Id) AS lastStockId FROM p_i_detail WHERE I_Id = ?`,\r\n            [itemId]\r\n        );\r\n        let lastStockId = lastStockResult[0]?.lastStockId || 0;\r\n\r\n        const insertDetailQuery = `\r\n            INSERT INTO p_i_detail (I_Id, stock_Id, pi_ID, barcode, status, orID, datetime)\r\n            VALUES (?, ?, ?, ?, 'Available', ?, NOW())`;\r\n\r\n        // Ensure barcodes folder exists\r\n        const barcodeFolderPath = path.join(\"./uploads/barcodes\");\r\n        if (!fs.existsSync(barcodeFolderPath)) {\r\n            fs.mkdirSync(barcodeFolderPath, { recursive: true });\r\n        }\r\n\r\n        for (let i = 1; i <= stockCount; i++) {\r\n            lastStockId++;\r\n\r\n            // Create barcode data\r\n            const barcodeData = `${itemId}-${lastStockId}-${receivedStockId}`;\r\n            const barcodeImageName = `barcode_${barcodeData}.png`;\r\n            const barcodeImagePath = path.join(barcodeFolderPath, barcodeImageName);\r\n\r\n            // Generate barcode image\r\n            const pngBuffer = await bwipjs.toBuffer({\r\n                bcid: \"code128\",\r\n                text: barcodeData,\r\n                scale: 3,\r\n                height: 10,\r\n                includetext: true,\r\n                textxalign: \"center\",\r\n            });\r\n\r\n            // Save barcode image to folder\r\n            fs.writeFileSync(barcodeImagePath, pngBuffer);\r\n\r\n            // Save barcode details in the database\r\n            await db.query(insertDetailQuery, [itemId, lastStockId, receivedStockId, barcodeData, \"\"]);\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Stock received successfully, image uploaded, and barcodes saved!\",\r\n            stockReceivedId: receivedStockId,\r\n            imagePath,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error adding stock received:\", error);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// add purchase note and add stock- Generate barcodes for each stock\r\nrouter.post(\"/addStock\", upload.single(\"image\"), async (req, res) => {\r\n    try {\r\n        const { purchase_id, supplier_id, date, itemTotal, delivery, invoice, items } = req.body;\r\n        console.log(req.body);\r\n        const imageFile = req.file;\r\n\r\n        const total = Number(itemTotal) || 0;\r\n        const deliveryPrice = Number(delivery) || 0;\r\n\r\n        if (!supplier_id || !itemTotal || !date || !purchase_id || !items) {\r\n            return res.status(400).json({ success: false, message: \"All fields are required!\" });\r\n        }\r\n\r\n        let imagePath = null;\r\n        if (imageFile) {\r\n            const imageName = `item_${purchase_id}_${Date.now()}.${imageFile.mimetype.split(\"/\")[1]}`;\r\n            const savePath = path.join(\"./uploads/images\", imageName);\r\n            fs.writeFileSync(savePath, imageFile.buffer);\r\n            imagePath = `/uploads/images/${imageName}`;\r\n        }\r\n        const formattedDate = moment(date, ['D/M/YYYY', 'M/D/YYYY']).format('YYYY-MM-DD');\r\n        const insertQuery = `\r\n            INSERT INTO purchase (pc_Id, s_ID, rDate, total, pay, balance, deliveryCharge, invoiceId)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;\r\n        await db.query(insertQuery, [purchase_id, supplier_id, formattedDate, total, 0, total, deliveryPrice, invoice]);\r\n\r\n        const stockCount = items.length;\r\n        const stockDetails = [];\r\n\r\n        for (let i = 0; i < stockCount; i++) {\r\n            const { I_Id, unit_price, quantity,material,price } = items[i];\r\n            const totalPrice = parseFloat(unit_price) * Number(quantity);\r\n\r\n            const checkUnitPriceQuery = `SELECT unit_cost FROM item_supplier WHERE I_Id = ? AND s_ID = ?`;\r\n            const [unitPriceResult] = await db.query(checkUnitPriceQuery, [I_Id, supplier_id]);\r\n\r\n            if (unitPriceResult.length > 0) {\r\n                const existingUnitPrice = unitPriceResult[0].unit_cost;\r\n                if (parseFloat(existingUnitPrice) !== parseFloat(unit_price)) {\r\n                    const updateUnitPriceQuery = `\r\n                        UPDATE item_supplier\r\n                        SET unit_cost = ?\r\n                        WHERE I_Id = ? AND s_ID = ?`;\r\n                    await db.query(updateUnitPriceQuery, [unit_price, I_Id, supplier_id]);\r\n                }\r\n            } else {\r\n                const insertUnitPriceQuery = `\r\n                    INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n                    VALUES (?, ?, ?)`;\r\n                await db.query(insertUnitPriceQuery, [I_Id, supplier_id, unit_price]);\r\n            }\r\n\r\n            const purchaseDetailQuery = `\r\n                INSERT INTO purchase_detail (pc_Id, I_Id, rec_count, unitPrice, total, stock_range)\r\n                VALUES (?, ?, ?, ?, ?, ?)`;\r\n            await db.query(purchaseDetailQuery, [purchase_id, I_Id, quantity, unit_price, totalPrice, \"\"]);\r\n\r\n            stockDetails.push({ I_Id, quantity ,material,price});\r\n        }\r\n\r\n        const insertBarcodeQuery = `\r\n            INSERT INTO p_i_detail (pc_Id, I_Id, stock_Id, barcode_img, status, orID, datetime,material,price)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?,?,?)`;\r\n\r\n        const barcodeFolderPath = path.join(\"./uploads/barcodes\");\r\n        if (!fs.existsSync(barcodeFolderPath)) {\r\n            fs.mkdirSync(barcodeFolderPath, { recursive: true });\r\n        }\r\n\r\n        const stockRanges = [];\r\n\r\n        for (let i = 0; i < stockCount; i++) {\r\n            const { I_Id, quantity,material,price } = stockDetails[i];\r\n\r\n            const [lastStockResult] = await db.query(\r\n                `SELECT MAX(stock_Id) AS lastStockId FROM p_i_detail WHERE I_Id = ?`,\r\n                [I_Id]\r\n            );\r\n            let lastStockId = lastStockResult[0]?.lastStockId || 0;\r\n            let startStockId = lastStockId + 1;\r\n\r\n            for (let j = 1; j <= quantity; j++) {\r\n                lastStockId++;\r\n                const barcodeData = `${I_Id}-${lastStockId}`;\r\n                const barcodeImageName = `barcode_${barcodeData}.png`;\r\n                const barcodeImagePath = path.join(barcodeFolderPath, barcodeImageName);\r\n\r\n                const pngBuffer = await bwipjs.toBuffer({bcid: \"code128\", text: barcodeData, scale: 3, height: 10, includetext: true, textxalign: \"center\",});\r\n\r\n                fs.writeFileSync(barcodeImagePath, pngBuffer);\r\n\r\n                await db.query(insertBarcodeQuery, [purchase_id, I_Id, lastStockId, barcodeImagePath, \"Available\", null,  mysql.raw('NOW()'),material,price]);\r\n\r\n            }\r\n\r\n            // ✅ Update stock only ONCE per item\r\n            await db.query(\r\n                `UPDATE Item SET stockQty = stockQty + ?, availableQty = availableQty + ? WHERE I_Id = ?`,\r\n                [quantity, quantity, I_Id]\r\n            );\r\n\r\n            const stockRange = `${startStockId}-${lastStockId}`;\r\n            stockRanges.push({ I_Id, stockRange });\r\n        }\r\n\r\n        for (let { I_Id, stockRange } of stockRanges) {\r\n            const updateStockRangeQuery = `\r\n                UPDATE purchase_detail\r\n                SET stock_range = ?\r\n                WHERE pc_Id = ? AND I_Id = ?`;\r\n            await db.query(updateStockRangeQuery, [stockRange, purchase_id, I_Id]);\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Stock received successfully, image uploaded, and barcodes saved!\",\r\n            imagePath,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error adding stock received:\", error);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Find cost by sid and iid\r\nrouter.get(\"/find-cost\", async (req, res) => {\r\n    try {\r\n        const { s_ID , I_Id } = req.query;\r\n\r\n        if (!s_ID || !I_Id ) {\r\n            return res.status(400).json({ message: \"Item ID, Supplier Id are required.\" });\r\n        }\r\n\r\n        // Query the database to fetch the type for the given Ca_Id, sub_one, and sub_two\r\n        const [cost] = await db.query(`\r\n            SELECT unit_cost\r\n            FROM item_supplier\r\n            WHERE s_ID = ? AND I_Id = ? ;\r\n        `, [s_ID,I_Id]);\r\n\r\n        // If no type found for this combination, return a 404 status\r\n        if (cost.length === 0) {\r\n            return res.status(404).json({ message: \"No cost found.\" });\r\n        }\r\n\r\n        // Send the type as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Cost found.\",\r\n            cost: cost[0],  // Return only the first matching cost\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching cost:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching cost\" });\r\n    }\r\n});\r\n\r\n// Find subcategory by Ca_Id\r\nrouter.get(\"/find-subcategory\", async (req, res) => {\r\n    try {\r\n        const { Ca_Id } = req.query;\r\n\r\n        // Validate query parameter\r\n        if (!Ca_Id) {\r\n            return res.status(400).json({ message: \"Ca_Id is required.\" });\r\n        }\r\n\r\n        // Query the database\r\n        const [subcategories] = await db.query(`\r\n            SELECT sb_c_id, subcategory \r\n            FROM subCat_one \r\n            WHERE Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        // If no subcategories found, return a 404 response\r\n        if (subcategories.length === 0) {\r\n            return res.status(404).json({ message: \"No subcategories found for this Ca_Id.\" });\r\n        }\r\n\r\n        // Return the result\r\n        return res.status(200).json({\r\n            message: \"Subcategories found.\",\r\n            data: subcategories,  // Returns an array of subcategories\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching subcategories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching subcategories\" });\r\n    }\r\n});\r\n\r\n//Find issuded orders by district & date\r\nrouter.get(\"/find-completed-orders\", async (req, res) => {\r\n    try {\r\n        const { district, date } = req.query;\r\n\r\n        if (!district) {\r\n            return res.status(400).json({ success: false, message: \"District is required.\" });\r\n        }\r\n\r\n        if (!date) {\r\n            return res.status(400).json({ success: false, message: \"Date is required.\" });\r\n        }\r\n\r\n        // Parse the date in DD/MM/YYYY format and convert it to YYYY-MM-DD format\r\n        const parsedDate = parseDate(date);\r\n\r\n        // 1\uFE0F⃣ Fetch Completed Orders with Sales Team & Customer Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.orId, o.orDate, o.c_ID, o.orStatus, o.delStatus, o.delPrice, o.discount,\r\n                o.total, o.ordertype, o.stID, o.expectedDate, o.specialNote, o.advance, o.balance,\r\n                o.payStatus, d.address, d.district, d.schedule_Date, d.type,\r\n                s.stID, e.name AS salesEmployeeName,\r\n                c.FtName, c.SrName, c.contact1, c.contact2\r\n            FROM Orders o\r\n                     JOIN delivery d ON o.orID = d.orID\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n                     LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE d.district = ? AND o.orStatus = 'Completed' AND o.expectedDate = ?;\r\n        `;\r\n\r\n        const [orders] = await db.query(orderQuery, [district, parsedDate]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No completed orders found for this district and date.\" });\r\n        }\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items for Each Order\r\n        const orderDetails = await Promise.all(orders.map(async (order) => {\r\n            const itemsQuery = `\r\n                SELECT\r\n                    od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                    i.bookedQty, i.availableQty\r\n                FROM Order_Detail od\r\n                         JOIN Item i ON od.I_Id = i.I_Id\r\n                WHERE od.orID = ?`;\r\n\r\n            const [items] = await db.query(itemsQuery, [order.orId]);\r\n\r\n            // 3\uFE0F⃣ Fetch Booked Items for Each Order\r\n            const bookedItemsQuery = `\r\n                SELECT bi.I_Id, i.I_name, bi.qty\r\n                FROM booked_item bi\r\n                         JOIN Item i ON bi.I_Id = i.I_Id\r\n                WHERE bi.orID = ?`;\r\n\r\n            const [bookedItems] = await db.query(bookedItemsQuery, [order.orId]);\r\n\r\n            // 4\uFE0F⃣ Fetch Accepted Items\r\n            const acceptedOrdersQuery = `\r\n                SELECT ao.I_Id, i.I_name, ao.itemReceived, ao.status\r\n                FROM accept_orders ao\r\n                         JOIN Item i ON ao.I_Id = i.I_Id\r\n                WHERE ao.orID = ?`;\r\n\r\n            const [acceptedOrders] = await db.query(acceptedOrdersQuery, [order.orId]);\r\n\r\n            // 5\uFE0F⃣ Build the Response Object\r\n            return {\r\n                orderId: order.orId,\r\n                orderDate: formatDate(order.orDate),\r\n                expectedDeliveryDate: formatDate(order.expectedDate),\r\n                customerId: order.c_ID,\r\n                customerName: `${order.FtName} ${order.SrName}`,\r\n                phoneNumber: order.contact1,\r\n                optionalNumber: order.contact2,\r\n                orderStatus: order.orStatus,\r\n                deliveryStatus: order.delStatus,\r\n                totalPrice: order.total,\r\n                deliveryCharge : order.delPrice,\r\n                discount : order.discount,\r\n                advance: order.advance,\r\n                balance: order.balance,\r\n                payStatus: order.payStatus,\r\n                deliveryInfo: {\r\n                    address: order.address,\r\n                    district: order.district,\r\n                    scheduleDate: formatDate(order.schedule_Date),\r\n                    type : order.type,\r\n                },\r\n                items: items.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty,\r\n                    color: item.color,\r\n                    price: item.tprice,\r\n                    unitPrice: item.unitPrice,\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty,\r\n                })),\r\n                salesTeam: {\r\n                    stID: order.stID,\r\n                    employeeName: order.salesEmployeeName, // Sales team member's name\r\n                },\r\n                bookedItems: bookedItems.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty\r\n                })),\r\n                acceptedOrders: acceptedOrders.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    itemReceived: item.itemReceived,\r\n                    status: item.status\r\n                }))\r\n            };\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Completed orders fetched successfully.\",\r\n            orders: orderDetails\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching completed orders.\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Find Return Orders by district & date\r\nrouter.get(\"/find-returned-orders\", async (req, res) => {\r\n    try {\r\n        const { district, date } = req.query;\r\n\r\n        if (!district) {\r\n            return res.status(400).json({ success: false, message: \"District is required.\" });\r\n        }\r\n\r\n        if (!date) {\r\n            return res.status(400).json({ success: false, message: \"Date is required.\" });\r\n        }\r\n\r\n        // Parse date in YYYY-MM-DD format\r\n        const parsedDate = parseDate(date);\r\n\r\n        // Fetch Return Orders (Only Orders with Returned Items)\r\n        const orderQuery = `\r\n            SELECT\r\n                o.orId, o.orDate, o.c_ID, o.orStatus, o.delStatus, o.delPrice, o.discount,\r\n                o.total, o.ordertype, o.stID, o.expectedDate, o.specialNote, o.advance, o.balance,\r\n                o.payStatus, d.address, d.district, d.schedule_Date, d.type,\r\n                s.stID, e.name AS salesEmployeeName,\r\n                c.FtName, c.SrName, c.contact1, c.contact2\r\n            FROM Orders o\r\n            JOIN delivery d ON o.orID = d.orID\r\n            LEFT JOIN sales_team s ON o.stID = s.stID\r\n            LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE d.district = ? AND o.orStatus = 'Returned' AND o.expectedDate = ?;\r\n        `;\r\n\r\n        const [orders] = await db.query(orderQuery, [district, parsedDate]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No return orders found for this district and date.\" });\r\n        }\r\n\r\n        // Process return orders\r\n        const orderDetails = await Promise.all(orders.map(async (order) => {\r\n            // Fetch only return items from the issued_item table\r\n            const returnItemsQuery = `\r\n                SELECT ii.I_Id, i.I_name, ii.qty, i.color, ii.status\r\n                FROM issued_item ii\r\n                JOIN Item i ON ii.I_Id = i.I_Id\r\n                WHERE ii.orID = ? AND ii.status IN ('Reserved', 'Available');`;\r\n\r\n            const [returnItems] = await db.query(returnItemsQuery, [order.orId]);\r\n\r\n            return {\r\n                orderId: order.orId,\r\n                orderDate: formatDate(order.orDate),\r\n                expectedDeliveryDate: formatDate(order.expectedDate),\r\n                customerId: order.c_ID,\r\n                customerName: `${order.FtName} ${order.SrName}`,\r\n                phoneNumber: order.contact1,\r\n                optionalNumber: order.contact2,\r\n                orderStatus: order.orStatus,\r\n                deliveryStatus: order.delStatus,\r\n                totalPrice: order.total,\r\n                deliveryCharge: order.delPrice,\r\n                discount: order.discount,\r\n                advance: order.advance,\r\n                balance: order.balance,\r\n                payStatus: order.payStatus,\r\n                deliveryInfo: {\r\n                    address: order.address,\r\n                    district: order.district,\r\n                    scheduleDate: formatDate(order.schedule_Date),\r\n                    type: order.type,\r\n                },\r\n                salesTeam: {\r\n                    stID: order.stID,\r\n                    employeeName: order.salesEmployeeName,\r\n                },\r\n                returnItems: returnItems.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty,\r\n                    color: item.color,\r\n                    status: item.status, // Reserved or Available\r\n                }))\r\n            };\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Return orders fetched successfully.\",\r\n            orders: orderDetails\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching return orders:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching return orders.\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n//Find issuded orders by  date\r\nrouter.get(\"/find-completed-orders-by-date\", async (req, res) => {\r\n    try {\r\n        const { date } = req.query;\r\n        if (!date) {\r\n            return res.status(400).json({ success: false, message: \"Date is required.\" });\r\n        }\r\n\r\n        // Ensure date is valid\r\n        const parsedDate = parseDate(date);\r\n        if (!parsedDate) {\r\n            return res.status(400).json({ success: false, message: \"Invalid date format. Use DD/MM/YYYY or YYYY-MM-DD.\" });\r\n        }\r\n\r\n        // Fetch completed orders with delivery, sales team and customer info\r\n        const orderQuery = `\r\n            SELECT\r\n                o.orId, o.orDate, o.c_ID, o.orStatus, o.delStatus, o.delPrice, o.discount,\r\n                o.total, o.ordertype, o.stID, o.expectedDate, o.specialNote, o.advance, o.balance,\r\n                o.payStatus, d.address, d.district, d.type, d.status AS deliveryStatus, d.schedule_Date,\r\n                s.stID, e.name AS salesEmployeeName,\r\n                c.FtName, c.SrName, c.contact1, c.contact2\r\n            FROM Orders o\r\n            JOIN delivery d ON o.orID = d.orID\r\n            LEFT JOIN sales_team s ON o.stID = s.stID\r\n            LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Completed' AND o.expectedDate = ?;\r\n        `;\r\n\r\n        const [orders] = await db.query(orderQuery, [parsedDate]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No completed orders found for this date.\" });\r\n        }\r\n\r\n        const orderDetails = await Promise.all(orders.map(async (order) => {\r\n            // \uD83D\uDD25 Fetch items with tprice and discount now\r\n            const itemsQuery = `\r\n                SELECT \r\n                    od.I_Id, i.I_name, i.color, od.qty, od.tprice, od.discount AS itemDiscount,\r\n                    i.price AS unitPrice, i.bookedQty, i.availableQty\r\n                FROM Order_Detail od\r\n                JOIN Item i ON od.I_Id = i.I_Id\r\n                WHERE od.orID = ?\r\n            `;\r\n\r\n            const [items] = await db.query(itemsQuery, [order.orId]);\r\n\r\n            return {\r\n                orderId: order.orId,\r\n                orderDate: formatDate(order.orDate),\r\n                expectedDeliveryDate: formatDate(order.expectedDate),\r\n                customerId: order.c_ID,\r\n                customerName: `${order.FtName} ${order.SrName}`,\r\n                phoneNumber: order.contact1,\r\n                optionalNumber: order.contact2,\r\n                orderStatus: order.orStatus,\r\n                deliveryStatus: order.delStatus,\r\n                totalPrice: order.total,\r\n                deliveryCharge: order.delPrice,\r\n                discount: order.discount,\r\n                advance: order.advance,\r\n                balance: order.balance,\r\n                payStatus: order.payStatus,\r\n                deliveryInfo: {\r\n                    address: order.address,\r\n                    district: order.district,\r\n                    scheduleDate: formatDate(order.schedule_Date),\r\n                    type: order.type,\r\n                },\r\n                items: items.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty,\r\n                    color: item.color,\r\n                    price: item.tprice, // total price after discount\r\n                    unitPrice: item.unitPrice, // original unit price\r\n                    discount: item.itemDiscount || 0, // \uD83D\uDD25 added item discount\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty,\r\n                })),\r\n                salesTeam: {\r\n                    stID: order.stID,\r\n                    employeeName: order.salesEmployeeName,\r\n                },\r\n            };\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Completed orders fetched successfully.\",\r\n            orders: orderDetails,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching completed orders.\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Find Return orders by  date\r\nrouter.get(\"/find-returned-orders-by-date\", async (req, res) => {\r\n    try {\r\n        const { date } = req.query;\r\n        if (!date) {\r\n            return res.status(400).json({ success: false, message: \"Date is required.\" });\r\n        }\r\n\r\n        // Convert DD/MM/YYYY to YYYY-MM-DD\r\n        const parsedDate = parseDate(date);\r\n        if (!parsedDate) {\r\n            return res.status(400).json({ success: false, message: \"Invalid date format. Use DD/MM/YYYY or YYYY-MM-DD.\" });\r\n        }\r\n\r\n        // Fetch Return Orders (Only Orders with Returned Items)\r\n        const orderQuery = `\r\n            SELECT\r\n                o.orId, o.orDate, o.c_ID, o.orStatus, o.delStatus, o.delPrice, o.discount,\r\n                o.total, o.ordertype, o.stID, o.expectedDate, o.specialNote, o.advance, o.balance,\r\n                o.payStatus, d.address, d.district, d.type, d.status AS deliveryStatus, d.schedule_Date,\r\n                s.stID, e.name AS salesEmployeeName,\r\n                c.FtName, c.SrName, c.contact1, c.contact2\r\n            FROM Orders o\r\n            JOIN delivery d ON o.orID = d.orID\r\n            LEFT JOIN sales_team s ON o.stID = s.stID\r\n            LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Return' AND o.expectedDate = ?;\r\n        `;\r\n\r\n        const [orders] = await db.query(orderQuery, [parsedDate]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No return orders found for this date.\" });\r\n        }\r\n\r\n        // Process return orders\r\n        const orderDetails = await Promise.all(orders.map(async (order) => {\r\n            // Fetch only return items from the issued_item table\r\n            const returnItemsQuery = `\r\n                SELECT ii.I_Id, i.I_name, ii.qty, i.color, ii.status\r\n                FROM issued_item ii\r\n                JOIN Item i ON ii.I_Id = i.I_Id\r\n                WHERE ii.orID = ? AND ii.status IN ('Reserved', 'Available');`;\r\n\r\n            const [returnItems] = await db.query(returnItemsQuery, [order.orId]);\r\n\r\n            return {\r\n                orderId: order.orId,\r\n                orderDate: formatDate(order.orDate),\r\n                expectedDeliveryDate: formatDate(order.expectedDate),\r\n                customerId: order.c_ID,\r\n                customerName: `${order.FtName} ${order.SrName}`,\r\n                phoneNumber: order.contact1,\r\n                optionalNumber: order.contact2,\r\n                orderStatus: order.orStatus,\r\n                deliveryStatus: order.delStatus,\r\n                totalPrice: order.total,\r\n                deliveryCharge: order.delPrice,\r\n                discount: order.discount,\r\n                advance: order.advance,\r\n                balance: order.balance,\r\n                payStatus: order.payStatus,\r\n                deliveryInfo: {\r\n                    address: order.address,\r\n                    district: order.district,\r\n                    scheduleDate: formatDate(order.schedule_Date),\r\n                    type: order.type,\r\n                },\r\n                salesTeam: {\r\n                    stID: order.stID,\r\n                    employeeName: order.salesEmployeeName,\r\n                },\r\n                returnItems: returnItems.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty,\r\n                    color: item.color,\r\n                    status: item.status, // Reserved or Available\r\n                }))\r\n            };\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Return orders fetched successfully.\",\r\n            orders: orderDetails,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching return orders:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching return orders.\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get subcat one detail by ca_id\r\nrouter.get(\"/getSubcategories\", async (req, res) => {\r\n    const { Ca_Id } = req.query;\r\n    if (!Ca_Id) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Category ID (Ca_Id) is required\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Fetch subcategories under the given category ID\r\n        const sqlSubcategories = `SELECT sb_c_id, subcategory FROM subCat_one WHERE Ca_Id = ?`;\r\n        const [subCategories] = await db.query(sqlSubcategories, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No subcategories found for the given category ID\",\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Subcategories retrieved successfully\",\r\n            data: subCategories.map(subCat => ({\r\n                sb_c_id: subCat.sb_c_id,\r\n                subcategory: subCat.subcategory\r\n            })),\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching subcategories:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get subcat two detail by ca_id\r\nrouter.get(\"/getSubcategoriesTwo\", async (req, res) => {\r\n    const { sb_c_id } = req.query;\r\n\r\n    if (!sb_c_id) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Subcategory One ID (sb_c_id) is required\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Fetch subcategory two names under the given subcategory one ID\r\n        const sqlSubcategoriesTwo = `SELECT sb_cc_id, subcategory FROM subCat_two WHERE sb_c_id = ?\r\n        `;\r\n        const [subCategoriesTwo] = await db.query(sqlSubcategoriesTwo, [sb_c_id]);\r\n\r\n        if (subCategoriesTwo.length === 0) {\r\n            return res.status(200).json({\r\n                success: true,\r\n                message: \"No subcategories found\",\r\n                data: [{ sb_cc_id: \"None\", subcategory: \"None\" }],\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Subcategories retrieved successfully\",\r\n            data: subCategoriesTwo.map(subCat => ({\r\n                sb_cc_id: subCat.sb_cc_id,\r\n                subcategory: subCat.subcategory\r\n            })),\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching subcategories:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Category\r\nrouter.post(\"/category\", async (req, res) => {\r\n    try {\r\n        // Fetch the last inserted category ID\r\n        const [lastCategory] = await db.query(\"SELECT Ca_Id FROM Category ORDER BY Ca_Id DESC LIMIT 1\");\r\n\r\n        let newId;\r\n        if (lastCategory.length > 0) {\r\n            // Extract the number from the last ID and increment\r\n            const lastIdNumber = parseInt(lastCategory[0].Ca_Id.split(\"_\")[1], 10);\r\n            newId = `Ca_${String(lastIdNumber + 1).padStart(4, \"0\")}`;\r\n        } else {\r\n            // If no categories exist, start from Ca_0001\r\n            newId = \"Ca_0001\";\r\n        }\r\n\r\n        // SQL query to insert new category\r\n        const sql = `INSERT INTO Category (Ca_Id, name) VALUES (?, ?)`;\r\n        const values = [newId, req.body.Catname];\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, values);\r\n\r\n        // Return success response with the new category details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Category added successfully\",\r\n            data: {\r\n                Ca_Id: newId,\r\n                name: req.body.Catname\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting category data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Sub category one and two with image\r\nrouter.post(\"/subcategory\", upload.fields([{ name: \"subcatone_img\" }, { name: \"subcattwo_img\" }]), async (req, res) => {\r\n    const { Ca_Id, sub_one, sub_two, isNewSubOne } = req.body;\r\n    const subcatone_img = req.files[\"subcatone_img\"] ? req.files[\"subcatone_img\"][0].buffer : null;\r\n    const subcattwo_img = req.files[\"subcattwo_img\"] ? req.files[\"subcattwo_img\"][0].buffer : null;\r\n\r\n    try {\r\n        let sb_c_id;\r\n\r\n        if (isNewSubOne === \"true\") {\r\n            // Generate ID for new subCat_one\r\n            sb_c_id = await generateNewId(\"subCat_one\", \"sb_c_id\", \"S1\");\r\n\r\n            // Insert new subcategory into subCat_one\r\n            await db.query(\r\n                \"INSERT INTO subCat_one (sb_c_id, subcategory, Ca_Id, img) VALUES (?, ?, ?, ?)\",\r\n                [sb_c_id, sub_one, Ca_Id, subcatone_img]\r\n            );\r\n        } else {\r\n            // Fetch existing sb_c_id for selected subcategory\r\n            const [existingSub] = await db.query(\r\n                \"SELECT sb_c_id FROM subCat_one WHERE subcategory = ? AND Ca_Id = ?\",\r\n                [sub_one, Ca_Id]\r\n            );\r\n\r\n            if (!existingSub.length) {\r\n                return res.status(400).json({ success: false, message: \"Invalid subcategory selection.\" });\r\n            }\r\n            sb_c_id = existingSub[0].sb_c_id;\r\n        }\r\n\r\n        let sb_cc_id = null;\r\n        if (sub_two !== \"None\" && subcattwo_img) {\r\n            // Generate ID for subCat_two\r\n            sb_cc_id = await generateNewId(\"subCat_two\", \"sb_cc_id\", \"S2\");\r\n\r\n            // Insert into subCat_two\r\n            await db.query(\r\n                \"INSERT INTO subCat_two (sb_cc_id, subcategory, sb_c_id, img) VALUES (?, ?, ?, ?)\",\r\n                [sb_cc_id, sub_two, sb_c_id, subcattwo_img]\r\n            );\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Sub-category added successfully\",\r\n            data: {\r\n                sb_c_id,\r\n                sub_one,\r\n                Ca_Id,\r\n                sb_cc_id: sb_cc_id || null,\r\n                sub_two: sb_cc_id ? sub_two : null,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting sub-category data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Save new item to supplier\r\nrouter.post(\"/add-supplier-item\", async (req, res) => {\r\n    try {\r\n        const { I_Id, s_ID, unit_cost } = req.body;\r\n\r\n        // Validate input\r\n        if (!I_Id || !s_ID || !unit_cost) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        // Query to insert the supplier item\r\n        const query = `\r\n            INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n            VALUES (?, ?, ?)\r\n                ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost)\r\n        `;\r\n\r\n        await db.query(query, [I_Id, s_ID, unit_cost]);\r\n\r\n        return res.status(201).json({ success: true, message: \"Item added successfully\" });\r\n    } catch (error) {\r\n        console.error(\"Error adding supplier item:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Fetch all coupons\r\nrouter.get(\"/coupon-details\", async (req, res) => {\r\n    try {\r\n        const query = `\r\n            SELECT\r\n                sc.cpID AS coupon_code,\r\n                sc.discount,\r\n                st.stID AS sales_team_id,\r\n                e.name AS employee_name\r\n            FROM sales_coupon sc\r\n                     JOIN sales_team st ON sc.stID = st.stID\r\n                     JOIN Employee e ON st.E_Id = e.E_Id\r\n        `;\r\n\r\n        const [results] = await db.query(query);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(200).json({ success: false, message: \"No coupon details found\" ,data:[],});\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Coupon details retrieved successfully\",\r\n            data: results,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching coupon details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching coupon details\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Fetch all Delivery rates\r\nrouter.get(\"/delivery-rates\", async (req, res) => {\r\n    try {\r\n        const query = `SELECT * FROM deli_rates`;\r\n\r\n        const [results] = await db.query(query);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No rates details found\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Rates details retrieved successfully\",\r\n            data: results,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching  details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching details\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// GET API to fetch delivery schedule by district\r\nrouter.get(\"/delivery-schedule\", async (req, res) => {\r\n    const { district } = req.query;\r\n\r\n    if (!district) {\r\n        return res.status(400).json({ message: \"District is required\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch all delivery dates for the given district\r\n        const [result] = await db.query(\r\n            \"SELECT ds_date FROM delivery_schedule WHERE district = ?\",\r\n            [district]\r\n        );\r\n\r\n        if (result.length === 0) {\r\n            return res.status(404).json({ message: \"District not found\" });\r\n        }\r\n\r\n        // Convert UTC timestamps to IST and format them as YYYY-MM-DD\r\n        const upcomingDates = result\r\n            .map(row => {\r\n                const utcDate = new Date(row.ds_date);\r\n\r\n                // Convert to IST (UTC +5:30)\r\n                const istDate = new Date(utcDate.getTime() + 5.5 * 60 * 60 * 1000);\r\n\r\n                return istDate.toISOString().split(\"T\")[0]; // Extract YYYY-MM-DD\r\n            })\r\n            .filter(date => {\r\n                const today = new Date();\r\n                today.setHours(0, 0, 0, 0); // Reset time to midnight for comparison\r\n\r\n                return new Date(date) >= today; // Keep today's and upcoming dates\r\n            })\r\n            .sort((a, b) => new Date(a) - new Date(b));\r\n\r\n        if (upcomingDates.length === 0) {\r\n            return res.status(404).json({ message: \"No upcoming delivery dates available\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            message: \"Upcoming delivery dates found\",\r\n            district: district,\r\n            upcomingDates: upcomingDates,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching delivery schedule:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching delivery schedule\" });\r\n    }\r\n});\r\n\r\n// Update change qty\r\nrouter.put(\"/change-quantity\", async (req, res) => {\r\n    const { orId, itemId, newQuantity, updatedPrice, booked } = req.body;\r\n\r\n    // Validation: Check required fields\r\n    if (!orId || !itemId || newQuantity == null || updatedPrice == null) {\r\n        return res.status(400).json({ message: \"Missing required fields.\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch current item quantities\r\n        const [currentItem] = await db.query(\r\n            \"SELECT bookedQty, availableQty FROM Item WHERE I_Id = ?\",\r\n            [itemId]\r\n        );\r\n\r\n        if (!currentItem || currentItem.length === 0) {\r\n            return res.status(404).json({ message: \"Item not found.\" });\r\n        }\r\n\r\n        // Fetch current order quantity\r\n        const [currentOrder] = await db.query(\r\n            \"SELECT qty FROM Order_Detail WHERE orID = ? AND I_Id = ?\",\r\n            [orId, itemId]\r\n        );\r\n\r\n        if (!currentOrder || currentOrder.length === 0) {\r\n            return res.status(404).json({ message: \"Order detail not found.\" });\r\n        }\r\n\r\n        //  Correctly accessing the first row values\r\n        const qtyDifference = Number(newQuantity) - Number(currentOrder[0].qty);\r\n\r\n        let newBookedQty = Number(currentItem[0].bookedQty);\r\n        let newAvailableQty = Number(currentItem[0].availableQty);\r\n\r\n        if (booked) {\r\n            newBookedQty += qtyDifference;\r\n            newAvailableQty -= qtyDifference;\r\n\r\n            if (newAvailableQty < 0) {\r\n                return res.status(400).json({ message: \"Insufficient available quantity.\" });\r\n            }\r\n        }\r\n\r\n        // Update Order_Detail\r\n        await db.query(\r\n            \"UPDATE Order_Detail SET qty = ?, tprice = ? WHERE orID = ? AND I_Id = ?\",\r\n            [newQuantity, updatedPrice, orId, itemId]\r\n        );\r\n\r\n        // Only update booked_item and Item when booked is true\r\n        if (booked) {\r\n            await db.query(\r\n                \"UPDATE booked_item SET qty = ? WHERE orID = ? AND I_Id = ?\",\r\n                [newQuantity, orId, itemId]\r\n            );\r\n\r\n            await db.query(\r\n                \"UPDATE Item SET bookedQty = ?, availableQty = ? WHERE I_Id = ?\",\r\n                [newBookedQty, newAvailableQty, itemId]\r\n            );\r\n        }\r\n\r\n        // Success response\r\n        return res.status(200).json({ message: \"Quantity updated successfully.\" });\r\n    } catch (error) {\r\n        console.error(\"Error updating quantity:\", error.message);\r\n        return res.status(500).json({ message: \"Error updating quantity.\", error: error.message });\r\n    }\r\n});\r\n\r\n// get stock detail by item ids\r\nrouter.post(\"/get-stock-details\", async (req, res) => {\r\n    try {\r\n        // Ensure req.body is an array\r\n        if (!Array.isArray(req.body) || req.body.length === 0) {\r\n            return res.status(400).json({ error: \"Invalid request. Provide an array of item IDs.\" });\r\n        }\r\n\r\n        const itemIds = req.body.map(id => id.trim()); // Trim whitespace\r\n\r\n        // Construct dynamic SQL query with placeholders\r\n        const placeholders = itemIds.map(() => \"?\").join(\", \");\r\n        const sql = `\r\n            SELECT * FROM p_i_detail\r\n            WHERE I_Id IN (${placeholders})\r\n              AND status = 'Available'\r\n        `;\r\n\r\n        // Execute query\r\n        const [results] = await db.query(sql, itemIds);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({\r\n                message: \"No stock details found for the provided item IDs\",\r\n                itemIds: itemIds,\r\n                stockDetails: []\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            message: \"Stock details retrieved successfully\",\r\n            itemIds: itemIds,\r\n            stockDetails: results\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching stock details:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n});\r\n\r\n// get stock detail by item id\r\nrouter.post(\"/get-stock-detail\", async (req, res) => {\r\n    try {\r\n        const { itemId } = req.body;\r\n\r\n        if (!itemId || typeof itemId !== \"string\") {\r\n            return res.status(400).json({ error: \"Invalid request. 'itemId' must be a non-empty string.\" });\r\n        }\r\n\r\n        const trimmedItemId = itemId.trim();\r\n\r\n        const sql = `\r\n            SELECT * FROM p_i_detail\r\n            WHERE I_Id = ?\r\n              AND status = 'Available'\r\n        `;\r\n\r\n        const [results] = await db.query(sql, [trimmedItemId]);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({\r\n                message: \"No stock details found for the provided item ID\",\r\n                itemId: trimmedItemId,\r\n                stockDetails: []\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            message: \"Stock details retrieved successfully\",\r\n            itemId: trimmedItemId,\r\n            stockDetails: results\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching stock details:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n});\r\n\r\n// Special Reserved\r\nrouter.post(\"/special-reserved\", async (req, res) => {\r\n    const { orID, selectedItems, Oid } = req.body;\r\n\r\n    if (!orID || !selectedItems || selectedItems.length === 0 || !Oid) {\r\n        return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n    }\r\n\r\n    try {\r\n        for (const item of selectedItems) {\r\n            // ✅ Update p_i_detail status to 'Reserved' and set orID\r\n            await db.query(\r\n                `UPDATE p_i_detail\r\n                 SET status = 'Reserved', orID = ?, datetime = NOW()\r\n                 WHERE pid_Id = ?`,\r\n                [orID, item.pid_Id]\r\n            );\r\n\r\n            // ✅ Update Item stock: bookedQty -1, reservedQty +1\r\n            await db.query(\r\n                `UPDATE Item\r\n                 SET bookedQty = bookedQty - 1,\r\n                     reservedQty = reservedQty + 1\r\n                 WHERE I_Id = ?`,\r\n                [item.I_Id]\r\n            );\r\n\r\n            // ✅ Insert into Special_Reservation with orID, pid_Id, and OrderDetailId (Oid)\r\n            await db.query(\r\n                `INSERT INTO Special_Reservation (orID, pid_Id, orderDetailId)\r\n                 VALUES (?, ?, ?)`,\r\n                [orID, item.pid_Id, Oid]\r\n            );\r\n\r\n            // ✅ Update Order_Detail status to 'Reserved'\r\n            await db.query(\r\n                `UPDATE Order_Detail\r\n                 SET status = 'Reserved'\r\n                 WHERE id = ?`,\r\n                [Oid]\r\n            );\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Items reserved and Special_Reservation updated successfully\"\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating reservation:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// GET reserved items for an order\r\nrouter.post(\"/get-special-reserved\", async (req, res) => {\r\n    try {\r\n        const { orID, itemIds } = req.body;\r\n\r\n        if (!orID || !Array.isArray(itemIds) || itemIds.length === 0) {\r\n            return res.status(400).json({ error: \"Invalid request. Provide orID and itemIds array.\" });\r\n        }\r\n\r\n        // Construct placeholders for itemIds\r\n        const placeholders = itemIds.map(() => '?').join(', ');\r\n\r\n        const sql = `\r\n            SELECT \r\n                sr.srID,sr.orID, sr.pid_Id,sr.orderDetailId, p.*\r\n            FROM Special_Reservation sr\r\n            JOIN p_i_detail p ON sr.pid_Id = p.pid_Id\r\n            WHERE sr.orID = ?\r\n              AND p.I_Id IN (${placeholders})\r\n        `;\r\n\r\n        const [results] = await db.query(sql, [orID, ...itemIds]);\r\n\r\n        return res.status(200).json({\r\n            message: \"Special reserved items fetched successfully\",\r\n            reservedItems: results\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching special reserved items:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n});\r\n\r\nrouter.get(\"/special-reserved-details\", async (req, res) => {\r\n    const { orID } = req.query;\r\n\r\n    if (!orID) {\r\n        return res.status(400).json({ success: false, message: \"Order ID (orID) is required\" });\r\n    }\r\n\r\n    try {\r\n        const query = `\r\n            SELECT \r\n                sr.srID,\r\n                sr.orID,\r\n                sr.orderDetailId,\r\n                sr.pid_Id,\r\n                pid.I_Id,\r\n                pid.status AS pi_status,\r\n                pid.datetime,\r\n                i.I_name,\r\n                i.color,\r\n                i.price\r\n            FROM Special_Reservation sr\r\n            JOIN p_i_detail pid ON sr.pid_Id = pid.pid_Id\r\n            LEFT JOIN Item i ON pid.I_Id = i.I_Id\r\n            WHERE sr.orID = ?\r\n        `;\r\n\r\n        const [results] = await db.query(query, [orID]);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No special reserved items found for this order.\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Special reserved items fetched successfully\",\r\n            data: results\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching special reserved items:\", error);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Issued order\r\nrouter.post(\"/issued-order\", async (req, res) => {\r\n    const { orID, delStatus, delPrice, discount, subtotal, total, advance, balance, payStatus, stID, paymentAmount, selectedItems } = req.body;\r\n\r\n    if (!orID || !stID || paymentAmount === undefined || !selectedItems || selectedItems.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n    }\r\n\r\n    try {\r\n        // 1. Update Orders table\r\n        await db.query(\r\n            `UPDATE Orders\r\n             SET delStatus = ?, orStatus = 'Issued', delPrice = ?, discount = ?, total = ?, advance = ?, balance = ?, payStatus = ?, stID = ?\r\n             WHERE OrID = ?`,\r\n            [delStatus, delPrice, discount, total, advance, balance, payStatus, stID, orID]\r\n        );\r\n\r\n        // 2. Update p_i_detail table (Mark selected items as issued)\r\n        const updateItemPromises = selectedItems.map(async (item) => {\r\n            await db.query(\r\n                `UPDATE p_i_detail\r\n                 SET status = 'Issued', orID = ?, datetime = NOW()\r\n                 WHERE pid_Id = ?`,\r\n                [orID, item.pid_Id]\r\n            );\r\n\r\n            await db.query(\r\n                `UPDATE issued_items SET status = 'Issued', date = NOW() WHERE orID = ? AND pid_Id = ?`,\r\n                [orID, item.pid_Id]\r\n            );\r\n\r\n        });\r\n\r\n        // Run all queries in parallel\r\n        await Promise.all(updateItemPromises);\r\n\r\n        // 3. Get Order Details\r\n        const [[orderDetail]] = await db.query(\r\n            `SELECT advance, balance, discount, total AS netTotal FROM Orders WHERE OrID = ?`,\r\n            [orID]\r\n        );\r\n\r\n        // 4. Update sales_team table\r\n        const issuedPrice = orderDetail.balance === 0\r\n            ? parseFloat(orderDetail.netTotal) - parseFloat(orderDetail.discount)\r\n            : orderDetail.advance || 0;\r\n\r\n        await db.query(\r\n            `UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?`,\r\n            [issuedPrice, stID]\r\n        );\r\n\r\n        // 5. Update Item stock quantities\r\n        const [orderItems] = await db.query(\r\n            `SELECT I_Id, qty FROM Order_Detail WHERE orID = ?`,\r\n            [orID]\r\n        );\r\n\r\n        const updateStockPromises = orderItems.map(item =>\r\n            db.query(\r\n                `UPDATE Item SET stockQty = stockQty - ?, bookedQty = bookedQty - ? WHERE I_Id = ? AND stockQty >= ?`,\r\n                [item.qty, item.qty, item.I_Id, item.qty]\r\n            )\r\n        );\r\n\r\n        await Promise.all(updateStockPromises);\r\n\r\n        // 6. Delete from booked_item & accept_orders\r\n        await db.query(`DELETE FROM booked_item WHERE orID = ?`, [orID]);\r\n        await db.query(`DELETE FROM accept_orders WHERE orID = ?`, [orID]);\r\n\r\n        // 7. Insert into Payment table\r\n        const op_ID = await generateNewId(\"order_payment\", \"op_ID\", \"OP\");\r\n        await db.query(\"INSERT INTO order_payment (op_ID, orID, amount, dateTime) VALUES (?, ?, ?, NOW())\", [op_ID, orID, paymentAmount]);\r\n        await db.query(\"INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount) VALUES (?, ?, ?, NOW(), ?)\", [\"Order payment\", op_ID, \"order\", paymentAmount]);\r\n\r\n        return res.status(200).json({ success: true, message: \"Order updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Issued Orders items\r\nrouter.post(\"/issued-items\", async (req, res) => {\r\n    const { orID, payStatus, selectedItems, deliveryStatus } = req.body;\r\n\r\n    if (!orID || !payStatus || !selectedItems || selectedItems.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n    }\r\n\r\n    try {\r\n        // 1. Update Orders table only if it's a Delivery\r\n        if (deliveryStatus === \"Delivery\") {\r\n            await db.query(\r\n                `UPDATE Orders SET orStatus = 'Delivered', payStatus = ? WHERE OrID = ?`,\r\n                [payStatus, orID]\r\n            );\r\n        } else {\r\n            await db.query(\r\n                `UPDATE Orders SET payStatus = ? WHERE OrID = ?`,\r\n                [payStatus, orID]\r\n            );\r\n        }\r\n\r\n        // 2. Update p_i_detail and issued_items\r\n        const itemStatus = deliveryStatus === \"Delivery\" ? \"Dispatched\" : \"Issued\";\r\n\r\n        for (const item of selectedItems) {\r\n            await db.query(\r\n                `UPDATE p_i_detail\r\n                 SET status = ?, orID = ?, datetime = NOW(), price = ?\r\n                 WHERE pid_Id = ?`,\r\n                [itemStatus, orID, item.price, item.pid_Id]\r\n            );\r\n\r\n            await db.query(\r\n                `INSERT INTO issued_items (orID, pid_Id, status, date)\r\n                 VALUES (?, ?, ?, NOW())`,\r\n                [orID, item.pid_Id, itemStatus]\r\n            );\r\n        }\r\n\r\n        if (!deliveryStatus === \"Delivery\") {\r\n             // 3. Update Item stock quantities\r\n            const [orderItems] = await db.query(\r\n                `SELECT I_Id, qty FROM Order_Detail WHERE orID = ?`,\r\n                [orID]\r\n            );\r\n    \r\n            for (const item of orderItems) {\r\n                console.log(item);\r\n                await db.query(\r\n                    `UPDATE Item\r\n                     SET bookedQty = bookedQty - ?, dispatchedQty = dispatchedQty + ?\r\n                     WHERE I_Id = ?`,\r\n                    [item.qty, item.qty, item.I_Id]\r\n                );\r\n            }\r\n    \r\n            // 4. Cleanup\r\n            await db.query(`DELETE FROM booked_item WHERE orID = ?`, [orID]);\r\n            await db.query(`DELETE FROM accept_orders WHERE orID = ?`, [orID]);\r\n\r\n            // Step 2: Update ST_order_review\r\n            const totalIssued = selectedItems.reduce((sum, item) => sum + parseFloat(item.price || 0), 0);\r\n\r\n            // Assuming orID is linked to a sales team ID (you may adjust where to fetch stID from)\r\n            const [[{ stID }]] = await db.query(`SELECT stID FROM Orders WHERE OrID = ?`, [orID]);\r\n\r\n            // \uD83E\uDDEE Extract year and month from deliveryDate (or current date if missing)\r\n            const dateObj = new Date();\r\n            const year = dateObj.getFullYear();\r\n            const month = dateObj.toLocaleString('default', { month: 'long' }); // e.g., 'May'\r\n\r\n\r\n            // Check if record exists\r\n            const [[existingReview]] = await db.query(\r\n                `SELECT totalIssued FROM ST_order_review WHERE stID = ? AND year = ? AND month = ?`,\r\n                [stID, year, month]\r\n            );\r\n\r\n            if (existingReview) {\r\n                // Update totalIssued\r\n                await db.query(\r\n                    `UPDATE ST_order_review\r\n                    SET totalIssued = totalIssued + ?\r\n                    WHERE stID = ? AND year = ? AND month = ?`,\r\n                    [totalIssued, stID, year, month]\r\n                );\r\n            } else {\r\n                // Insert new row\r\n                await db.query(\r\n                    `INSERT INTO ST_order_review (stID, year, month, totalOrder, totalIssued)\r\n                    VALUES (?, ?, ?, 0, ?)`,\r\n                    [stID, year, month, totalIssued]\r\n                );\r\n            }\r\n    \r\n        }\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: `Order processed as ${itemStatus}`,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Issued item in now order\r\nrouter.post(\"/issued-items-Now\", async (req, res) => {\r\n    const { orID, payStatus, selectedItems, deliveryStatus } = req.body;\r\n\r\n    if (!orID || !payStatus || !selectedItems || selectedItems.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n    }\r\n\r\n    try {\r\n        // 1. Update Orders table only if it's a Delivery\r\n        if (deliveryStatus === \"Delivery\") {\r\n            await db.query(\r\n                `UPDATE Orders SET orStatus = 'Delivered', payStatus = ? WHERE OrID = ?`,\r\n                [payStatus, orID]\r\n            );\r\n        } else {\r\n            await db.query(\r\n                `UPDATE Orders SET payStatus = ? WHERE OrID = ?`,\r\n                [payStatus, orID]\r\n            );\r\n        }\r\n\r\n        // 2. Update p_i_detail and issued_items\r\n        const itemStatus = deliveryStatus === \"Delivery\" ? \"Dispatched\" : \"Issued\";\r\n\r\n        for (const item of selectedItems) {\r\n            await db.query(\r\n                `UPDATE p_i_detail\r\n                 SET status = ?, orID = ?, datetime = NOW(), price = ?\r\n                 WHERE pid_Id = ?`,\r\n                [itemStatus, orID, item.price, item.pid_Id]\r\n            );\r\n\r\n            await db.query(\r\n                `INSERT INTO issued_items (orID, pid_Id, status, date)\r\n                 VALUES (?, ?, ?, NOW())`,\r\n                [orID, item.pid_Id, itemStatus]\r\n            );\r\n        }\r\n\r\n        if (deliveryStatus === \"Delivery\") {\r\n             // 3. Update Item stock quantities\r\n            const [orderItems] = await db.query(\r\n                `SELECT I_Id, qty FROM Order_Detail WHERE orID = ?`,\r\n                [orID]\r\n            );\r\n    \r\n            for (const item of orderItems) {\r\n                console.log(item);\r\n                await db.query(\r\n                    `UPDATE Item\r\n                     SET availableQty = availableQty - ?, dispatchedQty = dispatchedQty + ?\r\n                     WHERE I_Id = ?`,\r\n                    [item.qty, item.qty, item.I_Id]\r\n                );\r\n            }\r\n    \r\n            // 4. Cleanup\r\n            await db.query(`DELETE FROM booked_item WHERE orID = ?`, [orID]);\r\n            await db.query(`DELETE FROM accept_orders WHERE orID = ?`, [orID]);\r\n    \r\n        }\r\n\r\n        if (deliveryStatus !== \"Delivery\") {\r\n        // Step 1: Update stock quantities\r\n        const [orderItems] = await db.query(\r\n            `SELECT I_Id, qty FROM Order_Detail WHERE orID = ?`,\r\n            [orID]\r\n        );\r\n\r\n        for (const item of orderItems) {\r\n            await db.query(\r\n                `UPDATE Item\r\n                SET availableQty = availableQty - ?, stockQty = stockQty - ?\r\n                WHERE I_Id = ?`,\r\n                [item.qty, item.qty, item.I_Id]\r\n            );\r\n        }\r\n\r\n        // Step 2: Update ST_order_review\r\n        const totalIssued = selectedItems.reduce((sum, item) => sum + parseFloat(item.price || 0), 0);\r\n\r\n        // Assuming orID is linked to a sales team ID (you may adjust where to fetch stID from)\r\n        const [[{ stID }]] = await db.query(`SELECT stID FROM Orders WHERE OrID = ?`, [orID]);\r\n\r\n        // \uD83E\uDDEE Extract year and month from deliveryDate (or current date if missing)\r\n        const dateObj = new Date();\r\n        const year = dateObj.getFullYear();\r\n        const month = dateObj.toLocaleString('default', { month: 'long' }); // e.g., 'May'\r\n\r\n\r\n        // Check if record exists\r\n        const [[existingReview]] = await db.query(\r\n            `SELECT totalIssued FROM ST_order_review WHERE stID = ? AND year = ? AND month = ?`,\r\n            [stID, year, month]\r\n        );\r\n\r\n        if (existingReview) {\r\n            // Update totalIssued\r\n            await db.query(\r\n                `UPDATE ST_order_review\r\n                SET totalIssued = totalIssued + ?\r\n                WHERE stID = ? AND year = ? AND month = ?`,\r\n                [totalIssued, stID, year, month]\r\n            );\r\n        } else {\r\n            // Insert new row\r\n            await db.query(\r\n                `INSERT INTO ST_order_review (stID, year, month, totalOrder, totalIssued)\r\n                VALUES (?, ?, ?, 0, ?)`,\r\n                [stID, year, month, totalIssued]\r\n            );\r\n        }\r\n    }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: `Order processed as ${itemStatus}`,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save new Delivery Rate\r\nrouter.post(\"/delivery-rates\", async (req, res) => {\r\n    try {\r\n        // SQL query to insert new category\r\n        const sql = `INSERT INTO deli_Rates (district, amount) VALUES (?, ?)`;\r\n        const values = [req.body.District,req.body.rate];\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, values);\r\n\r\n        // Return success response with the new category details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Rate added successfully\",\r\n            data: {\r\n                District: req.body.District,\r\n                rate: req.body.rate\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting rates data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save Scheduled dates\r\nrouter.post(\"/delivery-dates\", async (req, res) => {\r\n    try {\r\n        const { District, dates } = req.body; // Extract district and dates array\r\n\r\n        if (!District || !Array.isArray(dates) || dates.length === 0) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"District and at least one date are required\"\r\n            });\r\n        }\r\n\r\n        // SQL query to insert multiple dates\r\n        const sql = `INSERT INTO delivery_schedule (district, ds_date) VALUES ?`;\r\n        const values = dates.map(date => [District, date]); // Create array of values\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, [values]);\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Delivery dates added successfully\",\r\n            data: {\r\n                District,\r\n                dates,\r\n            },\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error inserting delivery dates:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save new employee and saleteam\r\nrouter.post(\"/employees\", upload.single(\"lincenseimg\"), async (req, res) => {\r\n    try {\r\n        const {\r\n            name, address, nic, dob, contact, job, basic,\r\n            type, orderTarget, issuedTarget, lincenseDate,\r\n            monthlyTarget, dailyTarget\r\n        } = req.body;\r\n\r\n        const lincenseimg = req.file ? req.file.buffer : null;\r\n\r\n        if (!name || !address || !nic || !dob || !contact || !job || !basic) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"Required fields missing\",\r\n            });\r\n        }\r\n\r\n        const E_Id = await generateNewId(\"Employee\", \"E_Id\", \"E\");\r\n\r\n        await db.query(\r\n            `INSERT INTO Employee (E_Id, name, address, nic, dob, contact, job, basic, type)\r\n             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,\r\n            [E_Id, name, address, nic, dob, contact, job, parseFloat(basic), type]\r\n        );\r\n\r\n        let Data = null;\r\n\r\n        if (job === \"Sales\" && orderTarget && issuedTarget) {\r\n            const stID = await generateNewId(\"sales_team\", \"stID\", \"ST\");\r\n            await db.query(\r\n                `INSERT INTO sales_team (stID, E_Id, orderTarget, issuedTarget, totalOrder, totalIssued)\r\n                 VALUES (?, ?, ?, ?, 0, 0)`,\r\n                [stID, E_Id, parseFloat(orderTarget), parseFloat(issuedTarget)]\r\n            );\r\n            Data = { stID, orderTarget, issuedTarget };\r\n        }\r\n\r\n        if (job === \"Driver\") {\r\n            const devID = await generateNewId(\"driver\", \"devID\", \"DI\");\r\n            await db.query(\r\n                `INSERT INTO driver (devID, E_ID, balance, lincenseDate, lincense, dailyTarget, monthlyTarget)\r\n                 VALUES (?, ?, 0, ?, ?, ?, ?)`,\r\n                [\r\n                    devID,\r\n                    E_Id,\r\n                    lincenseDate || null,\r\n                    lincenseimg || null,\r\n                    parseFloat(dailyTarget) || 0,\r\n                    parseFloat(monthlyTarget) || 0,\r\n                ]\r\n            );\r\n            Data = { devID, E_Id };\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Employee added successfully\",\r\n            data: { E_Id, ...Data },\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error adding employee:\", err);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error adding employee\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save Delivery Notes with mulitiple orders\r\nrouter.post(\"/create-delivery-note\", async (req, res) => {\r\n    try {\r\n\r\n        const { driverName, driverId, vehicleName, hire, date, district, orders, balanceToCollect } = req.body;\r\n\r\n        // Validate required fields\r\n        if (!driverName || !vehicleName || !date || !hire || !Array.isArray(orders) || orders.length === 0) {\r\n            return res.status(400).json({ message: \"Driver name, vehicle name, hire, date, and orders are required.\" });\r\n        }\r\n        // Insert into delivery_note table\r\n        const [result] = await db.query(`\r\n            INSERT INTO delivery_note (driverName, devID, vehicalName, date, hire, district, balanceToCollect, status)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?, 'Incomplete')\r\n        `, [driverName, driverId, vehicleName, date, hire, district, balanceToCollect]);\r\n\r\n        // Get the generated Delivery Note ID\r\n        const delNoID = result.insertId;\r\n        // Insert orders into delivery_note_orders table\r\n        const orderQueries = orders.map(async ({ orderId, balance = 0 }) => {\r\n            try {\r\n                return await db.query(`\r\n                    INSERT INTO delivery_note_orders (delNoID, orID, balance)\r\n                    VALUES (?, ?, ?)\r\n                `, [delNoID, orderId, balance]);\r\n            } catch (err) {\r\n                console.error(`Error inserting order ${orderId}:`, err);\r\n            }\r\n        });\r\n\r\n        // Update delivery status for each order\r\n        const deliveryQueries = orders.map(async ({ orderId }) => {\r\n            try {\r\n                return await db.query(`\r\n                    UPDATE delivery\r\n                    SET status = 'Delivered', delivery_Date = ?\r\n                    WHERE orID = ?\r\n                `, [date, orderId]);\r\n            } catch (err) {\r\n                console.error(`Error updating delivery for order ${orderId}:`, err);\r\n            }\r\n        });\r\n\r\n        // Execute all insert and update queries\r\n        await Promise.allSettled(orderQueries);\r\n        await Promise.allSettled(deliveryQueries);\r\n\r\n        // Send success response\r\n        return res.status(201).json({\r\n            message: \"Delivery note created successfully\",\r\n            delNoID\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error creating delivery note:\", error);\r\n        return res.status(500).json({ message: \"Error creating delivery note\", details: error.message });\r\n    }\r\n});\r\n\r\n// Save delivery note with one order\r\nrouter.post(\"/create-delivery-note-now\", async (req, res) => {\r\n    try {\r\n        const {driverName, driverId, vehicleName, hire, date, district, order, balanceToCollect} = req.body;\r\n\r\n        // Validate required fields\r\n        if (!driverName || !vehicleName || !date || !hire || !order || !order.orderId) {\r\n            return res.status(400).json({\r\n                message: \"Driver name, vehicle name, hire, date, and a valid order are required.\"\r\n            });\r\n        }\r\n\r\n        const { orderId, balance = 0 } = order;\r\n\r\n        // Insert into delivery_note table\r\n        const [result] = await db.query(`\r\n            INSERT INTO delivery_note (driverName, devID, vehicalName, date, hire, district, balanceToCollect, status)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?, 'Incomplete')\r\n        `, [driverName, driverId, vehicleName, date, hire, district, balanceToCollect]);\r\n\r\n        const delNoID = result.insertId;\r\n\r\n        // Insert the single order into delivery_note_orders\r\n        await db.query(`\r\n            INSERT INTO delivery_note_orders (delNoID, orID, balance)\r\n            VALUES (?, ?, ?)\r\n        `, [delNoID, orderId, balance]);\r\n\r\n        // Update delivery status for the order\r\n        await db.query(`\r\n            UPDATE delivery\r\n            SET status = 'Delivered', delivery_Date = ?\r\n            WHERE orID = ?\r\n        `, [date, orderId]);\r\n\r\n        return res.status(201).json({\r\n            message: \"Delivery note created successfully\",\r\n            delNoID\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error creating delivery note:\", error);\r\n        return res.status(500).json({\r\n            message: \"Error creating delivery note\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get Delivery Note detail\r\nrouter.get(\"/delivery-note\", async (req, res) => {\r\n    try {\r\n        const { delNoID } = req.query;\r\n\r\n        if (!delNoID) {\r\n            return res.status(400).json({ success: false, message: \"Delivery Note ID is required.\" });\r\n        }\r\n\r\n        // Fetch delivery note details including driver ID (devID) and driver name from Employee\r\n        const [deliveryNote] = await db.query(\r\n            `SELECT dn.*, e.name AS driverName\r\n             FROM delivery_note dn\r\n                      LEFT JOIN driver d ON dn.devID = d.devID\r\n                      LEFT JOIN Employee e ON d.E_Id = e.E_Id\r\n             WHERE dn.delNoID = ?`,\r\n            [delNoID]\r\n        );\r\n\r\n        if (deliveryNote.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Delivery note not found\" });\r\n        }\r\n\r\n        // Fetch associated orders and balance from delivery_note_orders\r\n        const [orders] = await db.query(\r\n            `SELECT o.OrID, o.orStatus AS orderStatus, o.delStatus AS deliveryStatus,\r\n                    o.payStatus, dno.balance AS balanceAmount\r\n             FROM delivery_note_orders dno\r\n                      INNER JOIN Orders o ON o.OrID = dno.orID\r\n             WHERE dno.delNoID = ?`,\r\n            [delNoID]\r\n        );\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No orders found for this delivery note\" });\r\n        }\r\n\r\n        // Fetch issued and returned items from the issued_items table\r\n        const orderIds = orders.map(order => order.OrID);\r\n        let issuedItems = [];\r\n\r\n        if (orderIds.length > 0) {\r\n            [issuedItems] = await db.query(\r\n                `SELECT ii.orID, ii.pid_Id, ii.status AS itemStatus,\r\n                        pi.stock_Id, pi.barcode_img, pi.datetime, pi.I_Id\r\n                 FROM issued_items ii\r\n                          JOIN p_i_detail pi ON ii.pid_Id = pi.pid_Id\r\n                 WHERE ii.orID IN (?)`,\r\n                [orderIds]\r\n            );\r\n        }\r\n\r\n        // Organize issued items under their respective orders\r\n        const ordersWithIssuedItems = orders.map(order => ({\r\n            ...order,\r\n            issuedItems: issuedItems.filter(item => item.orID === order.OrID),\r\n            balance: order.payStatus === \"COD\" ? order.balanceAmount : null // Include balance only if COD\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Delivery note details fetched successfully\",\r\n            details: deliveryNote[0], // Delivery note details including devID and driver name\r\n            orders: ordersWithIssuedItems // Orders with issued and returned items grouped\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching delivery note details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching delivery note details\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Coupone\r\nrouter.post(\"/coupone\", async (req, res) => {\r\n    const sql = `INSERT INTO sales_coupon (cpID,stID,discount) VALUES (?, ?,?)`;\r\n    const values = [\r\n        req.body.couponCode,\r\n        req.body.saleteamCode,\r\n        req.body.discount\r\n    ];\r\n    try {\r\n        // Execute the query and retrieve the result\r\n        const [result] = await db.query(sql, values);\r\n\r\n        // Return success response with inserted data details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Coupone added successfully\",\r\n            data: {\r\n                couponCode : req.body.couponCode,\r\n                saleteamCode: req.body.saleteamCode,\r\n                discount: req.body.discount\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting coupone data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save shop banks\r\nrouter.post('/shop-banks', async (req, res) => {\r\n    const { bank, branch } = req.body;\r\n\r\n    if (!bank || !branch) {\r\n        return res.status(400).json({ error: 'Bank and branch are required' });\r\n    }\r\n\r\n    try {\r\n        const [result] = await db.query(\r\n            'INSERT INTO shop_Banks (Bank, branch) VALUES (?, ?)',\r\n            [bank, branch]\r\n        );\r\n        res.status(201).json({ message: 'Bank added successfully', sbID: result.insertId });\r\n    } catch (error) {\r\n        console.error('Error inserting shop_Banks:', error);\r\n        res.status(500).json({ error: 'Failed to add bank' });\r\n    }\r\n});\r\n\r\n// save Account numbers \r\nrouter.post('/account-numbers', async (req, res) => {\r\n    const { sbID, number } = req.body;\r\n\r\n    if (!sbID || !number) {\r\n        return res.status(400).json({ error: 'sbID and account number are required' });\r\n    }\r\n\r\n    try {\r\n        const [bankExists] = await db.query('SELECT sbID FROM shop_Banks WHERE sbID = ?', [sbID]);\r\n        if (bankExists.length === 0) {\r\n            return res.status(404).json({ error: 'Bank not found' });\r\n        }\r\n\r\n        const [result] = await db.query(\r\n            'INSERT INTO accountNumbers (sbID, number) VALUES (?, ?)',\r\n            [sbID, number]\r\n        );\r\n        res.status(201).json({ message: 'Account number added successfully', acnID: result.insertId });\r\n    } catch (error) {\r\n        console.error('Error inserting accountNumbers:', error);\r\n        res.status(500).json({ error: 'Failed to add account number' });\r\n    }\r\n});\r\n\r\n// Get all banks \r\nrouter.get('/shop-banks', async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query('SELECT * FROM shop_Banks');\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching shop_Banks:', error);\r\n        res.status(500).json({ error: 'Failed to fetch banks' });\r\n    }\r\n});\r\n\r\n// Get All account by sbid \r\nrouter.post('/account-numbers/by-id', async (req, res) => {\r\n    const { sbID } = req.body;\r\n\r\n    try {\r\n        const [rows] = await db.query(\r\n            'SELECT * FROM accountNumbers WHERE sbID = ?',\r\n            [sbID]\r\n        );\r\n\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching account numbers:', error);\r\n        res.status(500).json({ error: 'Failed to fetch account numbers' });\r\n    }\r\n});\r\n\r\n//Get All Account Numbers Grouped by sbID\r\nrouter.get('/account-numbers/grouped', async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query(`\r\n            SELECT \r\n                shop_Banks.sbID,\r\n                shop_Banks.Bank,\r\n                shop_Banks.branch,\r\n                accountNumbers.acnID,\r\n                accountNumbers.number\r\n            FROM \r\n                shop_Banks\r\n            LEFT JOIN \r\n                accountNumbers ON shop_Banks.sbID = accountNumbers.sbID\r\n            ORDER BY shop_Banks.sbID\r\n        `);\r\n\r\n        const grouped = {};\r\n\r\n        for (const row of rows) {\r\n            if (!grouped[row.sbID]) {\r\n                grouped[row.sbID] = {\r\n                    sbID: row.sbID,\r\n                    Bank: row.Bank,\r\n                    branch: row.branch,\r\n                    accountNumbers: []\r\n                };\r\n            }\r\n\r\n            if (row.acnID) {\r\n                grouped[row.sbID].accountNumbers.push({\r\n                    acnID: row.acnID,\r\n                    number: row.number\r\n                });\r\n            }\r\n        }\r\n\r\n        const result = Object.values(grouped);\r\n        res.status(200).json(result);\r\n\r\n    } catch (error) {\r\n        console.error('Error fetching grouped account numbers:', error);\r\n        res.status(500).json({ error: 'Failed to fetch grouped account numbers' });\r\n    }\r\n});\r\n\r\n// Salary-advance save\r\nrouter.post(\"/save-advance\", async (req, res) => {\r\n    try {\r\n        const { id, name, advance } = req.body;\r\n        const amount = Number(advance) || 0;\r\n        const advancepay = Number(amount); // Make sure the advancepay is a positive amount (unless negative is needed)\r\n\r\n        // Generate unique Advance Payment ID\r\n        const ad_ID = await generateNewId(\"salary_advance\", \"ad_ID\", \"AP\");\r\n\r\n        // Insert into advance_payment table\r\n        const sql = `INSERT INTO salary_advance (ad_ID, E_Id, amount, dateTime) VALUES (?, ?, ?, NOW())`;\r\n        const values = [ad_ID, id, amount];\r\n        const [result] = await db.query(sql, values);\r\n\r\n        // Insert into payment table with the negative advance amount (for payment record)\r\n        const sql1 = `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount) VALUES (?, ?, ?, NOW(), ?)`;\r\n        const values1 = [\"Pay Advance\", ad_ID, \"advance\", -advancepay];\r\n        const [result1] = await db.query(sql1, values1);\r\n\r\n        // Return success response with inserted data details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Advance added successfully\",\r\n            data: {\r\n                ad_ID,               // The generated Advance Payment ID\r\n                amount,              // The amount of the advance\r\n                paymentAmount: -advancepay, // Payment amount as negative (if needed)\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting Advance data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Salary-advance save\r\nrouter.post(\"/save-loan\", async (req, res) => {\r\n    try {\r\n        const { id, name, loan,months,installment } = req.body;\r\n        const amount = Number(loan) || 0;\r\n        const installment1 = Number(installment) || 0;\r\n        const count = Number(months) || 0;\r\n\r\n        // Generate unique Advance Payment ID\r\n        const sl_ID = await generateNewId(\"salary_loan\", \"sl_ID\", \"LP\");\r\n\r\n        // Insert into advance_payment table\r\n        const sql = `INSERT INTO salary_loan (sl_ID, E_Id, amount, dateTime,installment,months,skip) VALUES (?, ?, ?, NOW(),?,?,0)`;\r\n        const values = [sl_ID, id, amount,installment1,count];\r\n         const [result] = await db.query(sql, values);\r\n\r\n        // Insert installment details into sal_loan_detail\r\n        let currentDate = new Date();\r\n        for (let i = 0; i < count; i++) {\r\n            currentDate.setMonth(currentDate.getMonth() + 1); // Move to next month\r\n            let formattedDate = currentDate.toISOString().split(\"T\")[0]; // Format as YYYY-MM-DD\r\n\r\n            const sql2 = `INSERT INTO sal_loan_detail (sl_ID, date, installment) VALUES (?, ?, ?)`;\r\n            const values2 = [sl_ID, formattedDate, installment1];\r\n            await db.query(sql2, values2);\r\n        }\r\n\r\n        // Insert into payment table with the negative advance amount (for payment record)\r\n        const sql1 = `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount) VALUES (?, ?, ?, NOW(), ?)`;\r\n        const values1 = [\"Pay Loan\", sl_ID, \"Loan\", -amount];\r\n         const [result1] = await db.query(sql1, values1);\r\n\r\n        // Return success response with inserted data details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Loan added successfully\",\r\n            data: {\r\n                sl_ID,               // The generated Advance Payment ID\r\n                amount,              // The amount of the advance\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting Advance data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// POST: Create a new request\r\nrouter.post('/request', async (req, res) => {\r\n    const { E_Id, reason, status } = req.body;\r\n\r\n    // ✅ Validation\r\n    if (!E_Id || !reason || !status) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: 'All fields (E_Id, reason, status) are required.'\r\n        });\r\n    }\r\n\r\n    try {\r\n        const sql = `\r\n            INSERT INTO Request (E_Id, reason, status)\r\n            VALUES (?, ?, ?)\r\n        `;\r\n\r\n        const [result] = await db.query(sql, [E_Id, reason, status]);\r\n\r\n        res.status(201).json({\r\n            success: true,\r\n            message: 'Request submitted successfully.',\r\n            data: { id: result.insertId, E_Id, reason, status }\r\n        });\r\n    } catch (error) {\r\n        console.error('Error inserting request:', error.message);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'Internal server error.',\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Promotion\r\nrouter.post(\"/promotion\", upload.single('img'), async (req, res) => {\r\n    const sql = `INSERT INTO Promotion (img, date ) VALUES (?, ?)`;\r\n\r\n    const values = [\r\n        req.file.buffer,  // The image file is in `req.file.buffer`\r\n        req.body.date,\r\n    ];\r\n\r\n    // try {\r\n    //     const [result] = await db.query(sql, values);\r\n    //\r\n    //     return res.status(201).json({\r\n    //         success: true,\r\n    //         message: \"Promotion added successfully\",\r\n    //         data: {\r\n    //             img: req.body.img,\r\n    //             date: req.body.date,\r\n    //         },\r\n    //     });\r\n    // } catch (err) {\r\n    //     console.error(\"Error inserting item data:\", err.message);\r\n    //     return res.status(500).json({\r\n    //         success: false,\r\n    //         message: \"Error inserting data into database\",\r\n    //         details: err.message,\r\n    //     });\r\n    // }\r\n});\r\n\r\n// Update delivery note when order status issued (done)\r\nrouter.post(\"/delivery-return\", async (req, res) => {\r\n    const { deliveryNoteId, orderIds } = req.body;\r\n\r\n    if (!deliveryNoteId || !Array.isArray(orderIds) || orderIds.length === 0) {\r\n        return res.status(400).json({ error: \"Missing deliveryNoteId or invalid orderIds in request body.\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch all orders related to the delivery note\r\n        const [orders] = await db.query(\r\n            \"SELECT OrID, payStatus FROM Orders WHERE OrID IN (?)\",\r\n            [orderIds]\r\n        );\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ error: \"No orders found for the given order IDs.\" });\r\n        }\r\n\r\n        // Check if all orders are either \"Settled\" or \"N-Settled\"\r\n        const allSettled = orders.every(order => order.payStatus === \"Settled\" || order.payStatus === \"N-Settled\");\r\n\r\n        if (!allSettled) {\r\n            return res.status(400).json({\r\n                error: \"Some orders are not settled. Delivery note update aborted.\"\r\n            });\r\n        }\r\n\r\n        // Update the delivery note status to \"Complete\"\r\n        const [result] = await db.query(\r\n            \"UPDATE delivery_note SET status = ? WHERE delNoID = ?\",\r\n            [\"Complete\", deliveryNoteId]\r\n        );\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({ error: \"Delivery note not found or already updated.\" });\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Delivery note updated successfully.\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating delivery note:\", error);\r\n        return res.status(500).json({ error: \"Internal server error.\" });\r\n    }\r\n});\r\n\r\n// update payment in delivery note\r\nrouter.post(\"/delivery-payment\", async (req, res) => {\r\n    const { customReason, deliveryStatus, driver, driverId, deliveryDate, orderId, orderStatus, paymentDetails, reason, rescheduledDate, issuedItems, returnedItems, cancelledItems } = req.body;\r\n    const { RPayment, customerbalance, driverbalance, profitOrLoss } = paymentDetails || {};\r\n\r\n    const receivedPayment = Number(RPayment) || 0;\r\n    const DrivBalance = Number(driverbalance) || 0;\r\n    const CustBalance = Number(customerbalance) || 0;\r\n    const Loss = Number(profitOrLoss) || 0;\r\n\r\n    try {\r\n        // Fetch order details\r\n        const [Orderpayment] = await db.query(\r\n            \"SELECT orID, c_ID, balance, advance, total, netTotal, discount, delPrice, stID FROM Orders WHERE OrID = ?\",\r\n            [orderId]\r\n        );\r\n\r\n        if (!Orderpayment.length) {\r\n            console.error(\"No order found for this order ID.\");\r\n            return res.status(404).json({ error: \"Order not found.\" });\r\n        }\r\n\r\n        const { orID, c_ID, balance, advance, total, netTotal, discount, delPrice, stID } = Orderpayment[0];\r\n        let NetTotal1 = Math.max(0, Number(netTotal) || 0);\r\n        let totalAmount = Math.max(0, Number(total) || 0);\r\n        let discountAmount = Number(discount) || 0;\r\n        let deliveryCharge = Number(delPrice) || 0;\r\n        let previousAdvance = Number(advance) || 0;\r\n\r\n        // Fetch delivery\r\n        const [deliveryData] = await db.query(\"SELECT dv_id FROM delivery WHERE orID = ?\", [orderId]);\r\n        const dv_id = deliveryData?.[0]?.dv_id || null;\r\n\r\n        // Fetch customer and driver balance\r\n        const [customerData] = await db.query(\"SELECT balance FROM Customer WHERE c_ID = ?\", [c_ID]);\r\n        let customerBalance = Number(customerData?.[0]?.balance || 0) + CustBalance;\r\n\r\n        const [driverData] = await db.query(\"SELECT balance FROM Driver WHERE devID = ?\", [driverId]);\r\n        let driverNewBalance = Number(driverData?.[0]?.balance || 0) + DrivBalance;\r\n\r\n        // Calculate new advance and balance\r\n        let advance1 = previousAdvance + receivedPayment;\r\n        let balance1 = Math.max(0, totalAmount - advance1);\r\n\r\n        /** ------------------- Process Returned Items --------------------- */\r\n        if (returnedItems && Array.isArray(returnedItems)) {\r\n            for (const item of returnedItems) {\r\n                if (!item.itemId || !item.stockId) continue;\r\n\r\n                await db.query(\"UPDATE p_i_detail SET status = ? WHERE I_Id = ? AND stock_Id = ?\", [item.status, item.itemId, item.stockId]);\r\n\r\n                const [srdData] = await db.query(\"SELECT pid_Id FROM p_i_detail WHERE I_Id = ? AND stock_Id = ?\", [item.itemId, item.stockId]);\r\n                const srdId = srdData?.[0]?.pid_Id || null;\r\n\r\n                if (srdId !== null) {\r\n                    await db.query(\"UPDATE issued_items SET status = ? WHERE pid_Id = ? AND orID = ?\", [item.status, srdId, orderId]);\r\n                }\r\n\r\n                if (item.status === \"Available\") {\r\n                    await db.query(\"UPDATE Item SET dispatchedQty = dispatchedQty - 1, availableQty = availableQty + 1 WHERE I_Id = ?\", [item.itemId]);\r\n                } else if (item.status === \"Reserved\") {\r\n                    if (srdId !== null) {\r\n                        await db.query(\"INSERT INTO Special_Reservation (orID, pid_Id) VALUES (?, ?)\", [orderId, srdId]);\r\n                    }\r\n                    await db.query(\"UPDATE Item SET reservedQty = reservedQty + 1, dispatchedQty = dispatchedQty - 1 WHERE I_Id = ?\", [item.itemId]);\r\n                } else if (item.status === \"Damaged\") {\r\n                    await db.query(\"UPDATE Item SET dispatchedQty = dispatchedQty - 1, damageQty = damageQty + 1 WHERE I_Id = ?\", [item.itemId]);\r\n                }\r\n            }\r\n        }\r\n\r\n        /** ------------------- Process Cancelled Items --------------------- */\r\n        if (cancelledItems && Array.isArray(cancelledItems)) {\r\n            for (const item of cancelledItems) {\r\n                if (!item.itemId || !item.stockId) continue;\r\n\r\n                await db.query(\"UPDATE p_i_detail SET status = ? WHERE I_Id = ? AND stock_Id = ?\", [item.status, item.itemId, item.stockId]);\r\n\r\n                const [srdData] = await db.query(\"SELECT pid_Id FROM p_i_detail WHERE I_Id = ? AND stock_Id = ?\", [item.itemId, item.stockId]);\r\n                const srdId = srdData?.[0]?.pid_Id || null;\r\n\r\n                if (srdId !== null) {\r\n                    await db.query(\"UPDATE issued_items SET status = ? WHERE pid_Id = ? AND orID = ?\", [item.status, srdId, orderId]);\r\n                }\r\n\r\n                if (item.status === \"Available\") {\r\n                    await db.query(\"UPDATE Item SET dispatchedQty = dispatchedQty - 1, availableQty = availableQty + 1 WHERE I_Id = ?\", [item.itemId]);\r\n                } else if (item.status === \"Damaged\") {\r\n                    await db.query(\"UPDATE Item SET dispatchedQty = dispatchedQty - 1, damageQty = damageQty + 1 WHERE I_Id = ?\", [item.itemId]);\r\n                }\r\n            }\r\n        }\r\n\r\n        /** ------------------- Process Issued Items --------------------- */\r\n        if (issuedItems && Array.isArray(issuedItems)) {\r\n            for (const item of issuedItems) {\r\n                if (!item.I_Id || !item.stock_Id) continue;\r\n\r\n                const [itemData] = await db.query(\"SELECT status FROM p_i_detail WHERE I_Id = ? AND stock_Id = ?\", [item.I_Id, item.stock_Id]);\r\n                const currentStatus = itemData?.[0]?.status || \"\";\r\n\r\n                if (currentStatus === \"Dispatched\") {  // Only update if still Dispatched\r\n                    await db.query(\"UPDATE p_i_detail SET status = ? WHERE I_Id = ? AND stock_Id = ?\", [\"Issued\", item.I_Id, item.stock_Id]);\r\n                    await db.query(\"UPDATE Item SET dispatchedQty = dispatchedQty - 1, stockQty = stockQty - 1 WHERE I_Id = ?\", [item.itemId]);\r\n                    const [srdData] = await db.query(\"SELECT pid_Id FROM p_i_detail WHERE I_Id = ? AND stock_Id = ?\", [item.I_Id, item.stock_Id]);\r\n                    const srdId = srdData?.[0]?.pid_Id || null;\r\n\r\n                    if (srdId !== null) {\r\n                        await db.query(\"UPDATE issued_items SET status = ? WHERE pid_Id = ? AND orID = ?\", [\"Issued\", srdId, orderId]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /** ------------------- Update Order and Balances --------------------- */\r\n        NetTotal1 = Math.max(0, NetTotal1);\r\n        const payStatus = (balance1 === 0) ? \"Settled\" : \"N-Settled\";\r\n        let newTotal = Math.max(0, (NetTotal1 - discountAmount) + deliveryCharge);\r\n        let reducePrice = newTotal - totalAmount;\r\n        customerBalance += (NetTotal1 === 0 ? receivedPayment : reducePrice);\r\n\r\n        const op_ID = await generateNewId(\"order_payment\", \"op_ID\", \"OP\");\r\n\r\n        await db.query(\"UPDATE Customer SET balance = ? WHERE c_ID = ?\", [customerBalance, c_ID]);\r\n        await db.query(\"UPDATE Driver SET balance = ? WHERE devID = ?\", [driverNewBalance, driverId]);\r\n\r\n        if (orderStatus === \"Delivered\") {\r\n            await db.query(\"UPDATE Orders SET balance = ?, advance = ?, orStatus = ?, total = ?, netTotal = ?, delStatus = ?, payStatus = ? WHERE OrID = ?\",\r\n                [balance1, advance1, \"Issued\", newTotal, NetTotal1, deliveryStatus, payStatus, orderId]);\r\n        } else {\r\n            await db.query(\"UPDATE Orders SET balance = ?, advance = ?, orStatus = ?, total = ?, netTotal = ?, delStatus = ?, payStatus = ? WHERE OrID = ?\",\r\n                [balance1, advance1, orderStatus, newTotal, NetTotal1, deliveryStatus, payStatus, orderId]);\r\n        }\r\n\r\n        if (dv_id) {\r\n            await db.query(\"UPDATE delivery SET delivery_Date = ?, status = ?, driverBalance = ?, devID = ? WHERE dv_id = ?\",\r\n                [deliveryDate, deliveryStatus, DrivBalance, driverId, dv_id]);\r\n        }\r\n\r\n        await db.query(\"UPDATE delivery_note_orders SET balance = ? WHERE orID = ?\", [balance1, orderId]);\r\n\r\n        if (receivedPayment !== 0) {\r\n            const netValue = (advance1 - deliveryCharge) - Loss;\r\n\r\n            if (orderStatus === \"Delivered\") {\r\n                await db.query(\r\n                    \"INSERT INTO order_payment (op_ID, orID, amount, dateTime, or_status, netTotal, stID) VALUES (?, ?, ?, NOW(), ?, ?, ?)\",\r\n                    [op_ID, orderId, receivedPayment, \"Issued\", netValue, stID]\r\n                );\r\n                await db.query(\r\n                    \"UPDATE order_payment SET or_status = ? WHERE orID = ?\",\r\n                    [\"Issued\", orderId]\r\n                );\r\n            } else {\r\n                await db.query(\r\n                    \"INSERT INTO order_payment (op_ID, orID, amount, dateTime, or_status, netTotal, stID) VALUES (?, ?, ?, NOW(), ?, ?, ?)\",\r\n                    [op_ID, orderId, receivedPayment, orderStatus, netValue, stID]\r\n                );\r\n            }\r\n\r\n            await db.query(\r\n                \"INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount) VALUES (?, ?, ?, NOW(), ?)\",\r\n                [\"Order payment\", op_ID, \"order\", receivedPayment]\r\n            );\r\n        }\r\n\r\n\r\n        if (orderStatus === \"Delivered\") {\r\n            await db.query(\"UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?\", [advance1 - deliveryCharge, stID]);\r\n\r\n            // \uD83E\uDDEE Extract year and month from deliveryDate (or current date if missing)\r\n            const dateObj = deliveryDate ? new Date(deliveryDate) : new Date();\r\n            const year = dateObj.getFullYear();\r\n            const month = dateObj.toLocaleString('default', { month: 'long' }); // e.g., 'May'\r\n\r\n            const netValue = (advance1 - deliveryCharge) - Loss;\r\n\r\n            // \uD83D\uDCCC Check if ST_order_review row exists\r\n            const [reviewRows] = await db.query(\r\n                \"SELECT * FROM ST_order_review WHERE stID = ? AND year = ? AND month = ?\",\r\n                [stID, year, month]\r\n            );\r\n\r\n            if (reviewRows.length > 0) {\r\n                // ✅ Update existing totalIssued\r\n                await db.query(\r\n                    \"UPDATE ST_order_review SET totalIssued = totalIssued + ? WHERE stID = ? AND year = ? AND month = ?\",\r\n                    [netValue, stID, year, month]\r\n                );\r\n            } else {\r\n                // \uD83C\uDD95 Insert new row\r\n                await db.query(\r\n                    \"INSERT INTO ST_order_review (stID, year, month, totalOrder, totalIssued) VALUES (?, ?, ?, 0, ?)\",\r\n                    [stID, year, month, netValue]\r\n                );\r\n            }\r\n        }\r\n\r\n        if (Loss !== 0) {\r\n            const op_ID1 = await generateNewId(\"order_payment\", \"op_ID\", \"OP\");\r\n            await db.query(\"INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount) VALUES (?, ?, ?, NOW(), ?)\", [\"Ignore Balance\", op_ID1, \"Loss\", -Loss]);\r\n        }\r\n\r\n        if (orderStatus === \"Returned\" || orderStatus === \"Cancelled\") {\r\n            const reasonTable = orderStatus === \"Returned\" ? \"return_orders\" : \"canceled_orders\";\r\n            await db.query(`INSERT INTO ${reasonTable} (orID, detail) VALUES (?, ?)`, [orID, reason]);\r\n        }\r\n\r\n        if (rescheduledDate !== null) {\r\n            await db.query(\"UPDATE Orders SET expectedDate = ? WHERE orID = ?\", [rescheduledDate, orderId]);\r\n            await db.query(\"UPDATE delivery SET schedule_Date = ? WHERE orID = ?\", [rescheduledDate, orderId]);\r\n        }\r\n\r\n        res.json({ success: true, message: \"Payment processed successfully.\", paymentStatus: payStatus });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error processing delivery payment:\", error);\r\n        res.status(500).json({ error: \"Internal server error\" });\r\n    }\r\n});\r\nrouter.post(\"/delivery-update\", async (req, res) => {\r\n    const {\r\n        deliveryStatus,\r\n        driverId,\r\n        deliveryDate,\r\n        orderId,\r\n        orderStatus,\r\n        issuedItems,\r\n        rescheduledDate\r\n    } = req.body;\r\n\r\n    try {\r\n        // Fetch order and required details\r\n        const [orderResult] = await db.query(\r\n            \"SELECT OrID, stID, netTotal FROM Orders WHERE OrID = ?\",\r\n            [orderId]\r\n        );\r\n\r\n        if (!orderResult.length) {\r\n            return res.status(404).json({ error: \"Order not found.\" });\r\n        }\r\n\r\n        const { OrID, stID, netTotal } = orderResult[0];\r\n        const orderNetTotal = Number(netTotal) || 0;\r\n\r\n        // Fetch delivery ID\r\n        const [deliveryData] = await db.query(\r\n            \"SELECT dv_id FROM delivery WHERE orID = ?\",\r\n            [orderId]\r\n        );\r\n        const dv_id = deliveryData?.[0]?.dv_id || null;\r\n\r\n        /** ------------------- Process Issued Items --------------------- */\r\n        if (issuedItems && Array.isArray(issuedItems)) {\r\n            for (const item of issuedItems) {\r\n                if (!item.I_Id || !item.stock_Id) continue;\r\n\r\n                const [itemData] = await db.query(\r\n                    \"SELECT status FROM p_i_detail WHERE I_Id = ? AND stock_Id = ?\",\r\n                    [item.I_Id, item.stock_Id]\r\n                );\r\n                const currentStatus = itemData?.[0]?.status || \"\";\r\n\r\n                if (currentStatus === \"Dispatched\") {\r\n                    await db.query(\r\n                        \"UPDATE p_i_detail SET status = 'Issued' WHERE I_Id = ? AND stock_Id = ?\",\r\n                        [item.I_Id, item.stock_Id]\r\n                    );\r\n                    await db.query(\r\n                        \"UPDATE Item SET dispatchedQty = dispatchedQty - 1, stockQty = stockQty - 1 WHERE I_Id = ?\",\r\n                        [item.itemId]\r\n                    );\r\n\r\n                    const [srdData] = await db.query(\r\n                        \"SELECT pid_Id FROM p_i_detail WHERE I_Id = ? AND stock_Id = ?\",\r\n                        [item.I_Id, item.stock_Id]\r\n                    );\r\n                    const srdId = srdData?.[0]?.pid_Id || null;\r\n\r\n                    if (srdId !== null) {\r\n                        await db.query(\r\n                            \"UPDATE issued_items SET status = 'Issued' WHERE pid_Id = ? AND orID = ?\",\r\n                            [srdId, orderId]\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /** ------------------- Update Order Status --------------------- */\r\n        const newOrderStatus = (orderStatus === \"Delivered\") ? \"Issued\" : orderStatus;\r\n\r\n        await db.query(\r\n            \"UPDATE Orders SET orStatus = ?, delStatus = ? WHERE OrID = ?\",\r\n            [newOrderStatus, deliveryStatus, orderId]\r\n        );\r\n\r\n        if (dv_id) {\r\n            await db.query(\r\n                \"UPDATE delivery SET delivery_Date = ?, status = ?, devID = ? WHERE dv_id = ?\",\r\n                [deliveryDate, deliveryStatus, driverId, dv_id]\r\n            );\r\n        }\r\n\r\n        /** ------------------- Update sales_team (add netTotal) --------------------- */\r\n        if (orderStatus === \"Delivered\" && stID) {\r\n            await db.query(\r\n                \"UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?\",\r\n                [orderNetTotal, stID]\r\n            );\r\n\r\n            // \uD83E\uDDEE Extract year and month from deliveryDate (or current date if missing)\r\n            const dateObj = deliveryDate ? new Date(deliveryDate) : new Date();\r\n            const year = dateObj.getFullYear();\r\n            const month = dateObj.toLocaleString('default', { month: 'long' }); // e.g., 'May'\r\n\r\n            // \uD83D\uDCCC Check if ST_order_review row exists\r\n            const [reviewRows] = await db.query(\r\n                \"SELECT * FROM ST_order_review WHERE stID = ? AND year = ? AND month = ?\",\r\n                [stID, year, month]\r\n            );\r\n\r\n            if (reviewRows.length > 0) {\r\n                // ✅ Update existing totalIssued\r\n                await db.query(\r\n                    \"UPDATE ST_order_review SET totalIssued = totalIssued + ? WHERE stID = ? AND year = ? AND month = ?\",\r\n                    [orderNetTotal, stID, year, month]\r\n                );\r\n            } else {\r\n                // \uD83C\uDD95 Insert new row\r\n                await db.query(\r\n                    \"INSERT INTO ST_order_review (stID, year, month, totalOrder, totalIssued) VALUES (?, ?, ?, 0, ?)\",\r\n                    [stID, year, month, orderNetTotal]\r\n                );\r\n            }\r\n        }\r\n\r\n        /** ------------------- Handle Rescheduling --------------------- */\r\n        if (rescheduledDate !== null) {\r\n            await db.query(\r\n                \"UPDATE Orders SET expectedDate = ? WHERE orID = ?\",\r\n                [rescheduledDate, orderId]\r\n            );\r\n            await db.query(\r\n                \"UPDATE delivery SET schedule_Date = ? WHERE orID = ?\",\r\n                [rescheduledDate, orderId]\r\n            );\r\n        }\r\n\r\n        /** ------------------- Update order_payment.or_status --------------------- */\r\n        await db.query(\r\n            \"UPDATE order_payment SET or_status = ? WHERE orID = ?\",\r\n            [orderStatus, orderId]\r\n        );\r\n\r\n        res.json({ success: true, message: \"Order, delivery, and payment status updated successfully.\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error processing delivery update:\", error);\r\n        res.status(500).json({ error: \"Internal server error\" });\r\n    }\r\n});\r\n\r\n// get delivery schdule by date\r\nrouter.get(\"/check-delivery\", async (req, res) => {\r\n    const { date } = req.query; // Get date from query parameter\r\n    if (!date) {\r\n        return res.status(400).json({ message: \"Date is required\" });\r\n    }\r\n\r\n    try {\r\n        // Check if the given date is already scheduled for delivery\r\n        const [result] = await db.query(\r\n            \"SELECT COUNT(*) AS count FROM delivery_schedule WHERE ds_date = ?\",\r\n            [date]\r\n        );\r\n\r\n        // Reverse the logic: if count is 0, delivery is available; otherwise, it's not available\r\n        const available = result[0].count === 0;\r\n\r\n        return res.status(200).json({\r\n            message: available ? \"Delivery available\" : \"No delivery available on this date\",\r\n            available: available\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error checking delivery availability:\", error.message);\r\n        return res.status(500).json({ message: \"Error checking delivery availability\" });\r\n    }\r\n});\r\n\r\n// Get total order count sum\r\nrouter.get(\"/sales/count\", async (req, res) => {\r\n    try {\r\n        // Get the current system date\r\n        const currentDate = new Date();\r\n        const formattedDate = currentDate.toISOString().split('T')[0]; // YYYY-MM-DD\r\n        const firstDayOfMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-01`;\r\n\r\n        // Query to get daily sales categorized into issued, returned, canceled, and other\r\n        const [dailySales] = await db.query(`\r\n            SELECT \r\n                sales_team.stID, \r\n                Employee.name AS salesperson_name, \r\n                COALESCE(SUM(CASE WHEN Orders.orStatus = 'issued' THEN Orders.netTotal - Orders.discount ELSE 0 END), 0) AS issued_sales,\r\n                COALESCE(SUM(CASE WHEN Orders.orStatus = 'returned' THEN Orders.netTotal - Orders.discount ELSE 0 END), 0) AS returned_sales,\r\n                COALESCE(SUM(CASE WHEN Orders.orStatus = 'canceled' THEN Orders.netTotal - Orders.discount ELSE 0 END), 0) AS canceled_sales,\r\n                COALESCE(SUM(CASE WHEN Orders.orStatus NOT IN ('issued', 'returned', 'canceled') THEN Orders.netTotal - Orders.discount ELSE 0 END), 0) AS other_sales\r\n            FROM sales_team\r\n            LEFT JOIN Orders ON sales_team.stID = Orders.stID AND Orders.orDate = ?\r\n            LEFT JOIN Employee ON sales_team.E_Id = Employee.E_Id\r\n            GROUP BY sales_team.stID, Employee.name;\r\n        `, [formattedDate]);\r\n\r\n        // Query to get monthly sales categorized into issued, returned, canceled, and other\r\n        const [monthlySales] = await db.query(`\r\n            SELECT \r\n                sales_team.stID, \r\n                Employee.name AS salesperson_name, \r\n                COALESCE(SUM(CASE WHEN Orders.orStatus = 'issued' THEN Orders.netTotal - Orders.discount ELSE 0 END), 0) AS issued_sales,\r\n                COALESCE(SUM(CASE WHEN Orders.orStatus = 'returned' THEN Orders.netTotal - Orders.discount ELSE 0 END), 0) AS returned_sales,\r\n                COALESCE(SUM(CASE WHEN Orders.orStatus = 'canceled' THEN Orders.netTotal - Orders.discount ELSE 0 END), 0) AS canceled_sales,\r\n                COALESCE(SUM(CASE WHEN Orders.orStatus NOT IN ('issued', 'returned', 'canceled') THEN Orders.netTotal - Orders.discount ELSE 0 END), 0) AS other_sales\r\n            FROM sales_team\r\n            LEFT JOIN Orders ON sales_team.stID = Orders.stID AND Orders.orDate BETWEEN ? AND ?\r\n            LEFT JOIN Employee ON sales_team.E_Id = Employee.E_Id\r\n            GROUP BY sales_team.stID, Employee.name;\r\n        `, [firstDayOfMonth, formattedDate]);\r\n\r\n        return res.status(200).json({\r\n            message: \"Daily and monthly sales totals fetched successfully.\",\r\n            data: {\r\n                dailySales,\r\n                monthlySales\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching sales total:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching sales total.\" });\r\n    }\r\n});\r\n\r\n// Get E_Id by contact number\r\nrouter.post('/get-eid-by-contact', async (req, res) => {\r\n    const { contact } = req.body;\r\n\r\n    if (!contact) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Contact number is required.\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        const [rows] = await db.query(`SELECT E_Id FROM user WHERE contact = ?`, [contact]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No user found with this contact number.\",\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            E_Id: rows[0].E_Id,\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching E_Id by contact:\", err);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Internal server error.\",\r\n        });\r\n    }\r\n});\r\n\r\n// Get new purchaseid\r\nrouter.get(\"/newPurchasenoteID\", async (req, res) => {\r\n    try {\r\n        const PurchaseID = await generateNewId(\"purchase\", \"pc_Id\", \"PC\"); // Generate new Purchase ID\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"PurchaseID fetched successfully.\",\r\n            PurchaseID\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching pc_Id:\", error);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching Purchase ID.\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n//Get details of purchase id\r\nrouter.get(\"/purchase-details\", async (req, res) => {\r\n    try {\r\n        const { pc_Id } = req.query;\r\n\r\n        if (!pc_Id) {\r\n            return res.status(400).json({ success: false, message: \"pc_Id is required\" });\r\n        }\r\n\r\n        // Fetch purchase record\r\n        const [purchase] = await db.query(\"SELECT * FROM purchase WHERE pc_Id = ?\", [pc_Id]);\r\n        if (purchase.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Purchase not found\" });\r\n        }\r\n\r\n        // Fetch purchase details\r\n        const [purchaseDetails] = await db.query(\r\n            \"SELECT * FROM purchase_detail WHERE pc_Id = ?\", [pc_Id]\r\n        );\r\n\r\n        // Fetch stock details\r\n        const [pIDetails] = await db.query(\r\n            \"SELECT * FROM p_i_detail WHERE pc_Id = ?\", [pc_Id]\r\n        );\r\n\r\n        // Fetch payment details\r\n        const [paymentDetails] = await db.query(\r\n            \"SELECT * FROM cash_balance WHERE ref = ?\", [pc_Id]\r\n        );\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            purchase: purchase[0],   // Single purchase record\r\n            purchaseDetails,         // Purchase item details\r\n            pIDetails,               // Stock-related details\r\n            paymentDetails           // Payment records\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching purchase details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Settle supplier payment\r\nrouter.post(\"/settle-payment\", async (req, res) => {\r\n    try {\r\n        const { pc_Id, amountPaid } = req.body;\r\n\r\n        if (!pc_Id || !amountPaid || amountPaid <= 0) {\r\n            return res.status(400).json({ success: false, message: \"Invalid payment details provided.\" });\r\n        }\r\n\r\n        const amount = Number(amountPaid);\r\n\r\n        // Fetch current pay & balance\r\n        const [purchaseResult] = await db.query(\"SELECT pay, balance FROM purchase WHERE pc_Id = ?\", [pc_Id]);\r\n\r\n        if (purchaseResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Purchase record not found.\" });\r\n        }\r\n\r\n        const { pay, balance } = purchaseResult[0];\r\n\r\n        if (balance < amount) {\r\n            return res.status(400).json({ success: false, message: \"Payment exceeds remaining balance.\" });\r\n        }\r\n\r\n        // Insert transaction into cash_balance (recording the payment)\r\n        const sql1 = `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount) VALUES (?, ?, ?, NOW(), ?)`;\r\n        const values1 = [\"Supplier Payment\", pc_Id, \"supplier\", -amount];\r\n        await db.query(sql1, values1);\r\n\r\n        // Update purchase table (pay & balance)\r\n        const sql2 = `UPDATE purchase SET pay = pay + ?, balance = balance - ? WHERE pc_Id = ?`;\r\n        await db.query(sql2, [amount, amount, pc_Id]);\r\n\r\n        // Fetch updated purchase details\r\n        const [updatedPurchase] = await db.query(\"SELECT s_ID,pay, balance FROM purchase WHERE pc_Id = ?\", [pc_Id]);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Payment settled successfully.\",\r\n            data: {\r\n                pc_Id,\r\n                amountPaid: amount,\r\n                newPay: updatedPurchase[0].pay,\r\n                newBalance: updatedPurchase[0].balance,\r\n                supplier: updatedPurchase[0].s_ID,\r\n            },\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error processing payment:\", err.message);\r\n        return res.status(500).json({ success: false, message: \"Server error while processing payment.\", error: err.message });\r\n    }\r\n});\r\n\r\n// Get Today sales income\r\nrouter.get(\"/today-order-income\", async (req, res) => {\r\n    try {\r\n        const today = new Date().toISOString().split(\"T\")[0];\r\n        const yesterday = new Date(Date.now() - 86400000).toISOString().split(\"T\")[0]; // 86400000 ms = 1 day\r\n\r\n        const sql = `\r\n            SELECT\r\n                IFNULL(SUM(CASE WHEN DATE(dateTime) = ? THEN amount END), 0) AS todayIncome,\r\n                IFNULL(SUM(CASE WHEN DATE(dateTime) = ? THEN amount END), 0) AS yesterdayIncome\r\n            FROM cash_balance\r\n            WHERE ref_type = 'order'\r\n        `;\r\n\r\n        const [rows] = await db.query(sql, [today, yesterday]);\r\n        const todayIncome = rows[0].todayIncome;\r\n        const yesterdayIncome = rows[0].yesterdayIncome;\r\n\r\n        const incomeIncreased = todayIncome > yesterdayIncome ? \"yes\" : \"no\";\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Today's order income retrieved successfully\",\r\n            data: {\r\n                totalIncome: todayIncome,\r\n                incomeIncreased: incomeIncreased,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching today's order income:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while retrieving income\",\r\n            error: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get Daily in & out order count\r\nrouter.get(\"/today-order-counts\", async (req, res) => {\r\n    try {\r\n        const today = new Date().toISOString().split(\"T\")[0];\r\n        const yesterday = new Date(Date.now() - 86400000).toISOString().split(\"T\")[0];\r\n\r\n        const sql = `\r\n            SELECT \r\n                -- Today\r\n                (SELECT IFNULL(SUM(CASE WHEN orStatus IN ('Pending', 'Accepted', 'Completed') THEN 1 ELSE 0 END), 0)\r\n                 FROM Orders WHERE orDate = ?) AS todayIn,\r\n\r\n                (SELECT IFNULL(SUM(CASE WHEN orStatus IN ('Issued', 'Delivered') THEN 1 ELSE 0 END), 0)\r\n                 FROM Orders WHERE orDate = ?) AS todayOut,\r\n\r\n                -- Yesterday\r\n                (SELECT IFNULL(SUM(CASE WHEN orStatus IN ('Pending', 'Accepted', 'Completed') THEN 1 ELSE 0 END), 0)\r\n                 FROM Orders WHERE orDate = ?) AS yesterdayIn,\r\n\r\n                (SELECT IFNULL(SUM(CASE WHEN orStatus IN ('Issued', 'Delivered') THEN 1 ELSE 0 END), 0)\r\n                 FROM Orders WHERE orDate = ?) AS yesterdayOut\r\n        `;\r\n\r\n        const [rows] = await db.query(sql, [today, today, yesterday, yesterday]);\r\n        const {\r\n            todayIn,\r\n            todayOut,\r\n            yesterdayIn,\r\n            yesterdayOut\r\n        } = rows[0];\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Today's IN/OUT order counts compared with yesterday\",\r\n            data: {\r\n                inOrders: todayIn,\r\n                outOrders: todayOut,\r\n                inOrdersIncreased: todayIn > yesterdayIn ? \"yes\" : \"no\",\r\n                outOrdersIncreased: todayOut > yesterdayOut ? \"yes\" : \"no\"\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error comparing today's order counts:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while retrieving order comparison\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\nrouter.get(\"/order-summary\", async (req, res) => {\r\n    try {\r\n        const today = moment().format(\"YYYY-MM-DD\");\r\n        const yesterday = moment().subtract(1, \"day\").format(\"YYYY-MM-DD\");\r\n\r\n        const startOfThisMonth = moment().startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const startOfLastMonth = moment().subtract(1, \"month\").startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const endOfLastMonth = moment().subtract(1, \"month\").endOf(\"month\").format(\"YYYY-MM-DD\");\r\n\r\n        const sql = `\r\n            SELECT\r\n                -- TODAY\r\n                (SELECT COUNT(*) FROM Orders WHERE orDate = ? AND orStatus IN ('Pending', 'Accepted', 'Completed')) AS todayInCount,\r\n                (SELECT IFNULL(SUM(netTotal), 0) FROM Orders WHERE orDate = ? AND orStatus IN ('Pending', 'Accepted', 'Completed')) AS todayInTotal,\r\n                (SELECT COUNT(*) FROM Orders WHERE orDate = ? AND orStatus IN ('Issued', 'Delivered')) AS todayOutCount,\r\n                (SELECT IFNULL(SUM(netTotal), 0) FROM Orders WHERE orDate = ? AND orStatus IN ('Issued', 'Delivered')) AS todayOutTotal,\r\n\r\n                -- YESTERDAY\r\n                (SELECT COUNT(*) FROM Orders WHERE orDate = ? AND orStatus IN ('Pending', 'Accepted', 'Completed')) AS yesterdayInCount,\r\n                (SELECT IFNULL(SUM(netTotal), 0) FROM Orders WHERE orDate = ? AND orStatus IN ('Pending', 'Accepted', 'Completed')) AS yesterdayInTotal,\r\n                (SELECT COUNT(*) FROM Orders WHERE orDate = ? AND orStatus IN ('Issued', 'Delivered')) AS yesterdayOutCount,\r\n                (SELECT IFNULL(SUM(netTotal), 0) FROM Orders WHERE orDate = ? AND orStatus IN ('Issued', 'Delivered')) AS yesterdayOutTotal,\r\n\r\n                -- THIS MONTH\r\n                (SELECT COUNT(*) FROM Orders WHERE orDate BETWEEN ? AND ? AND orStatus IN ('Pending', 'Accepted', 'Completed')) AS thisMonthInCount,\r\n                (SELECT IFNULL(SUM(netTotal), 0) FROM Orders WHERE orDate BETWEEN ? AND ? AND orStatus IN ('Pending', 'Accepted', 'Completed')) AS thisMonthInTotal,\r\n                (SELECT COUNT(*) FROM Orders WHERE orDate BETWEEN ? AND ? AND orStatus IN ('Issued', 'Delivered')) AS thisMonthOutCount,\r\n                (SELECT IFNULL(SUM(netTotal), 0) FROM Orders WHERE orDate BETWEEN ? AND ? AND orStatus IN ('Issued', 'Delivered')) AS thisMonthOutTotal,\r\n\r\n                -- LAST MONTH\r\n                (SELECT COUNT(*) FROM Orders WHERE orDate BETWEEN ? AND ? AND orStatus IN ('Pending', 'Accepted', 'Completed')) AS lastMonthInCount,\r\n                (SELECT IFNULL(SUM(netTotal), 0) FROM Orders WHERE orDate BETWEEN ? AND ? AND orStatus IN ('Pending', 'Accepted', 'Completed')) AS lastMonthInTotal,\r\n                (SELECT COUNT(*) FROM Orders WHERE orDate BETWEEN ? AND ? AND orStatus IN ('Issued', 'Delivered')) AS lastMonthOutCount,\r\n                (SELECT IFNULL(SUM(netTotal), 0) FROM Orders WHERE orDate BETWEEN ? AND ? AND orStatus IN ('Issued', 'Delivered')) AS lastMonthOutTotal\r\n        `;\r\n\r\n        const params = [\r\n            today, today, today, today,\r\n            yesterday, yesterday, yesterday, yesterday,\r\n            startOfThisMonth, today, startOfThisMonth, today,\r\n            startOfThisMonth, today, startOfThisMonth, today,\r\n            startOfLastMonth, endOfLastMonth, startOfLastMonth, endOfLastMonth,\r\n            startOfLastMonth, endOfLastMonth, startOfLastMonth, endOfLastMonth\r\n        ];\r\n\r\n        const [rows] = await db.query(sql, params);\r\n        const r = rows[0];\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Today's and this month's order summary with comparisons\",\r\n            today: {\r\n                in: { count: r.todayInCount, total: r.todayInTotal },\r\n                out: { count: r.todayOutCount, total: r.todayOutTotal },\r\n                compare: {\r\n                    inIncreased: r.todayInCount > r.yesterdayInCount ? \"yes\" : \"no\",\r\n                    outIncreased: r.todayOutCount > r.yesterdayOutCount ? \"yes\" : \"no\"\r\n                }\r\n            },\r\n            thisMonth: {\r\n                in: { count: r.thisMonthInCount, total: r.thisMonthInTotal },\r\n                out: { count: r.thisMonthOutCount, total: r.thisMonthOutTotal },\r\n                compare: {\r\n                    inIncreased: r.thisMonthInCount > r.lastMonthInCount ? \"yes\" : \"no\",\r\n                    outIncreased: r.thisMonthOutCount > r.lastMonthOutCount ? \"yes\" : \"no\"\r\n                }\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching order summary:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while fetching summary\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get advance and loan amount for a month by employee id\r\nrouter.get(\"/advance&loan\", async (req, res) => {\r\n    try {\r\n        const { eid } = req.query;\r\n\r\n        if (!eid) {\r\n            return res.status(400).json({ success: false, message: \"Employee ID (eid) is required\" });\r\n        }\r\n\r\n        const startOfMonth = moment().startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const endOfMonth = moment().endOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const startOfLastMonth = moment().subtract(1, \"months\").startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const endOfLastMonth = moment().subtract(1, \"months\").endOf(\"month\").format(\"YYYY-MM-DD\");\r\n\r\n        // Salary Advances (Current Month)\r\n        const [advances] = await db.query(\r\n            \"SELECT * FROM salary_advance WHERE E_Id = ? AND dateTime BETWEEN ? AND ?\",\r\n            [eid, startOfMonth, endOfMonth]\r\n        );\r\n\r\n        // Unpaid Loan Installment from Last Month\r\n        const [lastMonthLoan] = await db.query(\r\n            `SELECT d.*, l.skip, l.E_Id\r\n             FROM sal_loan_detail d\r\n             JOIN salary_loan l ON d.sl_ID = l.sl_ID\r\n             WHERE l.E_Id = ? \r\n               AND l.status = 'Unfinished'\r\n               AND d.status = 'Unpaid'\r\n               AND d.date BETWEEN ? AND ?\r\n             ORDER BY d.date ASC\r\n             LIMIT 1`,\r\n            [eid, startOfLastMonth, endOfLastMonth]\r\n        );\r\n\r\n        const advancePayments = advances.map(adv => ({\r\n            ...adv,\r\n            dateTime: moment(adv.dateTime).format(\"YYYY-MM-DD\")\r\n        }));\r\n\r\n        const lastMonthUnpaidInstallment = lastMonthLoan.length > 0\r\n            ? {\r\n                id: lastMonthLoan[0].Id,\r\n                date: moment(lastMonthLoan[0].date).format(\"YYYY-MM-DD\"),\r\n                installment: lastMonthLoan[0].installment,\r\n                sl_ID: lastMonthLoan[0].sl_ID,\r\n                skip: lastMonthLoan[0].skip,\r\n                E_Id: lastMonthLoan[0].E_Id\r\n            }\r\n            : {\r\n                id: 0,\r\n                date: null,\r\n                installment: 0,\r\n                sl_ID: null,\r\n                skip: 0,\r\n                E_Id: eid\r\n            };\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            advancePayments,\r\n            lastMonthUnpaidInstallment\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching salary payments:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get leave count for a month by employee id\r\nrouter.get(\"/leave-count\", async (req, res) => {\r\n    try {\r\n        const { eid } = req.query;\r\n\r\n        if (!eid) {\r\n            return res.status(400).json({ success: false, message: \"Employee ID (eid) is required\" });\r\n        }\r\n\r\n        // Last month's start and end dates\r\n        const startOfLastMonth = moment().subtract(1, 'months').startOf('month').format('YYYY-MM-DD');\r\n        const endOfLastMonth = moment().subtract(1, 'months').endOf('month').format('YYYY-MM-DD');\r\n\r\n        // Get informed and uninformed leaves where present is not 'In'\r\n        const [leaveCounts] = await db.query(`\r\n            SELECT leave_type, COUNT(*) AS count\r\n            FROM emp_leaves\r\n            WHERE \r\n                E_Id = ? \r\n                AND date BETWEEN ? AND ? \r\n                AND present != 'In'\r\n                AND leave_type IN ('Informed', 'Uninformed')\r\n            GROUP BY leave_type\r\n        `, [eid, startOfLastMonth, endOfLastMonth]);\r\n\r\n        let informedCount = 0;\r\n        let uninformedCount = 0;\r\n\r\n        leaveCounts.forEach(leave => {\r\n            if (leave.leave_type === \"Informed\") {\r\n                informedCount = leave.count;\r\n            } else if (leave.leave_type === \"Uninformed\") {\r\n                uninformedCount = leave.count;\r\n            }\r\n        });\r\n\r\n        const totalLeave = informedCount + uninformedCount;\r\n        const deduction = (informedCount * 1000) + (uninformedCount * 2000);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            informedLeave: informedCount,\r\n            uninformedLeave: uninformedCount,\r\n            totalLeave,\r\n            attendanceDeduction: deduction\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error counting leaves:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get driver hire summary\r\nrouter.get(\"/hire-summary\", async (req, res) => {\r\n    try {\r\n        const { eid } = req.query;\r\n\r\n        if (!eid) {\r\n            return res.status(400).json({ success: false, message: \"Employee ID (eid) is required\" });\r\n        }\r\n\r\n        const [driverResult] = await db.query(\"SELECT devID,balance FROM driver WHERE E_ID = ?\", [eid]);\r\n        if (!driverResult.length) {\r\n            return res.status(404).json({ success: false, message: \"Driver not found for given E_ID\" });\r\n        }\r\n\r\n        const { devID, balance } = driverResult[0];\r\n\r\n        // const startOfLastMonth = moment().subtract(1, 'months').startOf('month').format('YYYY-MM-DD');\r\n        // const endOfLastMonth = moment().subtract(1, 'months').endOf('month').format('YYYY-MM-DD');\r\n        const startOfLastMonth = moment().startOf('month').format('YYYY-MM-DD');\r\n        const endOfLastMonth = moment().endOf('month').format('YYYY-MM-DD');\r\n\r\n\r\n        const [hireRows] = await db.query(\r\n            `SELECT date, SUM(hire) AS total\r\n             FROM otherHire\r\n             WHERE driverId = ? AND date BETWEEN ? AND ?\r\n             GROUP BY date`,\r\n            [devID, startOfLastMonth, endOfLastMonth]\r\n        );\r\n\r\n        const [deliveryRows] = await db.query(\r\n            `SELECT date, SUM(hire) AS total\r\n             FROM delivery_note\r\n             WHERE devID = ? AND date BETWEEN ? AND ?\r\n             GROUP BY date`,\r\n            [devID, startOfLastMonth, endOfLastMonth]\r\n        );\r\n\r\n        const [bonusRates] = await db.query(\r\n            `SELECT targetRate, bonus, type FROM delivery_target_bonus`\r\n        );\r\n\r\n        let lastMonthHireTotal = 0;\r\n        let lastMonthDeliveryTotal = 0;\r\n        const dailyMap = {};\r\n\r\n        hireRows.forEach(row => {\r\n            const day = new Date(row.date).getDate();\r\n            const total = parseFloat(row.total || 0);\r\n            lastMonthHireTotal += total;\r\n            dailyMap[day] = (dailyMap[day] || 0) + total;\r\n        });\r\n\r\n        deliveryRows.forEach(row => {\r\n            const day = new Date(row.date).getDate();\r\n            const total = parseFloat(row.total || 0);\r\n            lastMonthDeliveryTotal += total;\r\n            dailyMap[day] = (dailyMap[day] || 0) + total;\r\n        });\r\n\r\n        // Daily Summary with bonus\r\n        const dailySummary = Object.entries(dailyMap).map(([day, total]) => {\r\n            const totalNum = parseFloat(total.toFixed(2));\r\n            const dailyBonus = bonusRates\r\n                .filter(rate => rate.type === \"Daily\" && totalNum >= rate.targetRate)\r\n                .sort((a, b) => b.targetRate - a.targetRate)[0];\r\n\r\n            return {\r\n                day: parseInt(day),\r\n                total: totalNum,\r\n                bonus: dailyBonus ? dailyBonus.bonus : 0\r\n            };\r\n        }).sort((a, b) => a.day - b.day);\r\n\r\n        const totalMonthlyEarnings = lastMonthHireTotal + lastMonthDeliveryTotal;\r\n\r\n        // Monthly bonus\r\n        const monthlyBonus = bonusRates\r\n            .filter(rate => rate.type === \"Monthly\" && totalMonthlyEarnings >= rate.targetRate)\r\n            .sort((a, b) => b.targetRate - a.targetRate)[0];\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            devID,balance:parseFloat(balance.toFixed(2)),\r\n            lastMonthHireTotal: parseFloat(lastMonthHireTotal.toFixed(2)),\r\n            lastMonthDeliveryTotal: parseFloat(lastMonthDeliveryTotal.toFixed(2)),\r\n            totalMonthlyEarnings: parseFloat(totalMonthlyEarnings.toFixed(2)),\r\n            monthlyBonus: monthlyBonus ? {\r\n                targetRate: monthlyBonus.targetRate,\r\n                bonus: monthlyBonus.bonus\r\n            } : null,\r\n            dailySummary\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error generating hire summary:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get sale-team order payment summary\r\nrouter.get(\"/sales-summary\", async (req, res) => {\r\n    try {\r\n        const { eid } = req.query;\r\n        if (!eid) {\r\n            return res.status(400).json({ success: false, message: \"eid is required\" });\r\n        }\r\n\r\n        // 1. Get stID and targets from sales_team\r\n        const [teamRows] = await db.query(\r\n            `SELECT stID, orderTarget, issuedTarget FROM sales_team WHERE E_Id = ?`,\r\n            [eid]\r\n        );\r\n\r\n        if (teamRows.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Sales team member not found for given eid\" });\r\n        }\r\n\r\n        const { stID, orderTarget, issuedTarget } = teamRows[0];\r\n\r\n        // 2. Get last month year + name\r\n        const now = moment();\r\n        const lastMonthYear = now.year(); // e.g., 2025\r\n        const lastMonthName = now.format(\"MMMM\"); // e.g., \"June\"\r\n\r\n        // 3. Get order review data\r\n        const [reviewRows] = await db.query(\r\n            `SELECT totalOrder, totalIssued FROM ST_order_review WHERE stID = ? AND year = ? AND month = ?`,\r\n            [stID, lastMonthYear, lastMonthName]\r\n        );\r\n\r\n        if (reviewRows.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No order review found for last month\" });\r\n        }\r\n\r\n        const { totalOrder, totalIssued } = reviewRows[0];\r\n\r\n        // 4. Get OrdersIn Target bonus\r\n        let orderBonus = 0;\r\n        if (totalOrder > orderTarget) {\r\n            const [bonusRow] = await db.query(\r\n                `SELECT bonus FROM sale_target WHERE targetType = 'OrdersIn Target' LIMIT 1`\r\n            );\r\n            if (bonusRow.length) {\r\n                orderBonus = bonusRow[0].bonus;\r\n            }\r\n        }\r\n\r\n        // 5. Get Issued Target bonus from order_target_bonus\r\n        let issuedBonus = 0;\r\n        const [issuedBonusRows] = await db.query(\r\n            `SELECT bonus FROM order_target_bonus WHERE targetRate <= ? ORDER BY targetRate DESC LIMIT 1`,\r\n            [totalIssued]\r\n        );\r\n        if (issuedBonusRows.length > 0) {\r\n            issuedBonus = issuedBonusRows[0].bonus;\r\n        }\r\n\r\n        // 6. Check if this user has highest issued among all STs that month\r\n        const [allIssuedRows] = await db.query(\r\n            `SELECT stID, totalIssued FROM ST_order_review WHERE year = ? AND month = ?`,\r\n            [lastMonthYear, lastMonthName]\r\n        );\r\n\r\n        let highestBonus = 0;\r\n        if (allIssuedRows.length > 0) {\r\n            // There are other sales team members, find the highest issued value\r\n            const maxIssued = Math.max(...allIssuedRows.map(row => row.totalIssued));\r\n\r\n            if (totalIssued === maxIssued) {\r\n                // If this user has the highest issued, get the bonus\r\n                const [highBonusRows] = await db.query(\r\n                    `SELECT bonus FROM sale_target WHERE targetType = 'Highest Target' LIMIT 1`\r\n                );\r\n                if (highBonusRows.length > 0) {\r\n                    highestBonus = highBonusRows[0].bonus;\r\n                }\r\n            }\r\n        } else {\r\n            // If no other sales team members, assign the highest bonus to this user\r\n            const [highBonusRows] = await db.query(\r\n                `SELECT bonus FROM sale_target WHERE targetType = 'Highest Target' LIMIT 1`\r\n            );\r\n            if (highBonusRows.length > 0) {\r\n                highestBonus = highBonusRows[0].bonus;\r\n            }\r\n        }\r\n\r\n        // Total Bonus\r\n        const totalBonus = parseFloat((orderBonus + issuedBonus + highestBonus).toFixed(2));\r\n\r\n        // 7. Final Response\r\n        return res.status(200).json({\r\n            success: true,\r\n            eid,\r\n            stID,\r\n            year: lastMonthYear,\r\n            month: lastMonthName,\r\n            totalOrder: parseFloat(totalOrder.toFixed(2)),\r\n            totalIssued: parseFloat(totalIssued.toFixed(2)),\r\n            orderTarget,\r\n            issuedTarget,\r\n            bonuses: {\r\n                orderBonus,\r\n                issuedBonus,\r\n                highestBonus,\r\n                totalBonus\r\n            }\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Sales summary error:\", err.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: err.message });\r\n    }\r\n});\r\n\r\n//  Get Sales Team Targets\r\nrouter.get(\"/sales-team-targets\", async (req, res) => {\r\n    try {\r\n        const [results] = await db.query(`\r\n            SELECT st.stID, st.E_Id, emp.name, st.orderTarget, st.issuedTarget\r\n            FROM sales_team st\r\n            JOIN employee emp ON st.E_Id = emp.E_Id\r\n        `);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            salesTeam: results\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching sales team targets:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get Driver's Targets\r\nrouter.get(\"/drivers-targets\", async (req, res) => {\r\n    try {\r\n        const [results] = await db.query(`\r\n            SELECT d.devID, d.E_ID, emp.name, d.dailyTarget, d.monthlyTarget\r\n            FROM driver d\r\n            JOIN Employee emp ON d.E_ID = emp.E_Id\r\n        `);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            drivers: results\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching driver targets:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save leave form\r\nrouter.post(\"/add-leave\", async (req, res) => {\r\n    try {\r\n        const { id, date, type, reason } = req.body;\r\n\r\n        if (!id || !date || !type || !reason) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"Missing required fields (id, date, type, reason)\"\r\n            });\r\n        }\r\n\r\n        // Format the date for SQL DATETIME\r\n        const formattedDate = moment(date).format(\"YYYY-MM-DD HH:mm:ss\");\r\n\r\n        // Insert into Emp_leaves\r\n        await db.query(\r\n            \"INSERT INTO Emp_leaves (E_Id, date, leave_type,duration_type, reason,status,present) VALUES (?, ?, 'Uninformed', ?,?,'Applied','Out')\",\r\n            [id, formattedDate, type, reason]\r\n        );\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Leave successfully recorded\"\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error adding leave:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get All Applied Leaves\r\nrouter.get(\"/applied-leaves\", async (req, res) => {\r\n    try {\r\n        const query = `\r\n            SELECT\r\n                el.id, el.E_Id, e.name, el.date, el.leave_type, el.duration_type, el.reason, el.status\r\n            FROM Emp_leaves el\r\n                     JOIN Employee e ON el.E_Id = e.E_Id\r\n            WHERE el.status = 'Applied'\r\n            ORDER BY el.date DESC\r\n        `;\r\n\r\n        const [leaves] = await db.query(query);\r\n        const count = leaves.length;\r\n\r\n        if (count === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No applied leaves found\",\r\n                count: 0,\r\n                data: []\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Applied leaves fetched successfully\",\r\n            count,\r\n            data: leaves\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching applied leaves:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get Applied Leaves and Pending Requests\r\nrouter.get(\"/applied-leaves-and-requests\", async (req, res) => {\r\n    try {\r\n        // Fetch Applied Leaves\r\n        const leavesQuery = `\r\n            SELECT\r\n                el.id, el.E_Id, e.name, el.date, el.leave_type, el.duration_type, el.reason, el.status\r\n            FROM Emp_leaves el\r\n            JOIN Employee e ON el.E_Id = e.E_Id\r\n            WHERE el.status = 'Applied'\r\n            ORDER BY el.date DESC\r\n        `;\r\n\r\n        const [appliedLeaves] = await db.query(leavesQuery);\r\n\r\n        // Fetch Pending Requests\r\n        const requestsQuery = `\r\n            SELECT\r\n                r.id, r.E_Id, e.name, r.reason, r.status\r\n            FROM Request r\r\n            JOIN Employee e ON r.E_Id = e.E_Id\r\n            WHERE r.status = 'Pending'\r\n            ORDER BY r.id DESC\r\n        `;\r\n\r\n        const [pendingRequests] = await db.query(requestsQuery);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Fetched applied leaves and pending requests\",\r\n            data: {\r\n                appliedLeaves,\r\n                pendingRequests\r\n            },\r\n            counts: {\r\n                appliedLeaves: appliedLeaves.length,\r\n                pendingRequests: pendingRequests.length\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching applied leaves and pending requests:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Approve a leave by ID\r\nrouter.put(\"/approve-leave/:id\", async (req, res) => {\r\n    try {\r\n        const leaveId = req.params.id;\r\n\r\n        const [result] = await db.query(\r\n            \"UPDATE Emp_leaves SET leave_type = 'Informed', status = 'Approved' WHERE id = ?\",\r\n            [leaveId]\r\n        );\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"Leave not found or already approved\",\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Leave approved successfully\",\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error approving leave:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Rejected a leave by id\r\nrouter.put(\"/reject-leave/:id\", async (req, res) => {\r\n    try {\r\n        const leaveId = req.params.id;\r\n\r\n        const [result] = await db.query(\r\n            \"UPDATE Emp_leaves SET leave_type = 'Uninformed', status = 'Rejected' WHERE id = ?\",\r\n            [leaveId]\r\n        );\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"Leave not found or already Rejected\",\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Leave Rejected successfully\",\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error approving leave:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get This Month's Leaves for an Employee\r\nrouter.get(\"/monthly-leaves/:id\", async (req, res) => {\r\n    try {\r\n        const { id } = req.params;\r\n\r\n        // Get first and last day of the current month\r\n        const startOfMonth = moment().startOf('month').format('YYYY-MM-DD');\r\n        const endOfMonth = moment().endOf('month').format('YYYY-MM-DD');\r\n\r\n        const query = `\r\n            SELECT id, E_Id, date, leave_type, duration_type, reason, status\r\n            FROM Emp_leaves\r\n            WHERE E_Id = ?\r\n              AND date BETWEEN ? AND ?\r\n            ORDER BY date DESC\r\n        `;\r\n\r\n        const [leaves] = await db.query(query, [id, startOfMonth, endOfMonth]);\r\n\r\n        res.status(200).json({\r\n            success: true,\r\n            message: \"Monthly leaves fetched successfully\",\r\n            data: leaves,\r\n            count: leaves.length\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching monthly leaves:\", error.message);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save a new order target\r\nrouter.post(\"/order-targets\", async (req, res) => {\r\n    try {\r\n        const { target, bonus } = req.body;\r\n\r\n        if (!target || !bonus) {\r\n            return res.status(400).json({ success: false, message: \"Target and bonus are required\" });\r\n        }\r\n\r\n        await db.query(\r\n            \"INSERT INTO order_target_bonus (targetRate, bonus) VALUES (?, ?)\",\r\n            [target, bonus]\r\n        );\r\n\r\n        return res.status(200).json({ success: true, message: \"Target added successfully\" });\r\n    } catch (error) {\r\n        console.error(\"Error saving target:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save a new sale target\r\nrouter.post(\"/sale-targets\", async (req, res) => {\r\n    try {\r\n        const { target, bonus } = req.body;\r\n\r\n        if (!target || !bonus) {\r\n            return res.status(400).json({ success: false, message: \"Target and bonus are required\" });\r\n        }\r\n\r\n        await db.query(\r\n            \"INSERT INTO sale_target (targetType, bonus) VALUES (?, ?)\",\r\n            [target, bonus]\r\n        );\r\n\r\n        return res.status(200).json({ success: true, message: \"Target added successfully\" });\r\n    } catch (error) {\r\n        console.error(\"Error saving target:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save a new delivery target\r\nrouter.post(\"/delivery-target\", async (req, res) => {\r\n    try {\r\n        const { target, bonus, type } = req.body;\r\n\r\n        if (!target || !bonus || !type) {\r\n            return res.status(400).json({ success: false, message: \"Target, bonus, and type are required\" });\r\n        }\r\n\r\n        await db.query(\r\n            \"INSERT INTO delivery_target_bonus (targetRate, bonus, type) VALUES (?, ?, ?)\",\r\n            [parseFloat(target), parseFloat(bonus), type]\r\n        );\r\n\r\n        return res.status(200).json({ success: true, message: \"Delivery target bonus added successfully\" });\r\n    } catch (error) {\r\n        console.error(\"Error saving delivery target bonus:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n//Get all order targets bonus\r\nrouter.get(\"/order-targets\", async (req, res) => {\r\n    try {\r\n        const [targets] = await db.query(\"SELECT id, targetRate AS target, bonus FROM order_target_bonus\");\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            targets\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching targets:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// GEt all delivery target bonus\r\nrouter.get(\"/delivery-targets\", async (req, res) => {\r\n    try {\r\n        const [targets] = await db.query(\r\n            \"SELECT id, targetRate AS target, bonus, type FROM delivery_target_bonus\"\r\n        );\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            targets\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching delivery targets:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Update sale team target values\r\nrouter.put(\"/update-sales-target\", async (req, res) => {\r\n    try {\r\n        const { stID, totalOrder, totalIssued } = req.body;\r\n\r\n        if (!stID || totalOrder == null || totalIssued == null) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        const [result] = await db.query(\r\n            `UPDATE sales_team\r\n             SET orderTarget = ?, issuedTarget = ?\r\n             WHERE stID = ?`,\r\n            [parseFloat(totalOrder), parseFloat(totalIssued), stID]\r\n        );\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({ success: false, message: \"Sales team member not found\" });\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Sales target updated successfully\" });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error updating sales target:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Update driver target values\r\nrouter.put(\"/update-driver-target\", async (req, res) => {\r\n    try {\r\n        const { devID, dailyTarget, monthlyTarget } = req.body;\r\n\r\n        if (!devID || dailyTarget == null || monthlyTarget == null) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"Missing required fields\"\r\n            });\r\n        }\r\n\r\n        const [result] = await db.query(\r\n            `UPDATE driver\r\n             SET dailyTarget = ?, monthlyTarget = ?\r\n             WHERE devID = ?`,\r\n            [parseFloat(dailyTarget), parseFloat(monthlyTarget), devID]\r\n        );\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"Driver not found\"\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Driver target updated successfully\"\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error updating driver target:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Server error\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Summing Total salling price of items for each category\r\nrouter.get(\"/monthly-issued-material-prices\", async (req, res) => {\r\n    try {\r\n        const startOfThisMonth = moment().startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const endOfThisMonth = moment().endOf(\"month\").format(\"YYYY-MM-DD\");\r\n\r\n        const startOfLastMonth = moment().subtract(1, \"month\").startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const endOfLastMonth = moment().subtract(1, \"month\").endOf(\"month\").format(\"YYYY-MM-DD\");\r\n\r\n        const sql = `\r\n            SELECT\r\n                materialGroup,\r\n                SUM(tprice) AS totalPrice\r\n            FROM (\r\n                SELECT \r\n                    CASE\r\n                        WHEN material IN ('Teak', 'Mahogani', 'Mara', 'Attoriya', 'Sapu') THEN 'Furniture'\r\n                        ELSE material\r\n                    END AS materialGroup,\r\n                    tprice,\r\n                    o.orDate\r\n                FROM Order_Detail od\r\n                JOIN Orders o ON od.orID = o.orID\r\n                WHERE o.orDate IS NOT NULL\r\n            ) AS sub\r\n            WHERE DATE(orDate) BETWEEN ? AND ?\r\n            GROUP BY materialGroup\r\n        `;\r\n\r\n        const [thisMonthRows] = await db.query(sql, [startOfThisMonth, endOfThisMonth]);\r\n        const [lastMonthRows] = await db.query(sql, [startOfLastMonth, endOfLastMonth]);\r\n\r\n        const toPriceMap = (rows) =>\r\n            rows.reduce((acc, row) => {\r\n                acc[row.materialGroup] = parseFloat(row.totalPrice || 0);\r\n                return acc;\r\n            }, {});\r\n\r\n        const thisMonthMap = toPriceMap(thisMonthRows);\r\n        const lastMonthMap = toPriceMap(lastMonthRows);\r\n\r\n        const materials = ['MDF', 'MM', 'Mattress', 'Furniture'];\r\n\r\n        const data = materials.map(material => {\r\n            const current = thisMonthMap[material] || 0;\r\n            const previous = lastMonthMap[material] || 0;\r\n            return {\r\n                material,\r\n                totalPrice: current,\r\n                lastMonthTotal: previous,\r\n                increased: current > previous ? \"yes\" : \"no\"\r\n            };\r\n        });\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Monthly issued material total price comparison\",\r\n            data,\r\n            // Optionally keep backward-compatible format:\r\n            MDF: [data.find(d => d.material === 'MDF')],\r\n            MM: [data.find(d => d.material === 'MM')],\r\n            Mattress: [data.find(d => d.material === 'Mattress')],\r\n            Furniture: [data.find(d => d.material === 'Furniture')]\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error retrieving material prices:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while retrieving material price comparison\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get Monthly Net Total for walking and onsite orders\r\nrouter.get(\"/monthly-net-total-summary\", async (req, res) => {\r\n    try {\r\n        const startOfThisMonth = moment().startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const startOfLastMonth = moment().subtract(1, \"month\").startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const endOfLastMonth = moment().subtract(1, \"month\").endOf(\"month\").format(\"YYYY-MM-DD\");\r\n\r\n        const sql = `\r\n            SELECT\r\n                -- This month net total for walking orders\r\n                (SELECT IFNULL(SUM(netTotal), 0) \r\n                 FROM Orders \r\n                 WHERE orDate BETWEEN ? AND ? \r\n                 AND ordertype = 'walking' \r\n                 AND orStatus != 'cancel') AS thisMonthWalkingTotal,\r\n                 \r\n                -- This month net total for onsite orders\r\n                (SELECT IFNULL(SUM(netTotal), 0) \r\n                 FROM Orders \r\n                 WHERE orDate BETWEEN ? AND ? \r\n                 AND ordertype = 'On-site' \r\n                 AND orStatus != 'cancel') AS thisMonthOnsiteTotal,\r\n                 \r\n                -- Last month net total for walking orders\r\n                (SELECT IFNULL(SUM(netTotal), 0) \r\n                 FROM Orders \r\n                 WHERE orDate BETWEEN ? AND ? \r\n                 AND ordertype = 'walking' \r\n                 AND orStatus != 'cancel') AS lastMonthWalkingTotal,\r\n                 \r\n                -- Last month net total for onsite orders\r\n                (SELECT IFNULL(SUM(netTotal), 0) \r\n                 FROM Orders \r\n                 WHERE orDate BETWEEN ? AND ? \r\n                 AND ordertype = 'On-site' \r\n                 AND orStatus != 'cancel') AS lastMonthOnsiteTotal\r\n        `;\r\n\r\n        const [rows] = await db.query(sql, [\r\n            startOfThisMonth, moment().format(\"YYYY-MM-DD\"),\r\n            startOfThisMonth, moment().format(\"YYYY-MM-DD\"),\r\n            startOfLastMonth, endOfLastMonth,\r\n            startOfLastMonth, endOfLastMonth\r\n        ]);\r\n\r\n        const result = rows[0];\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Monthly net total comparison for walking and onsite orders\",\r\n            walking: {\r\n                thisMonthTotal: result.thisMonthWalkingTotal,\r\n                lastMonthTotal: result.lastMonthWalkingTotal,\r\n                compare: {\r\n                    increased: result.thisMonthWalkingTotal > result.lastMonthWalkingTotal ? \"yes\" : \"no\"\r\n                }\r\n            },\r\n            onsite: {\r\n                thisMonthTotal: result.thisMonthOnsiteTotal,\r\n                lastMonthTotal: result.lastMonthOnsiteTotal,\r\n                compare: {\r\n                    increased: result.thisMonthOnsiteTotal > result.lastMonthOnsiteTotal ? \"yes\" : \"no\"\r\n                }\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching monthly net total summary:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while fetching monthly net total data\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get sales team monthly order summary for current year\r\nrouter.get(\"/sales-team-monthly-summary\", async (req, res) => {\r\n    try {\r\n        const currentYear = new Date().getFullYear();\r\n\r\n        const sql = `\r\n            SELECT\r\n                s.stID,\r\n                e.name AS employeeName,\r\n                sr.month,\r\n                sr.totalOrder,\r\n                sr.totalIssued\r\n            FROM ST_order_review sr\r\n            INNER JOIN sales_team s ON sr.stID = s.stID\r\n            INNER JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE sr.year = ?\r\n            ORDER BY s.stID, sr.month\r\n        `;\r\n\r\n        const [rows] = await db.query(sql, [currentYear]);\r\n\r\n        // Group by sales team member\r\n        const result = {};\r\n\r\n        rows.forEach(row => {\r\n            if (!result[row.stID]) {\r\n                result[row.stID] = {\r\n                    employeeName: row.employeeName,\r\n                    stID: row.stID,\r\n                    monthlyData: []\r\n                };\r\n            }\r\n            result[row.stID].monthlyData.push({\r\n                month: row.month,\r\n                totalOrder: row.totalOrder,\r\n                totalIssued: row.totalIssued\r\n            });\r\n        });\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Monthly summary of orders and issues for each sales team member\",\r\n            data: Object.values(result)\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"❌ Error fetching sales team monthly summary:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while fetching sales team monthly data\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get Total hire daily & monthly\r\nrouter.get(\"/monthly-hire-summary\", async (req, res) => {\r\n    try {\r\n        const today = moment().format(\"YYYY-MM-DD\");\r\n        const yesterday = moment().subtract(1, \"day\").format(\"YYYY-MM-DD\");\r\n        const startOfThisMonth = moment().startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const startOfLastMonth = moment().subtract(1, \"month\").startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const endOfLastMonth = moment().subtract(1, \"month\").endOf(\"month\").format(\"YYYY-MM-DD\");\r\n\r\n        const sql = `\r\n            SELECT\r\n                -- Today Hire Total\r\n                (\r\n                    (SELECT IFNULL(SUM(hire), 0) FROM delivery_note \r\n                     WHERE date = ? AND status = 'complete')\r\n                    +\r\n                    (SELECT IFNULL(SUM(payment), 0) FROM otherHire \r\n                     WHERE bookingDate = ? AND status = 'Done')\r\n                ) AS todayHire,\r\n\r\n                -- Yesterday Hire Total\r\n                (\r\n                    (SELECT IFNULL(SUM(hire), 0) FROM delivery_note \r\n                     WHERE date = ? AND status = 'complete')\r\n                    +\r\n                    (SELECT IFNULL(SUM(payment), 0) FROM otherHire \r\n                     WHERE bookingDate = ? AND status = 'Done')\r\n                ) AS yesterdayHire,\r\n\r\n                -- This Month Total\r\n                (\r\n                    (SELECT IFNULL(SUM(hire), 0) FROM delivery_note \r\n                     WHERE date BETWEEN ? AND ? AND status = 'complete')\r\n                    +\r\n                    (SELECT IFNULL(SUM(payment), 0) FROM otherHire \r\n                     WHERE bookingDate BETWEEN ? AND ? AND status = 'Done')\r\n                ) AS thisMonthHire,\r\n\r\n                -- Last Month Total\r\n                (\r\n                    (SELECT IFNULL(SUM(hire), 0) FROM delivery_note \r\n                     WHERE date BETWEEN ? AND ? AND status = 'complete')\r\n                    +\r\n                    (SELECT IFNULL(SUM(payment), 0) FROM otherHire \r\n                     WHERE bookingDate BETWEEN ? AND ? AND status = 'Done')\r\n                ) AS lastMonthHire\r\n        `;\r\n\r\n        const [rows] = await db.query(sql, [\r\n            today, today,           // Today's\r\n            yesterday, yesterday,   // Yesterday's\r\n            startOfThisMonth, today, startOfThisMonth, today,   // This Month\r\n            startOfLastMonth, endOfLastMonth, startOfLastMonth, endOfLastMonth // Last Month\r\n        ]);\r\n\r\n        const result = rows[0];\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Hire summary: daily and monthly comparison\",\r\n            todayHire: result.todayHire,\r\n            todayIncreased: result.todayHire > result.yesterdayHire ? \"yes\" : \"no\",\r\n            thisMonthHire: result.thisMonthHire,\r\n            hireIncreased: result.thisMonthHire > result.lastMonthHire ? \"yes\" : \"no\"\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching hire summary:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while fetching hire data\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n//get year totals month by month\r\nrouter.get(\"/monthly-order-income\", async (req, res) => {\r\n    try {\r\n        const currentYear = moment().year();\r\n\r\n        const sql = `\r\n            SELECT \r\n                MONTH(orDate) AS month,\r\n                ordertype,\r\n                SUM(total) AS monthlyTotal\r\n            FROM Orders\r\n            WHERE orStatus != 'cancel' AND YEAR(orDate) = ?\r\n            GROUP BY MONTH(orDate), ordertype\r\n            ORDER BY MONTH(orDate), ordertype\r\n        `;\r\n\r\n        const [rows] = await db.query(sql, [currentYear]);\r\n\r\n        const totalIncome = Array(12).fill(0);\r\n        const walkingIncome = Array(12).fill(0);\r\n        const onsiteIncome = Array(12).fill(0);\r\n\r\n        rows.forEach(row => {\r\n            const index = row.month - 1;\r\n            const income = parseFloat(row.monthlyTotal);\r\n\r\n            // Sum to total regardless of type\r\n            totalIncome[index] += income;\r\n\r\n            if (row.ordertype === 'Walking') {\r\n                walkingIncome[index] = income;\r\n            } else if (row.ordertype === 'On-site') {\r\n                onsiteIncome[index] = income;\r\n            }\r\n        });\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            year: currentYear,\r\n            totalIncome,\r\n            walkingIncome,\r\n            onsiteIncome\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching monthly order income:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while fetching monthly order income\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// get month total day by day\r\nrouter.get(\"/daily-order-income\", async (req, res) => {\r\n    try {\r\n        // Use moment to get the current year and month\r\n        const year = moment().year();\r\n        const month = moment().month() + 1; // month() is 0-based, so add 1\r\n\r\n        const sql = `\r\n            SELECT \r\n                DAY(orDate) AS day,\r\n                ordertype,\r\n                SUM(total) AS dailyTotal\r\n            FROM Orders\r\n            WHERE orStatus != 'cancel' AND YEAR(orDate) = ? AND MONTH(orDate) = ?\r\n            GROUP BY DAY(orDate), ordertype\r\n            ORDER BY DAY(orDate), ordertype\r\n        `;\r\n\r\n        const [rows] = await db.query(sql, [year, month]);\r\n\r\n        const daysInMonth = moment(`${year}-${month}`, \"YYYY-MM\").daysInMonth();\r\n        const totalIncome = Array(daysInMonth).fill(0);\r\n        const walkingIncome = Array(daysInMonth).fill(0);\r\n        const onsiteIncome = Array(daysInMonth).fill(0);\r\n\r\n        rows.forEach(row => {\r\n            const index = row.day - 1;\r\n            const amount = parseFloat(row.dailyTotal);\r\n\r\n            totalIncome[index] += amount;\r\n\r\n            if (row.ordertype === \"Walking\") {\r\n                walkingIncome[index] = amount;\r\n            } else if (row.ordertype === \"On-site\") {\r\n                onsiteIncome[index] = amount;\r\n            }\r\n        });\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            year,\r\n            month,\r\n            totalIncome,\r\n            walkingIncome,\r\n            onsiteIncome\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching daily income:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Database error while fetching daily order income\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Daily Issued Material Prices\r\nrouter.get(\"/daily-issued-material-prices\", async (req, res) => {\r\n    try {\r\n        // Use moment to get the current year and month if not passed in the request\r\n        const year =  moment().year(); // Default to current year if not provided\r\n        const month = moment().month() + 1; // Default to current month (moment() returns 0-based month, so add 1)\r\n\r\n        // Ensure year and month are valid\r\n        if (!year || !month) {\r\n            return res.status(400).json({ success: false, message: \"Year and month are required.\" });\r\n        }\r\n\r\n        // Get the start and end date for the selected month\r\n        const startOfMonth = moment(`${year}-${month}-01`).startOf(\"month\").format(\"YYYY-MM-DD\");\r\n        const endOfMonth = moment(`${year}-${month}-01`).endOf(\"month\").format(\"YYYY-MM-DD\");\r\n\r\n        // SQL query to fetch data\r\n        const sql = `\r\n            SELECT \r\n                CASE\r\n                    WHEN pid.material IN ('Teak', 'Mahogani', 'Mara', 'Attoriya', 'Sapu') THEN 'Furniture'\r\n                    ELSE pid.material\r\n                END AS materialGroup,\r\n                DAY(pid.datetime) AS day,\r\n                SUM(pid.price) AS totalPrice\r\n            FROM p_i_detail pid\r\n            WHERE pid.status = 'Issued' \r\n            AND pid.datetime BETWEEN ? AND ?\r\n            GROUP BY materialGroup, day\r\n            ORDER BY day\r\n        `;\r\n\r\n        const [rows] = await db.query(sql, [startOfMonth, endOfMonth]);\r\n\r\n        // Initialize arrays for each material group (31 days for the month)\r\n        const data = {\r\n            \"MDF\": Array(31).fill(0),\r\n            \"MM\": Array(31).fill(0),\r\n            \"Mattress\": Array(31).fill(0),\r\n            \"Furniture\": Array(31).fill(0),\r\n        };\r\n\r\n        // Populate the data with the queried values\r\n        rows.forEach(row => {\r\n            data[row.materialGroup][row.day - 1] = parseFloat(row.totalPrice);\r\n        });\r\n\r\n        // Return the data in the response\r\n        return res.status(200).json({\r\n            success: true,\r\n            year,\r\n            month,\r\n            data: data\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error retrieving daily issued material prices:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error retrieving material price data for the day\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n// Yearly Issued Material Prices\r\nrouter.get(\"/yearly-issued-material-prices\", async (req, res) => {\r\n    try {\r\n        // Use query year if provided, otherwise use current year\r\n        const year = req.query.year ? parseInt(req.query.year) : moment().year();\r\n\r\n        // Validate the year\r\n        if (isNaN(year) || year < 1900 || year > 2100) {\r\n            return res.status(400).json({ success: false, message: \"Valid year is required.\" });\r\n        }\r\n\r\n        // Get start and end of the year\r\n        const startOfYear = moment(`${year}-01-01`).startOf(\"year\").format(\"YYYY-MM-DD\");\r\n        const endOfYear = moment(`${year}-12-31`).endOf(\"year\").format(\"YYYY-MM-DD\");\r\n\r\n        // SQL to aggregate material prices per month\r\n        const sql = `\r\n            SELECT\r\n                sub.materialGroup,\r\n                MONTH(sub.datetime) AS month,\r\n                SUM(sub.price) AS totalPrice\r\n            FROM (\r\n                SELECT\r\n                CASE\r\n                WHEN material IN ('Teak', 'Mahogani', 'Mara', 'Attoriya', 'Sapu') THEN 'Furniture'\r\n                ELSE material\r\n                END AS materialGroup,\r\n                price,\r\n                datetime\r\n                FROM p_i_detail\r\n                WHERE datetime BETWEEN ? AND ? AND status = 'Issued'\r\n                ) AS sub\r\n            GROUP BY sub.materialGroup, month\r\n            ORDER BY month\r\n        `;\r\n\r\n\r\n        const [rows] = await db.query(sql, [startOfYear, endOfYear]);\r\n\r\n        // Initialize data containers\r\n        const data = {\r\n            \"MDF\": Array(12).fill(0),\r\n            \"MM\": Array(12).fill(0),\r\n            \"Mattress\": Array(12).fill(0),\r\n            \"Furniture\": Array(12).fill(0),\r\n        };\r\n\r\n        // Populate data with results\r\n        rows.forEach(row => {\r\n            if (data[row.materialGroup]) {\r\n                data[row.materialGroup][row.month - 1] = parseFloat(row.totalPrice);\r\n            }\r\n        });\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            year,\r\n            data\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error retrieving yearly issued material prices:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error retrieving material price data for the year\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save Vehicle\r\nrouter.post(\"/vehicle\", async (req, res) => {\r\n    try {\r\n        const {registration_no, brand, model, color, year, license_Date, insurance_Date, fuel_type, size, status} = req.body;\r\n\r\n        if (!registration_no || !brand || !model || !status) {\r\n            return res.status(400).json({ success: false, message: \"Required fields missing\" });\r\n        }\r\n\r\n        const sql = `\r\n            INSERT INTO vehicle (\r\n                registration_no, brand, model, color, year,\r\n                license_Date, insurance_Date, fuel_type, size, status\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n        `;\r\n\r\n        const [result] = await db.query(sql, [\r\n            registration_no, brand, model, color, year,\r\n            license_Date, insurance_Date, fuel_type, size, status\r\n        ]);\r\n\r\n        res.status(201).json({\r\n            success: true,\r\n            message: \"Vehicle saved successfully\",\r\n            vehicleId: result.insertId\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error saving vehicle:\", err.message);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: \"Error saving vehicle\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get All Vehicles\r\nrouter.get(\"/vehicles\", async (req, res) => {\r\n    try {\r\n        const sql = `SELECT * FROM vehicle ORDER BY id DESC`;\r\n        const [rows] = await db.query(sql);\r\n\r\n        res.status(200).json({\r\n            success: true,\r\n            data: rows\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching vehicles:\", err.message);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching vehicles\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Hire\r\n// POST: Create a new hire\r\nrouter.post(\"/other-hire\", async (req, res) => {\r\n    try {\r\n        const { title, FtName, SrName, phoneNumber, otherNumber, date, pickup, destination, distance, hire, driverId, vehicleID } = req.body;\r\n\r\n        const Cust_id = await generateNewId(\"Customer\", \"c_ID\", \"Cus\");\r\n        const trimmedPhone = phoneNumber.trim();\r\n        const trimmedOther = otherNumber.trim();\r\n\r\n        // ✅ Set bookingDate to current system date\r\n        const placeDate = moment().format(\"YYYY-MM-DD\");\r\n\r\n        const sqlInsertCustomer = `\r\n            INSERT INTO Customer (c_ID, title, FtName, SrName, address, contact1, contact2, id, balance, type, category, t_name, occupation, workPlace)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\r\n\r\n        const valuesCustomer = [\r\n            Cust_id, title, FtName, SrName, '', trimmedPhone || \"-\", trimmedOther || \"-\", '', 0, \"Transport\", '', '', '', ''\r\n        ];\r\n\r\n        await db.query(sqlInsertCustomer, valuesCustomer);\r\n\r\n        // Insert into otherHire\r\n        const insertHire = `\r\n            INSERT INTO otherHire (\r\n                customer, date, bookingDate, pickup, destination,\r\n                distance, hire, driverId, vehicleID, status, payment\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'Booked', 0)\r\n        `;\r\n\r\n        await db.query(insertHire, [\r\n            Cust_id, placeDate, date, pickup, destination,\r\n            distance, hire, driverId, vehicleID\r\n        ]);\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"New hire entry saved successfully.\"\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"❌ Error saving new hire:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Failed to save hire entry.\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// GET: All hire entries\r\nrouter.get(\"/other-hires\", async (req, res) => {\r\n    try {\r\n        const sql = `\r\n            SELECT\r\n                oh.*,\r\n                CONCAT(c.title, ' ', c.FtName) AS custname,\r\n                c.contact1 AS phoneNumber,\r\n                c.contact2 AS otherNumber,\r\n                c.balance AS customerBalance,\r\n                v.registration_no,\r\n                e.name AS driverName\r\n            FROM otherHire oh\r\n                     LEFT JOIN Customer c ON oh.customer = c.c_ID\r\n                     LEFT JOIN vehicle v ON oh.vehicleID = v.id\r\n                     LEFT JOIN driver d ON oh.driverId = d.devID\r\n                     LEFT JOIN Employee e ON d.E_ID = e.E_Id\r\n            ORDER BY oh.date DESC\r\n        `;\r\n\r\n        const [rows] = await db.query(sql);\r\n\r\n        // Separate into two arrays based on status\r\n        const booked = rows.filter(item => item.status === 'Booked');\r\n        const done = rows.filter(item => item.status === 'Done');\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            booked,\r\n            done\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"❌ Error fetching hires:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Failed to retrieve hire entries.\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n// Get all hire for specific employee\r\nrouter.get(\"/other-hires-stid\", async (req, res) => {\r\n    try {\r\n        const { eid } = req.query;\r\n        let sql = `\r\n            SELECT\r\n                oh.*,\r\n                CONCAT(c.title, ' ', c.FtName) AS custname,\r\n                c.contact1 AS phoneNumber,\r\n                c.contact2 AS otherNumber,\r\n                c.balance AS customerBalance,\r\n                v.registration_no,\r\n                e.name AS driverName\r\n            FROM otherHire oh\r\n            LEFT JOIN Customer c ON oh.customer = c.c_ID\r\n            LEFT JOIN vehicle v ON oh.vehicleID = v.id\r\n            LEFT JOIN driver d ON oh.driverId = d.devID\r\n            LEFT JOIN Employee e ON d.E_ID = e.E_Id\r\n        `;\r\n\r\n        const params = [];\r\n\r\n        if (eid) {\r\n            sql += ` WHERE d.E_ID = ?`;\r\n            params.push(eid);\r\n        }\r\n\r\n        sql += ` ORDER BY oh.date DESC`;\r\n\r\n        const [rows] = await db.query(sql, params);\r\n\r\n        const booked = rows.filter(item => item.status === 'Booked');\r\n        const done = rows.filter(item => item.status === 'Done');\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            booked,\r\n            done\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"❌ Error fetching hires:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Failed to retrieve hire entries.\",\r\n            error: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Update Hire payments\r\nrouter.put(\"/other-hire/payment\", async (req, res) => {\r\n    const {customer, customerPayment, customerBalance, driver, driverHandover, driverBalance, profitOrLoss, lossBy} = req.body;\r\n\r\n    try {\r\n        const currentDateTime = new Date();\r\n\r\n        // 1\uFE0F⃣ Update hire status to 'Done'\r\n        await db.query(\r\n            `UPDATE otherHire\r\n             SET status = 'Done', payment=?\r\n             WHERE customer = ? AND driverId = ? AND status != 'Done'`,\r\n            [customerPayment,customer, driver]\r\n        );\r\n\r\n        // 2\uFE0F⃣ Insert customer payment into cash_balance\r\n        await db.query(\r\n            `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)\r\n             VALUES (?, ?, 'Hire', ?, ?)`,\r\n            ['Hire payment from customer', customer, currentDateTime, customerPayment]\r\n        );\r\n\r\n        // 3\uFE0F⃣ If loss exists, insert as negative cash_balance\r\n        if (profitOrLoss > 0 && lossBy) {\r\n            await db.query(\r\n                `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)\r\n                 VALUES (?, ?, 'loss', ?, ?)`,\r\n                [`Loss by ${lossBy}`, customer, currentDateTime, -Math.abs(profitOrLoss)]\r\n            );\r\n        }\r\n\r\n        // 4\uFE0F⃣ Update customer balance if needed\r\n        if (customerBalance !== 0) {\r\n            await db.query(\r\n                `UPDATE hireCustomer SET balance = ? WHERE custID = ?`,\r\n                [customerBalance, customer]\r\n            );\r\n        }\r\n\r\n        // 5\uFE0F⃣ Update driver balance if needed\r\n        if (driverBalance !== 0) {\r\n            await db.query(\r\n                `UPDATE driver SET balance = ? WHERE devID = ?`,\r\n                [driverBalance, driver]\r\n            );\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Hire payment processed successfully.\"\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Error in hire payment update:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Failed to process hire payment.\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get all users\r\nrouter.get(\"/users\", async (req, res) => {\r\n    try {\r\n        const [users] = await db.query(\"SELECT id, contact, type FROM user\");\r\n        res.json({ data: users });\r\n    } catch (err) {\r\n        res.status(500).json({ message: \"Failed to fetch users\" });\r\n    }\r\n});\r\n\r\n//Get full detail of a user \r\nrouter.get(\"/users/:id\", async (req, res) => {\r\n    const { id } = req.params;\r\n    try {\r\n        const [[user]] = await db.query(\"SELECT * FROM user WHERE id = ?\", [id]);\r\n        const [sessions] = await db.query(\"SELECT * FROM sessionlogs WHERE user = ?\", [id]);\r\n\r\n        if (!user) return res.status(404).json({ message: \"User not found\" });\r\n\r\n        res.json({ user, sessions });\r\n    } catch (err) {\r\n        res.status(500).json({ message: \"Failed to get user details\" });\r\n    }\r\n});\r\n\r\n// Delete one unwanted user\r\nrouter.delete(\"/users/:id\", async (req, res) => {\r\n    const { id } = req.params;\r\n    try {\r\n        await db.query(\"DELETE FROM user WHERE id = ?\", [id]);\r\n        res.json({ message: \"User deleted\" });\r\n    } catch (err) {\r\n        res.status(500).json({ message: \"Failed to delete user\" });\r\n    }\r\n});\r\n\r\n//Update user details\r\nrouter.put(\"/users/:id\", async (req, res) => {\r\n    const { id } = req.params;\r\n    const { contact, password, role } = req.body;\r\n\r\n    try {\r\n        const updates = [];\r\n        const values = [];\r\n\r\n        if (contact) {\r\n            updates.push(\"contact = ?\");\r\n            values.push(contact);\r\n        }\r\n\r\n        if (password) {\r\n            updates.push(\"password = ?\");\r\n            values.push(password); // You should hash it in real usage\r\n        }\r\n\r\n        if (role) {\r\n            updates.push(\"type = ?\");\r\n            values.push(role);\r\n        }\r\n\r\n        if (updates.length === 0) {\r\n            return res.status(400).json({ message: \"No valid fields to update.\" });\r\n        }\r\n\r\n        values.push(id);\r\n        await db.query(`UPDATE user SET ${updates.join(\", \")} WHERE id = ?`, values);\r\n\r\n        res.json({ message: \"User updated successfully\" });\r\n    } catch (err) {\r\n        res.status(500).json({ message: \"Failed to update user\" });\r\n    }\r\n});\r\n\r\n// Delete emploee\r\nrouter.delete(\"/employees/:id\", async (req, res) => {\r\n    const employeeId = req.params.id;\r\n\r\n    try {\r\n        const [existing] = await db.query(\"SELECT * FROM Employee WHERE E_Id = ?\", [employeeId]);\r\n\r\n        if (existing.length === 0) {\r\n            return res.status(404).json({ message: \"Employee not found\" });\r\n        }\r\n\r\n        // Foreign key constraints with ON DELETE CASCADE will handle related deletions\r\n        await db.query(\"DELETE FROM Employee WHERE E_Id = ?\", [employeeId]);\r\n\r\n        res.json({ message: \"Employee and related records deleted successfully.\" });\r\n    } catch (error) {\r\n        console.error(\"Error deleting employee:\", error);\r\n        res.status(500).json({ message: \"Internal server error\" });\r\n    }\r\n});\r\n\r\n//Route: Get Applied Leaves, Pending Requests, and Onsite Pending Orders Count\r\nrouter.get('/applied_leaves-and-requests-and-ordercounts', async (req, res) => {\r\n  try {\r\n    // Fetch Applied Leaves\r\n    const [appliedLeaves] = await db.query(`\r\n      SELECT el.id, el.E_Id, e.name, el.date, el.leave_type, el.duration_type, el.reason, el.status\r\n      FROM Emp_leaves el\r\n      JOIN Employee e ON el.E_Id = e.E_Id\r\n      WHERE el.status = 'Applied'\r\n      ORDER BY el.date DESC\r\n    `);\r\n\r\n    // Fetch Pending Requests\r\n    const [pendingRequests] = await db.query(`\r\n      SELECT r.id, r.E_Id, e.name, r.reason, r.status\r\n      FROM Request r\r\n      JOIN Employee e ON r.E_Id = e.E_Id\r\n      WHERE r.status = 'Pending'\r\n      ORDER BY r.id DESC\r\n    `);\r\n\r\n    // Fetch Pending On-site Orders by Sales Team\r\n    const [pendingOnsiteOrders] = await db.query(`\r\n      SELECT st.stID, e.name AS sales_team_name, COUNT(*) AS pendingOrderCount\r\n      FROM Orders o\r\n      JOIN sales_team st ON o.stID = st.stID\r\n      JOIN Employee e ON st.E_Id = e.E_Id\r\n      WHERE o.orStatus = 'Pending' AND o.ordertype = 'On-site'\r\n      GROUP BY st.stID\r\n    `);\r\n\r\n    // Return the results in the response\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        appliedLeaves,\r\n        pendingRequests,\r\n        pendingOnsiteOrders,\r\n      },\r\n    });\r\n  } catch (err) {\r\n    console.error('❌ Error in notification fetch:', err);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Server error',\r\n      detail: err.message,\r\n    });\r\n  }\r\n});\r\n\r\n// Fetch all leaves for a user in a given month and year\r\nrouter.get(\"/leaves/:eid/:month/:year\", async (req, res) => {\r\n    const { eid, month, year } = req.params;\r\n    try {\r\n        const [rows] = await db.execute(`\r\n            SELECT id, E_Id, date, leave_type, duration_type, reason, status, present\r\n            FROM emp_leaves\r\n            WHERE E_Id = ? AND MONTH(date) = ? AND YEAR(date) = ?\r\n            ORDER BY date DESC\r\n        `, [eid, month, year]);\r\n\r\n        res.json({ success: true, leaves: rows });\r\n    } catch (err) {\r\n        console.error(\"Error fetching leaves:\", err);\r\n        res.status(500).json({ success: false, message: \"Server error\" });\r\n    }\r\n});\r\n\r\n// Update a leave record, including the 'present' column\r\nrouter.put(\"/update-leave/:id\", async (req, res) => {\r\n    const { id } = req.params;\r\n    const { date, duration_type, reason, present } = req.body;\r\n\r\n    try {\r\n        const [result] = await db.execute(`\r\n            UPDATE emp_leaves\r\n            SET date = ?, duration_type = ?, reason = ?, present = ?\r\n            WHERE id = ?\r\n        `, [date, duration_type, reason, present, id]);\r\n\r\n        if (result.affectedRows > 0) {\r\n            res.json({ success: true, message: \"Leave updated\" });\r\n        } else {\r\n            res.status(404).json({ success: false, message: \"Leave not found\" });\r\n        }\r\n    } catch (err) {\r\n        console.error(\"Error updating leave:\", err);\r\n        res.status(500).json({ success: false, message: \"Server error\" });\r\n    }\r\n});\r\n\r\n// Express Route// In your Express router\r\nrouter.get('/cheques/received', async (req, res) => {\r\n    try {\r\n        const [rows] = await db.execute(`\r\n            SELECT \r\n                cp.*, \r\n                pt.orID,\r\n                c.FtName, \r\n                c.SrName\r\n            FROM ord_Cheque_Pay cp\r\n            JOIN ord_Pay_type pt ON cp.optId = pt.optId\r\n            JOIN Orders o ON pt.orID = o.orID\r\n            JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE cp.status = 'received'\r\n        `);\r\n\r\n        // Append full name\r\n        const cheques = rows.map(row => ({\r\n            ...row,\r\n            customerName: `${row.FtName} ${row.SrName}`\r\n        }));\r\n\r\n        res.json({ success: true, cheques });\r\n    } catch (err) {\r\n        console.error(err);\r\n        res.status(500).json({ success: false, message: \"Database error\" });\r\n    }\r\n});\r\n\r\n// Update check\r\nrouter.put('/cheques/update-status/:id', async (req, res) => {\r\n    const chequeId = req.params.id;\r\n    const { status } = req.body;\r\n\r\n    const validStatuses = ['received', 'cashed', 'returned'];\r\n    if (!validStatuses.includes(status)) {\r\n        return res.status(400).json({ success: false, message: \"Invalid status\" });\r\n    }\r\n\r\n    try {\r\n        const [result] = await db.execute(\r\n            \"UPDATE ord_Cheque_Pay SET status = ? WHERE id = ?\",\r\n            [status, chequeId]\r\n        );\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({ success: false, message: \"Cheque not found\" });\r\n        }\r\n\r\n        res.json({ success: true, message: \"Status updated\" });\r\n    } catch (err) {\r\n        console.error(err);\r\n        res.status(500).json({ success: false, message: \"Server error\" });\r\n    }\r\n});\r\n\r\n\r\n// pass sale team value to review in month end\r\n\r\n// Function to generate new ida\r\nconst generateNewId = async (table, column, prefix) => {\r\n    const [rows] = await db.query(`SELECT ${column} FROM ${table} ORDER BY ${column} DESC LIMIT 1`);\r\n    if (rows.length === 0) return `${prefix}_001`; // First entry\r\n    const lastId = rows[0][column]; // Get last ID\r\n    const lastNum = parseInt(lastId.split(\"_\")[1],10) + 1; // Extract number and increment\r\n    return `${prefix}_${String(lastNum).padStart(3, \"0\")}`;\r\n};\r\n\r\n// Helper function to parse date from DD/MM/YYYY format to YYYY-MM-DD format\r\nconst parseDate = (dateStr) => {\r\n    if (!dateStr) return null;\r\n    let year, month, day;\r\n\r\n    // Check if the date is in `YYYY-MM-DD` format\r\n    if (dateStr.includes(\"-\")) {\r\n        [year, month, day] = dateStr.split(\"-\");\r\n    }\r\n    // Check if the date is in `DD/MM/YYYY` format\r\n    else if (dateStr.includes(\"/\")) {\r\n        [day, month, year] = dateStr.split(\"/\");\r\n    } else {\r\n        return null; // Invalid format\r\n    }\r\n    // Validate components\r\n    if (!day || !month || !year || isNaN(day) || isNaN(month) || isNaN(year)) {\r\n        return null;\r\n    }\r\n\r\n    // Convert to `YYYY-MM-DD` for MySQL queries\r\n    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;\r\n};\r\n\r\nconst parseDate1 = (dateStr) => {\r\n    if (!dateStr) return null;\r\n    let year, month, day;\r\n\r\n    if (dateStr.includes(\"-\")) {\r\n        [year, month, day] = dateStr.split(\"-\");\r\n    } else if (dateStr.includes(\"/\")) {\r\n        [day, month, year] = dateStr.split(\"/\");\r\n    } else {\r\n        return null;\r\n    }\r\n\r\n    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;\r\n};\r\nconst formatDate = (date) => {\r\n    return date ? new Date(date).toLocaleDateString(\"en-GB\") : null;\r\n};\r\nconst formatDateTime = (datetime) => {\r\n    return new Date(datetime).toLocaleString(\"en-US\", {\r\n        year: \"numeric\",\r\n        month: \"2-digit\",\r\n        day: \"2-digit\",\r\n        hour: \"2-digit\",\r\n        minute: \"2-digit\",\r\n        hour12: true\r\n    });\r\n};\r\n\r\n\r\nexport default router;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/adminBackend/Routes/mainRoutes.js b/adminBackend/Routes/mainRoutes.js
--- a/adminBackend/Routes/mainRoutes.js	(revision 19a335d815a5f44e7d7c3d0328af014c99b3c776)
+++ b/adminBackend/Routes/mainRoutes.js	(date 1750238868514)
@@ -440,9 +440,13 @@
                 const optId = await insertPayType();
                 if (subPayment === 'Transfer' && tranferPayment) {
                     await db.query(
-                        `INSERT INTO ord_Transfer_Pay (optId, amount, bank) VALUES (?, ?, ?)`,
+                        `INSERT INTO ord_Transfer_Pay (optId, amount, acnID) VALUES (?, ?, ?)`,
                         [optId, advance1, tranferPayment.bank]
                     );
+                    await db.query(
+                        `INSERT INTO deposit_withdrawals (acnID, type, amount, dwdate,remark) VALUES (?, ?, ?, NOW(),?)`,
+                        [tranferPayment.acnID, 'Deposit', advance1,orID]
+                    );
                 } else {
                     await db.query(
                         `INSERT INTO ord_Cash_Pay (optId, amount) VALUES (?, ?)`,
@@ -534,12 +538,21 @@
 
                 else if (subPayment === 'Cash & Transfer' && combinedTransferPayment) {
                     await db.query(
-                        `INSERT INTO ord_Transfer_Pay (optId, amount, bank) VALUES (?, ?, ?)`,
+                        `INSERT INTO ord_Transfer_Pay (optId, amount, acnID) VALUES (?, ?, ?)`,
                         [optId, combinedTransferPayment.transferAmount, combinedTransferPayment.bank]
                     );
+                    await db.query(
+                        `INSERT INTO deposit_withdrawals (acnID, type, amount, dwdate,remark) VALUES (?, ?, ?, NOW(),?)`,
+                        [combinedTransferPayment.acnID, 'Deposit', combinedTransferPayment.transferAmount,orID]
+                    );
                     await updateOrderPayment(0, advance1);
                 }
+
             }
+            await db.query(
+                `UPDATE Customer SET balance = ? WHERE c_ID = ?`,
+                [customerBalance, Cust_id]
+            );
         }
 
         return res.status(201).json({
@@ -1034,10 +1047,14 @@
                 if (subPayment === 'Cash & Transfer' && combinedTransferPayment) {
                     const optId = await insertPayType();
                     await db.query(
-                        `INSERT INTO ord_Transfer_Pay (optId, amount, bank)
+                        `INSERT INTO ord_Transfer_Pay (optId, amount, acnID)
                 VALUES (?, ?, ?)`,
                         [optId, combinedTransferPayment.transferAmount, combinedTransferPayment.bank]
                     );
+                    await db.query(
+                        `INSERT INTO deposit_withdrawals (acnID, type, amount, dwdate,remark) VALUES (?, ?, ?, NOW(),?)`,
+                        [combinedTransferPayment.acnID, 'Deposit', combinedTransferPayment.transferAmount,orID]
+                    );
                     await updateOrderPayment(advance1);
                 }
             }
@@ -1045,12 +1062,20 @@
             if (payment === 'Cash' && subPayment === 'Transfer' && tranferPayment) {
                 const optId = await insertPayType();
                 await db.query(
-                    `INSERT INTO ord_Transfer_Pay (optId, amount, bank)
+                    `INSERT INTO ord_Transfer_Pay (optId, amount, acnID)
             VALUES (?, ?, ?)`,
                     [optId, advance1, tranferPayment.bank]
                 );
+                await db.query(
+                    `INSERT INTO deposit_withdrawals (acnID, type, amount, dwdate,remark) VALUES (?, ?, ?, NOW(),?)`,
+                    [tranferPayment.acnID, 'Deposit', advance1,orID]
+                );
                 await updateOrderPayment(advance1);
             }
+            await db.query(
+                `UPDATE Customer SET balance = ? WHERE c_ID = ?`,
+                [customerBalance, Cust_id]
+            );
         }
 
         return res.status(201).json({
@@ -10263,6 +10288,113 @@
     }
 });
 
+// GET all transfer transactions
+// Get all bank transfers (deposits/withdrawals)
+router.get('/bank-transfers', async (req, res) => {
+    try {
+        const [rows] = await db.execute(`
+            SELECT 
+                t.id,
+                t.amount,
+                t.acnID,
+                pt.orID,
+                pt.type,
+                pt.subType,
+                pt.payDate,
+                a.number AS accountNumber,
+                b.Bank,
+                b.branch
+            FROM ord_transfer_pay t
+            JOIN ord_pay_type pt ON t.optId = pt.optId
+            JOIN accountNumbers a ON t.acnID = a.acnID
+            JOIN shop_Banks b ON a.sbID = b.sbID
+            ORDER BY t.id DESC
+        `);
+
+        res.json({ success: true, transfers: rows });
+    } catch (err) {
+        console.error("Error fetching bank transfers:", err);
+        res.status(500).json({ success: false, message: "Database error" });
+    }
+});
+
+// get withdrawls payments
+router.get('/bank-deposit-withdrawals', async (req, res) => {
+    try {
+        const [rows] = await db.execute(`
+            SELECT 
+                dw.dwID AS id,
+                dw.type,
+                dw.amount,
+                dw.dwdate,
+                dw.remark,
+                a.number AS accountNumber,
+                b.Bank AS bank,
+                b.branch
+            FROM deposit_withdrawals dw
+            JOIN accountNumbers a ON dw.acnID = a.acnID
+            JOIN shop_Banks b ON a.sbID = b.sbID
+            ORDER BY dw.dwID DESC
+        `);
+
+        res.json({ success: true, transfers: rows });
+    } catch (err) {
+        console.error("Error fetching deposit/withdrawals:", err);
+        res.status(500).json({ success: false, message: "Database error" });
+    }
+});
+
+// POST new transfer transaction
+router.post('/deposit&withdrawals', async (req, res) => {
+    const { optId, acnID, amount, remark } = req.body;
+
+    // Validate inputs
+    if (!optId || !acnID || isNaN(amount)) {
+        return res.status(400).json({
+            success: false,
+            message: 'Missing or invalid fields',
+        });
+    }
+
+    try {
+        // Ensure the amount is a positive float
+        const numericAmount = parseFloat(amount);
+        const payment = optId === 'Withdrawal' ? -Math.abs(numericAmount) : Math.abs(numericAmount);
+        const ref = optId === 'Withdrawal' ? 'Withdrawl' : 'Deposit';
+
+        // Insert the transaction
+        await db.query(
+            `INSERT INTO deposit_withdrawals (acnID, type, amount, dwdate,remark) VALUES (?, ?, ?, NOW(),?)`,
+            [acnID, optId, payment,remark]
+        );
+
+        await db.query(
+            `INSERT INTO cash_balance (reason, ref, ref_type, dateTime, amount)
+             VALUES (?, ?, ?, NOW(), ?)`,
+            [optId,remark, ref , payment]
+        );
+
+        res.json({
+            success: true,
+            message: `${optId} of ${Math.abs(payment)} recorded successfully.`,
+        });
+
+    } catch (err) {
+        console.error("Error recording transaction:", err);
+        res.status(500).json({
+            success: false,
+            message: 'Database error while inserting transaction.',
+        });
+    }
+});
+
+
+// DELETE a transaction
+router.delete('/transfers/:id', async (req, res) => {
+    await db.query(`DELETE FROM ord_Transfer_Pay WHERE id = ?`, [req.params.id]);
+    res.json({ success: true, message: 'Deleted' });
+});
+
 
 // pass sale team value to review in month end
 
