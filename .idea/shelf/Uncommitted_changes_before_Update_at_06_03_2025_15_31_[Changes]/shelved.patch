Index: adminBackend/Routes/mainRoutes.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import express from 'express';\r\nimport upload from \"../middlewares/upload.js\";\r\nimport db from '../utils/db.js';\r\nimport bwipjs from 'bwip-js';\r\nimport path from \"path\";\r\nimport fs from \"fs\";\r\nimport {parse} from \"dotenv\";\r\nconst router = express.Router();\r\n\r\n// Save  new item\r\nrouter.post(\"/add-item\", upload.fields([{ name: \"img\", maxCount: 1 }, { name: \"img1\", maxCount: 1 }, { name: \"img2\", maxCount: 1 }, { name: \"img3\", maxCount: 1 }]), async (req, res) => {\r\n    try {\r\n        const { I_Id, I_name, descrip, color, price, warrantyPeriod, cost, material, s_Id, minQty, Ca_Id, sub_one, sub_two } = req.body;\r\n        const parsedPrice = parseFloat(price) || 0;\r\n        const parsedCost = parseFloat(cost) || 0;\r\n\r\n        // ✅ Check if main category exists\r\n        const [mainCatCheck] = await db.query(`SELECT name FROM Category WHERE Ca_Id = ?`, [Ca_Id]);\r\n        if (mainCatCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Main Category: ${Ca_Id}` });\r\n        }\r\n        const mainCategoryName = mainCatCheck[0].name;\r\n\r\n        // ✅ Check if subCat_one exists\r\n        const [subCatOneCheck] = await db.query(`SELECT subcategory FROM subCat_one WHERE sb_c_id = ?`, [sub_one]);\r\n        if (subCatOneCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Sub Category One: ${sub_one}` });\r\n        }\r\n        const subCatOneName = subCatOneCheck[0].subcategory;\r\n\r\n        // ✅ Check if subCat_two exists or set as 'None'\r\n        let subCatTwoName = 'None';\r\n        if (sub_two !== 'None') {\r\n            const [subCatTwoCheck] = await db.query(`SELECT subcategory FROM subCat_two WHERE sb_cc_id = ?`, [sub_two]);\r\n            if (subCatTwoCheck.length === 0) {\r\n                return res.status(400).json({ success: false, message: `Invalid Sub Category Two: ${sub_two}` });\r\n            }\r\n            subCatTwoName = subCatTwoCheck[0].subcategory;\r\n        }\r\n\r\n        // ✅ Check if supplier exists\r\n        const [supplierCheck] = await db.query(`SELECT s_ID FROM Supplier WHERE s_ID = ?`, [s_Id]);\r\n        if (supplierCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Supplier ID: ${s_Id}` });\r\n        }\r\n\r\n        // ✅ Extract image buffers (only main image required)\r\n        const imgBuffer = req.files[\"img\"]?.[0]?.buffer || null;\r\n        const img1Buffer = req.files[\"img1\"]?.[0]?.buffer || null;\r\n        const img2Buffer = req.files[\"img2\"]?.[0]?.buffer || null;\r\n        const img3Buffer = req.files[\"img3\"]?.[0]?.buffer || null;\r\n\r\n        if (!imgBuffer) {\r\n            return res.status(400).json({ success: false, message: \"Main image (img) is required.\" });\r\n        }\r\n\r\n        // ✅ Insert into `Item` table\r\n        const itemSql = `\r\n            INSERT INTO Item (I_Id, I_name, descrip, color, material, price, stockQty, bookedQty, availableQty, minQTY, img, img1, img2, img3, warrantyPeriod, mn_Cat, sb_catOne, sb_catTwo)\r\n            VALUES (?, ?, ?, ?, ?, ?, 0, 0, 0, ?, ?, ?, ?, ?, ?, ?, ?, ?);\r\n        `;\r\n        await db.query(itemSql, [\r\n            I_Id,\r\n            I_name,\r\n            descrip,\r\n            color,\r\n            material,\r\n            parsedPrice,\r\n            minQty,\r\n            imgBuffer,\r\n            img1Buffer,\r\n            img2Buffer,\r\n            img3Buffer,\r\n            warrantyPeriod,\r\n            mainCategoryName,\r\n            subCatOneName,\r\n            subCatTwoName\r\n        ]);\r\n\r\n        // ✅ Insert into `Item_supplier` table\r\n        const supplierSql = `INSERT INTO item_supplier (I_Id, s_ID, unit_cost) VALUES (?, ?, ?);`;\r\n        await db.query(supplierSql, [I_Id, s_Id, parsedCost]);\r\n\r\n        res.status(201).json({\r\n            success: true,\r\n            message: \"✅ Item added successfully!\",\r\n            data: {\r\n                I_Id,\r\n                I_name,\r\n                descrip,\r\n                color,\r\n                material,\r\n                price: parsedPrice,\r\n                warrantyPeriod,\r\n                cost: parsedCost,\r\n                mn_Cat: mainCategoryName,\r\n                sb_catOne: subCatOneName,\r\n                sb_catTwo: subCatTwoName\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"❌ Error inserting item data:\", err.message);\r\n        res.status(500).json({ success: false, message: \"Error inserting data into database\", details: err.message });\r\n    }\r\n});\r\n\r\n// Update item\r\nrouter.put(\"/update-item\", upload.fields([{ name: \"img\", maxCount: 1 }, { name: \"img1\", maxCount: 1 }, { name: \"img2\", maxCount: 1 }, { name: \"img3\", maxCount: 1 },]), async (req, res) => {\r\n    try {\r\n        const {I_Id, I_name, descrip, color, material, price, warrantyPeriod, stockQty, bookedQty, availableQty, maincategory, sub_one, sub_two, suppliers,} = req.body;\r\n\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required.\" });\r\n        }\r\n\r\n        // ✅ Log received files and form data\r\n        const [itemCheckResult] = await db.query(`SELECT * FROM Item WHERE I_Id = ?`, [I_Id]);\r\n        if (itemCheckResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found.\" });\r\n        }\r\n\r\n        const parsedPrice = parseFloat(price) || 0;\r\n\r\n        // ✅ Properly extract image buffers\r\n        const imgBuffer = req.files[\"img\"]?.[0]?.buffer || null;\r\n        const img1Buffer = req.files[\"img1\"]?.[0]?.buffer || null;\r\n        const img2Buffer = req.files[\"img2\"]?.[0]?.buffer || null;\r\n        const img3Buffer = req.files[\"img3\"]?.[0]?.buffer || null;\r\n\r\n        // ✅ Fetch subcategory names\r\n        let subCatOneName = null;\r\n        let subCatTwoName = sub_two !== \"None\" ? null : \"None\";\r\n\r\n        if (sub_one) {\r\n            const [subOneResult] = await db.query(`SELECT subcategory FROM subCat_one WHERE sb_c_id = ?`, [sub_one]);\r\n            subCatOneName = subOneResult[0]?.subcategory || null;\r\n        }\r\n\r\n        if (sub_two !== \"None\") {\r\n            const [subTwoResult] = await db.query(`SELECT subcategory FROM subCat_two WHERE sb_cc_id = ?`, [sub_two]);\r\n            subCatTwoName = subTwoResult[0]?.subcategory || null;\r\n        }\r\n\r\n        let updateFields = [];\r\n        let updateValues = [];\r\n\r\n        // ✅ Dynamic field updates\r\n        const fields = {\r\n            I_name, descrip, color, material, price: parsedPrice, warrantyPeriod, stockQty, bookedQty, availableQty, mn_Cat: maincategory, sb_catOne: subCatOneName, sb_catTwo: subCatTwoName, img: imgBuffer, img1: img1Buffer, img2: img2Buffer, img3: img3Buffer,\r\n        };\r\n\r\n        for (const key in fields) {\r\n            if (fields[key] !== undefined && fields[key] !== null) {\r\n                updateFields.push(`${key} = ?`);\r\n                updateValues.push(fields[key]);\r\n            }\r\n        }\r\n\r\n        if (updateFields.length > 0) {\r\n            const updateQuery = `UPDATE Item SET ${updateFields.join(\", \")} WHERE I_Id = ?`;\r\n            updateValues.push(I_Id);\r\n            await db.query(updateQuery, updateValues);\r\n        }\r\n\r\n        // ✅ Handle suppliers\r\n        if (suppliers) {\r\n            let supplierData = typeof suppliers === \"string\" ? JSON.parse(suppliers) : suppliers;\r\n            if (Array.isArray(supplierData)) {\r\n                for (const { s_ID, unit_cost } of supplierData) {\r\n                    const parsedUnitCost = parseFloat(unit_cost) || 0;\r\n                    await db.query(\r\n                        `INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n                         VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost)`,\r\n                        [I_Id, s_ID, parsedUnitCost]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        res.status(200).json({\r\n            success: true,\r\n            message: \"Item updated successfully\",\r\n            data: { I_Id, I_name },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"❌ Error updating item:\", err.message);\r\n        res.status(500).json({ success: false, message: \"Error updating item\", details: err.message });\r\n    }\r\n});\r\n\r\n// Save a order\r\nrouter.post(\"/orders\", async (req, res) => {\r\n    try {\r\n        const {\r\n            dvStatus,\r\n            address,\r\n            city,\r\n            district,\r\n            email,\r\n            name,\r\n            phoneNumber,\r\n            otherNumber,\r\n            items,\r\n            totalBillPrice,\r\n            deliveryPrice,\r\n            discountAmount,\r\n            totalItemPrice,\r\n            couponCode,\r\n            expectedDate,\r\n            specialNote,\r\n        } = req.body;\r\n\r\n        console.log(expectedDate);\r\n\r\n        // Calculate net total and balance\r\n        const netTotal = parseFloat(totalBillPrice);\r\n        const advance = 0;\r\n        const balance = netTotal - parseFloat(advance);\r\n\r\n        // Generate unique order ID\r\n        const orID = `ORD_${Date.now()}`;\r\n        const orderDate = new Date().toISOString().split(\"T\")[0];\r\n\r\n        // Initialize stID and c_ID\r\n        let stID = null;\r\n        let c_ID = null;\r\n\r\n        // Check if customer already exists\r\n        const customerQuery = `\r\n            SELECT c_ID FROM Customer \r\n            WHERE contact1 = ? OR contact2 = ?\r\n        `;\r\n        const [customerResult] = await db.query(customerQuery, [phoneNumber, otherNumber]);\r\n\r\n        if (customerResult.length > 0) {\r\n            // Customer exists, get their ID\r\n            c_ID = customerResult[0].c_ID;\r\n        } else {\r\n            // Customer does not exist, insert new customer\r\n            const insertCustomerQuery = `\r\n                INSERT INTO Customer (email, address, contact1, contact2, excessAmount)\r\n                VALUES (?, ?, ?, ?, ?)\r\n            `;\r\n            const [newCustomer] = await db.query(insertCustomerQuery, [email, address, phoneNumber, otherNumber, 0]);\r\n            c_ID = newCustomer.insertId; // Get the newly inserted customer ID\r\n        }\r\n\r\n        // Check if a coupon is provided and get stID\r\n        if (couponCode) {\r\n            const couponQuery = `SELECT stID FROM sales_coupon WHERE cpID = ?`;\r\n            const [couponResult] = await db.query(couponQuery, [couponCode]);\r\n\r\n            if (couponResult.length === 0) {\r\n                return res.status(400).json({\r\n                    success: false,\r\n                    message: \"Invalid coupon code\"\r\n                });\r\n            }\r\n\r\n            stID = couponResult[0].stID;\r\n\r\n            // Update sales team total order amount\r\n            const newTotalOrder = parseFloat(totalItemPrice) - parseFloat(discountAmount);\r\n            const updateSalesTeamQuery = `\r\n                UPDATE sales_team SET totalOrder = totalOrder + ? WHERE stID = ?\r\n            `;\r\n            await db.query(updateSalesTeamQuery, [newTotalOrder, stID]);\r\n        }\r\n\r\n        // Insert Order with the found or new c_ID\r\n        let orderQuery = `\r\n            INSERT INTO Orders (OrID, orDate, custName, customerEmail, contact1, contact2, orStatus, delStatus, city, delPrice, discount, total, stID, expectedDate, specialNote, ordertype, advance, balance, payStatus)\r\n            VALUES (?, ?, ?, ?, ?, ?, 'Pending', ?, ?, ?, ?, ?, ?, ?, ?, 'on-site', ?, ?, 'Pending')`;\r\n        let orderParams = [\r\n            orID, orderDate, name, email, phoneNumber, otherNumber, dvStatus, city,\r\n            parseFloat(deliveryPrice), parseFloat(discountAmount), parseFloat(totalBillPrice),\r\n            stID, expectedDate, specialNote, advance, balance\r\n        ];\r\n\r\n        await db.query(orderQuery, orderParams);\r\n\r\n        // Insert Order Details\r\n        for (const item of items) {\r\n            let orderDetailQuery = `\r\n                INSERT INTO Order_Detail (orID, I_Id, qty, tprice)\r\n                VALUES (?, ?, ?, ?)`;\r\n            let orderDetailParams = [orID, item.I_Id, item.qty, parseFloat(item.price)];\r\n\r\n            await db.query(orderDetailQuery, orderDetailParams);\r\n        }\r\n\r\n        // Insert Delivery Info if delivery is selected\r\n        if (dvStatus === \"Delivery\") {\r\n            const dvID = `DLV_${Date.now()}`;\r\n            let deliveryQuery = `\r\n                INSERT INTO delivery (dv_id, orID, address, district, contact, status, schedule_Date)\r\n                VALUES (?, ?, ?, ?, ?, 'Pending', ?)`;\r\n            let deliveryParams = [dvID, orID, address, district, phoneNumber, expectedDate];\r\n\r\n            await db.query(deliveryQuery, deliveryParams);\r\n        }\r\n\r\n        // Insert Coupon Info if a coupon is used\r\n        if (couponCode) {\r\n            const ocID = `OCP_${Date.now()}`;\r\n            let couponQuery = `\r\n                INSERT INTO order_coupon (ocID, orID, cpID)\r\n                VALUES (?, ?, ?)`;\r\n            let couponParams = [ocID, orID, couponCode];\r\n\r\n            await db.query(couponQuery, couponParams);\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Order placed successfully\",\r\n            data: {\r\n                orID: orID,\r\n                orderDate: orderDate,\r\n                expectedDate: expectedDate\r\n            },\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error inserting order data:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get all orders\r\nrouter.get(\"/orders\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all Orders\r\n        const [orders] = await db.query(\"SELECT * FROM Orders\");\r\n\r\n        // If no promotions found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Orders found\" });\r\n        }\r\n\r\n\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID : order.OrID, // Assuming you have an id column\r\n            orDate : order.orDate,\r\n            customerEmail : order.customerEmail,\r\n            ordertype : order.ordertype,\r\n            orStatus : order.orStatus,\r\n            delStatus : order.delStatus,\r\n            delPrice : order.delPrice,\r\n            disPrice : order.discount,\r\n            totPrice : order.total,\r\n            advance : order.advance,\r\n            balance : order.balance,\r\n            payStatus : order.payStatus,\r\n            stID:  order.stID,\r\n            expectedDeliveryDate: order.expectedDate\r\n        }));\r\n        // console.log(formattedOrders);\r\n\r\n        // Send the formatted promotions as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Orders are founded.\",\r\n            data : formattedOrders,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching promotions:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching promotions\" });\r\n    }\r\n});\r\n\r\n// Get all items\r\nrouter.get(\"/allitems\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [items] = await db.query(\"SELECT * FROM Item\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (items.length === 0) {\r\n            return res.status(404).json({ message: \"No items found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedItems = items.map(item => ({\r\n            I_Id: item.I_Id, // Item ID\r\n            I_name: item.I_name, // Item name\r\n            descrip: item.descrip, // Item description\r\n            price: item.price, // Price\r\n            stockQty: item.stockQty, // Quantity\r\n            availableQty : item.availableQty, // available stock\r\n            warrantyPeriod: item.warrantyPeriod,\r\n            img: `data:image/png;base64,${item.img.toString(\"base64\")}`, // Convert LONGBLOB image to Base64\r\n            color: item.color,\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedItems);\r\n    } catch (error) {\r\n        console.error(\"Error fetching items:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching items\" });\r\n    }\r\n});\r\n\r\n// Get all delivery notes\r\nrouter.get(\"/alldeliverynotes\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [deliveryNotes] = await db.query(\"SELECT * FROM delivery_note\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (deliveryNotes.length === 0) {\r\n            return res.status(404).json({ message: \"No deliveries found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedDeliveryNotes = deliveryNotes.map(deliverynote => ({\r\n            delNoID: deliverynote.delNoID,\r\n            driverName: deliverynote.driverName,\r\n            date: deliverynote.date,\r\n            district: deliverynote.district\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedDeliveryNotes);\r\n    } catch (error) {\r\n        console.error(\"Error fetching deliveries:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching deliveries\" });\r\n    }\r\n});\r\n\r\n// Get all deliveries\r\nrouter.get(\"/alldeliveries\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [deliveries] = await db.query(\"SELECT * FROM delivery\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (deliveries.length === 0) {\r\n            return res.status(404).json({ message: \"No deliveries found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedDeliveries = deliveries.map(delivery => ({\r\n            dv_id: delivery.dv_id,\r\n            orID: delivery.orID,\r\n            district: delivery.district,\r\n            status: delivery.status,\r\n            schedule_Date: delivery.schedule_Date,\r\n            delivery_Date: delivery.delivery_Date,\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedDeliveries);\r\n    } catch (error) {\r\n        console.error(\"Error fetching deliveries:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching deliveries\" });\r\n    }\r\n});\r\n\r\n//add a new supplier and items\r\nrouter.post(\"/supplier\", async (req, res) => {\r\n    const { name, contact, contact2, address} = req.body;\r\n\r\n    // Generate new supplier ID\r\n    const s_ID = await generateNewId(\"supplier\", \"s_ID\", \"S\");\r\n    console.log(s_ID);\r\n    const sqlInsertSupplier = `\r\n        INSERT INTO Supplier (s_ID, name, address, contact, contact2)\r\n        VALUES (?, ?, ?, ?, ?)`;\r\n    const valuesSupplier = [\r\n        s_ID,\r\n        name,\r\n        address,\r\n        contact,\r\n        contact2 || \"\", // If contact2 is empty, set it as an empty string\r\n    ];\r\n\r\n    try {\r\n        // Insert the supplier into the Supplier table\r\n        await db.query(sqlInsertSupplier, valuesSupplier);\r\n\r\n        // Respond with success message and new supplier details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Supplier  added successfully\",\r\n            data: {\r\n                s_ID,\r\n                name,\r\n                contact,\r\n                contact2,\r\n                address,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting supplier  data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get one accept order in-detail\r\nrouter.get(\"/accept-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info with Sales Team Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.contact1, o.contact2,o.advance,o.balance,o.payStatus,\r\n                o.orStatus, o.delStatus, o.delPrice, o.discount, o.total, o.ordertype,o.stID,\r\n                o.expectedDate, o.specialNote, s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items with Updated Stock Fields\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Booked Items\r\n        const bookedItemsQuery = `\r\n            SELECT bi.I_Id, i.I_name, bi.qty\r\n            FROM booked_item bi\r\n                     JOIN Item i ON bi.I_Id = i.I_Id\r\n            WHERE bi.orID = ?`;\r\n\r\n        const [bookedItemsResult] = await db.query(bookedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Fetch Accepted Orders\r\n        const acceptedOrdersQuery = `\r\n            SELECT ao.I_Id, i.I_name, ao.itemReceived, ao.status\r\n            FROM accept_orders ao\r\n                     JOIN Item i ON ao.I_Id = i.I_Id\r\n            WHERE ao.orID = ?`;\r\n\r\n        const [acceptedOrdersResult] = await db.query(acceptedOrdersQuery, [orID]);\r\n\r\n        // 5\uFE0F⃣ Initialize Response Object\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate: new Date(orderData.orDate).toLocaleDateString('en-CA'),\r\n            customerEmail: orderData.customerEmail,\r\n            ordertype : orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            saleID: orderData.stID,\r\n            totalPrice: orderData.total,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus : orderData.payStatus,\r\n            expectedDeliveryDate: new Date(orderData.expectedDate).toLocaleDateString('en-CA'),\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty,\r\n                color: item.color,\r\n                price: item.tprice,\r\n                unitPrice: item.unitPrice,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty // Updated field from Item table\r\n            })),\r\n            bookedItems: bookedItemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty\r\n            })),\r\n            acceptedOrders: acceptedOrdersResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                itemReceived: item.itemReceived,\r\n                status: item.status\r\n            }))\r\n        };\r\n\r\n        // 6\uFE0F⃣ Fetch Delivery Info If Order is for Delivery\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, contact, status, schedule_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: deliveryData.schedule_Date,\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get Details of isssued order\r\nrouter.get(\"/issued-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info with Sales Team Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.contact1, o.contact2, o.advance, o.balance, o.payStatus,\r\n                o.orStatus, o.delStatus, o.delPrice, o.discount, o.total, o.ordertype, o.stID,\r\n                o.expectedDate, o.specialNote, s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items with Updated Stock Fields\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Issued Items for this Order from `m_s_r_detail`\r\n        const issuedItemsQuery = `\r\n            SELECT\r\n                m.I_Id, i.I_name, m.stock_Id, m.sr_ID, m.barcode, m.status, m.datetime\r\n            FROM m_s_r_detail m\r\n                     JOIN Item i ON m.I_Id = i.I_Id\r\n            WHERE m.orID = ?`;\r\n\r\n        const [issuedItemsResult] = await db.query(issuedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Initialize Response Object\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate: orderData.orDate,\r\n            customerEmail: orderData.customerEmail,\r\n            ordertype: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            saleID: orderData.stID,\r\n            totalPrice: orderData.total,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            expectedDeliveryDate: orderData.expectedDate,\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty,\r\n                color: item.color,\r\n                price: item.tprice,\r\n                unitPrice: item.unitPrice,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty\r\n            })),\r\n            issuedItems: issuedItemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                stockId: item.stock_Id,\r\n                srID: item.sr_ID,\r\n                barcode: item.barcode.toString('base64'), // Convert to readable format if needed\r\n                status: item.status,\r\n                datetime: item.datetime\r\n            }))\r\n        };\r\n\r\n        // 5\uFE0F⃣ Fetch Delivery Info If Order is for Delivery\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, contact, status, schedule_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: deliveryData.schedule_Date,\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get one order in-detail\r\nrouter.get(\"/order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // Fetch Order Info along with Sales Team details (Employee Name)\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.contact1, o.contact2, o.orStatus, o.delStatus,\r\n                o.delPrice, o.discount, o.total, o.advance , o.balance, o.payStatus, o.expectedDate,\r\n                o.specialNote, o.ordertype, s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        const orderData = orderResult[0];\r\n\r\n        // Fetch Ordered Items with Updated Stock Fields\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id,\r\n                i.I_name,\r\n                i.color,\r\n                od.qty,\r\n                od.tprice,\r\n                i.price AS unitPrice,\r\n                i.bookedQty,\r\n                i.availableQty,\r\n                i.stockQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // Prepare the order response\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate: new Date(orderData.orDate).toLocaleDateString('en-CA'), // Fix date issue\r\n            customerEmail: orderData.customerEmail,\r\n            ordertype: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            totalPrice: orderData.total,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus : orderData.payStatus,\r\n            expectedDeliveryDate: new Date(orderData.expectedDate).toLocaleDateString('en-CA'), // Fix date issue\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: [],\r\n        };\r\n\r\n        // If order is \"Accepted\", fetch booked items and accept_orders\r\n        if (orderData.orStatus === \"Accepted\") {\r\n            for (const item of itemsResult) {\r\n                let itemReceived = \"No\";\r\n                let itemStatus = \"Incomplete\";\r\n\r\n                // Fetch accept order data\r\n                const acceptQuery = `SELECT itemReceived, status FROM accept_orders WHERE orID = ? AND I_Id = ?`;\r\n                const [acceptResult] = await db.query(acceptQuery, [orID, item.I_Id]);\r\n                if (acceptResult.length > 0) {\r\n                    itemReceived = acceptResult[0].itemReceived;\r\n                    itemStatus = acceptResult[0].status;\r\n                }\r\n\r\n                orderResponse.items.push({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    price: item.tprice,\r\n                    color: item.color,\r\n                    quantity: item.qty,\r\n                    unitPrice: item.unitPrice,\r\n                    booked: item.bookedQty > 0, // true if the item is booked\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty, // Updated field from Item table\r\n                    stockQuantity: item.stockQty,\r\n                    itemReceived: itemReceived,\r\n                    itemStatus: itemStatus\r\n                });\r\n            }\r\n        } else {\r\n            // If order is not \"Accepted\", return normal item details\r\n            orderResponse.items = itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty,\r\n                price: item.tprice,\r\n                color: item.color,\r\n                unitPrice: item.unitPrice,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty, // Updated field\r\n                stockQuantity: item.stockQty\r\n            }));\r\n        }\r\n\r\n        // If it's a delivery order, fetch delivery details\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, contact, status, schedule_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: deliveryData.schedule_Date,\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// GET Item Details by Item ID\r\nrouter.get(\"/item-details\", async (req, res) => {\r\n    try {\r\n        const { I_Id } = req.query;\r\n\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // ✅ Fetch item details from Item table\r\n        const itemQuery = `\r\n            SELECT\r\n                I.I_Id, I.I_name, I.descrip, I.price, I.stockQty, I.bookedQty, I.availableQty, I.minQTY,\r\n                I.warrantyPeriod, I.img, I.img1, I.img2, I.img3, I.color, I.material, I.mn_Cat, I.sb_catOne, I.sb_catTwo\r\n            FROM Item I\r\n            WHERE I.I_Id = ?`;\r\n\r\n        const [itemResult] = await db.query(itemQuery, [I_Id]);\r\n\r\n        if (itemResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found\" });\r\n        }\r\n\r\n        const itemData = itemResult[0];\r\n\r\n        // ✅ Convert images to Base64\r\n        const mainImgBase64 = itemData.img ? Buffer.from(itemData.img).toString(\"base64\") : null;\r\n        const img1Base64 = itemData.img1 ? Buffer.from(itemData.img1).toString(\"base64\") : null;\r\n        const img2Base64 = itemData.img2 ? Buffer.from(itemData.img2).toString(\"base64\") : null;\r\n        const img3Base64 = itemData.img3 ? Buffer.from(itemData.img3).toString(\"base64\") : null;\r\n\r\n        // ✅ Fetch suppliers providing this item\r\n        const supplierQuery = `\r\n            SELECT S.s_ID, S.name, S.contact, ISUP.unit_cost\r\n            FROM Supplier S\r\n                     JOIN item_supplier ISUP ON S.s_ID = ISUP.s_ID\r\n            WHERE ISUP.I_Id = ?`;\r\n\r\n        const [suppliersResult] = await db.query(supplierQuery, [I_Id]);\r\n\r\n        const suppliers = suppliersResult.map(supplier => ({\r\n            s_ID: supplier.s_ID,\r\n            name: supplier.name,\r\n            contact: supplier.contact,\r\n            unit_cost: supplier.unit_cost\r\n        }));\r\n\r\n        // ✅ Fetch stock details **excluding** 'Issued' status, only include 'Available', 'Damage', 'Reserved'\r\n        const stockQuery = `\r\n            SELECT srd_Id, stock_Id, sr_ID, status\r\n            FROM m_s_r_detail\r\n            WHERE I_Id = ?\r\n              AND status IN ('Available', 'Damage', 'Reserved')\r\n            ORDER BY srd_Id ASC , FIELD(status, 'Available', 'Reserved', 'Damage')`;\r\n\r\n        const [stockResults] = await db.query(stockQuery, [I_Id]);\r\n        console.log(I_Id);\r\n\r\n        const stockDetails = stockResults.map(stock => ({\r\n            srd_Id: stock.srd_Id,\r\n            stock_Id: stock.stock_Id,\r\n            sr_ID: stock.sr_ID,\r\n            status: stock.status\r\n        }));\r\n        console.log(stockDetails);\r\n\r\n        // ✅ Construct final response\r\n        const responseData = {\r\n            success: true,\r\n            item: {\r\n                I_Id: itemData.I_Id,\r\n                I_name: itemData.I_name,\r\n                descrip: itemData.descrip,\r\n                color: itemData.color,\r\n                material: itemData.material,\r\n                price: itemData.price,\r\n                stockQty: itemData.stockQty,\r\n                availableQty: itemData.availableQty,\r\n                bookedQty: itemData.bookedQty,\r\n                warrantyPeriod: itemData.warrantyPeriod,\r\n                minQTY: itemData.minQTY,\r\n                maincategory: itemData.mn_Cat,\r\n                sub_one: itemData.sb_catOne,\r\n                sub_two: itemData.sb_catTwo,\r\n                img: mainImgBase64,\r\n                img1: img1Base64,\r\n                img2: img2Base64,\r\n                img3: img3Base64,\r\n                suppliers: suppliers,\r\n                stockDetails: stockDetails // Only 'Available', 'Reserved', 'Damage'\r\n            }\r\n        };\r\n\r\n        return res.status(200).json(responseData);\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Error fetching item details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= pending\r\nrouter.get(\"/orders-pending\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all pending Orders\r\n        const [orders] = await db.query(\"SELECT * FROM Orders WHERE orStatus = 'pending'\");\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No pending orders found\" });\r\n        }\r\n\r\n        // Format orders\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID: order.OrID, // Order ID\r\n            orDate: order.orDate, // Order Date\r\n            customerEmail: order.customerEmail, // Customer Email\r\n            ordertype : order.ordertype,\r\n            orStatus: order.orStatus, // Order Status\r\n            dvStatus: order.delStatus, // Delivery Status\r\n            dvPrice: order.delPrice, // Delivery Price\r\n            disPrice: order.discount, // Discount Price\r\n            totPrice: order.total, // Total Price\r\n            advance: order.advance,\r\n            balance: order.balance,\r\n            payStatus : order.payStatus,\r\n            stID: order.stID, // Sales Team ID\r\n            expectedDeliveryDate: order.expectedDate, // Expected Delivery Date\r\n        }));\r\n\r\n        // Send the formatted orders as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching pending orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= accepting\r\nrouter.get(\"/orders-accepting\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Accepted'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customerEmail: order.customerEmail,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= completed\r\nrouter.get(\"/orders-completed\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Completed'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Completed orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customerEmail: order.customerEmail,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Completed orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching completed orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Fetch Issued order\r\nrouter.get(\"/orders-issued\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Issued'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Completed orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customerEmail: order.customerEmail,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Completed orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching completed orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Fetch Returned order\r\nrouter.get(\"/orders-returned\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Returned'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Completed orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customerEmail: order.customerEmail,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Completed orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching completed orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= inproduction\r\nrouter.get(\"/orders-inproduction\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all pending Orders\r\n        const [suporders] = await db.query(\"SELECT * FROM production WHERE status= 'Incomplete'\");\r\n\r\n        // If no orders found, return a 404 status\r\n        if (suporders.length === 0) {\r\n            return res.status(404).json({ message: \"No supplier orders found\" });\r\n        }\r\n\r\n        // Format orders\r\n        const formattedOrders = suporders.map(order => ({\r\n            p_ID : order.p_ID,\r\n            I_Id : order.I_Id,\r\n            qty : order.qty,\r\n            s_ID : order.s_ID,\r\n            expectedDate : order.expectedDate,\r\n            specialNote: order.specialNote,\r\n            status: order.status\r\n        }));\r\n\r\n        // Send the formatted orders as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching pending orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all items where stock count is less than or equal to one\r\nrouter.get(\"/allitemslessone\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch items with qty <= 1\r\n        const [items] = await db.query(\r\n            \"SELECT I_Id, I_name, descrip, price,stockQty, availableQty, img FROM Item WHERE availableQty <= minQTY\"\r\n        );\r\n\r\n        // If no items found, return a 404 status with a descriptive message\r\n        if (items.length === 0) {\r\n            return res.status(404).json({ message: \"No items found with stock count less than or equal to 1\" });\r\n        }\r\n\r\n        // Format the items data with necessary fields\r\n        const formattedItems = items.map(item => ({\r\n            I_Id: item.I_Id,\r\n            I_name: item.I_name,\r\n            descrip: item.descrip,\r\n            price: item.price,\r\n            availableQty: item.availableQty,\r\n            stockQty: item.stockQty,\r\n            img: `data:image/png;base64,${item.img.toString(\"base64\")}`, // Convert image to base64\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedItems);\r\n    } catch (error) {\r\n        console.error(\"Error fetching items:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching items\" });\r\n    }\r\n});\r\n\r\n// get all suppliers for the item\r\nrouter.get(\"/item-suppliers\", async (req, res) => {\r\n    try {\r\n        const { I_Id } = req.query;\r\n\r\n        // Validate the input\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Step 1: Fetch the suppliers associated with the item from item_supplier table\r\n        const itemSuppliersQuery = `\r\n            SELECT s_ID\r\n            FROM item_supplier\r\n            WHERE I_Id = ?`;\r\n\r\n        const [itemSuppliersResult] = await db.query(itemSuppliersQuery, [I_Id]);\r\n\r\n        if (itemSuppliersResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No suppliers found for the given item\" });\r\n        }\r\n\r\n        // Step 2: Extract the supplier IDs from the result\r\n        const supplierIds = itemSuppliersResult.map(row => row.s_ID);\r\n\r\n        // Step 3: Fetch the supplier details using the supplier IDs\r\n        const suppliersQuery = `\r\n            SELECT s_ID, name, contact\r\n            FROM Supplier\r\n            WHERE s_ID IN (?)`;\r\n\r\n        const [suppliersResult] = await db.query(suppliersQuery, [supplierIds]);\r\n\r\n        // Step 4: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            suppliers: suppliersResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item suppliers:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// get all items for the supplier\r\nrouter.get(\"/supplier-items\", async (req, res) => {\r\n    try {\r\n        const { s_Id } = req.query;\r\n\r\n        // Validate input\r\n        if (!s_Id) {\r\n            return res.status(400).json({ success: false, message: \"Supplier ID is required\" });\r\n        }\r\n\r\n        // Query to fetch supplier's items along with cost, warranty period, and image\r\n        const query = `\r\n            SELECT\r\n                item_supplier.I_Id,\r\n                Item.I_name,\r\n                item_supplier.unit_cost,\r\n                Item.warrantyPeriod,\r\n                Item.img  -- Fetch the binary image (LONGBLOB)\r\n            FROM item_supplier\r\n                     JOIN Item ON Item.I_Id = item_supplier.I_Id\r\n            WHERE item_supplier.s_ID = ?\r\n        `;\r\n\r\n        const [itemsResult] = await db.query(query, [s_Id]);\r\n\r\n        // If no items found, return a 404 response\r\n        if (itemsResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No items found for the given supplier\" });\r\n        }\r\n\r\n        // Convert image binary data to Base64\r\n        const itemsWithImages = itemsResult.map(item => ({\r\n            ...item,\r\n            img: item.img ? `data:image/jpeg;base64,${item.img.toString('base64')}` : null  // Convert LONGBLOB to Base64\r\n        }));\r\n\r\n        // Return the supplier's items with cost, warranty period, and image\r\n        return res.status(200).json({\r\n            success: true,\r\n            items: itemsWithImages,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching supplier items:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all suppliers\r\nrouter.get(\"/suppliers\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all suppliers\r\n        const suppliersQuery = `SELECT s_ID, name, contact,contact2,address FROM Supplier`;\r\n\r\n        const [suppliersResult] = await db.query(suppliersQuery);\r\n        // Step 2: Check if suppliers were found\r\n        if (suppliersResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No suppliers found\" });\r\n        }\r\n\r\n        // Step 3: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            suppliers: suppliersResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching suppliers:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// get item detail in item table only\r\nrouter.get(\"/item-detail\", async (req, res) => {\r\n    try {\r\n        const { Id } = req.query;\r\n\r\n        if (!Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Step 1: Fetch Item details\r\n        const itemQuery = `\r\n            SELECT\r\n                I.I_Id, I.I_name, I.descrip, I.price, I.stockQty,I.bookedQty,I.availableQty,\r\n                I.warrantyPeriod, I.img\r\n            FROM Item I\r\n            WHERE I.I_Id = ?`;\r\n\r\n        const [itemResult] = await db.query(itemQuery, [Id]);\r\n\r\n        if (itemResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found\" });\r\n        }\r\n\r\n        const itemData1 = itemResult[0];\r\n        // Step 2: Construct final response\r\n        const responseData = {\r\n            success: true,\r\n            item: {\r\n                I_Id: itemData1.I_Id,\r\n                I_name: itemData1.I_name,\r\n                price: itemData1.price,\r\n                stockQty: itemData1.stockQty,\r\n                bookedQty: itemData1.bookedQty,\r\n                availableQty: itemData1.availableQty,\r\n            }\r\n        };\r\n\r\n        return res.status(200).json(responseData);\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// save in production\r\nrouter.post('/add-production', async (req, res) => {\r\n    const {itemId, qty, supplierId, expectedDate, specialnote} = req.body;\r\n\r\n    if (!itemId || !qty || !supplierId || !expectedDate) {\r\n        return res.status(400).json({error: 'All fields are required'});\r\n    }\r\n\r\n    const p_ID = `InP_${Date.now()}`;\r\n\r\n    const sql = `INSERT INTO production (p_ID, I_Id, qty, s_ID, expectedDate, specialNote,status)\r\n                 VALUES (?, ?, ?, ?, ?, ?,'Incomplete')`;\r\n    const [Result] = await db.query(sql, [p_ID, itemId, qty, supplierId, expectedDate, specialnote]);\r\n    return res.status(200).json({\r\n        success: true,\r\n        message: \"Order details fetched successfully\",\r\n        result: Result\r\n    });\r\n});\r\n\r\n// Get category namees\r\nrouter.get(\"/getcategory\", async (req, res) => {\r\n    const { category } = req.query;\r\n\r\n    // Check if category is provided\r\n    if (!category) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Category is required\",\r\n        });\r\n    }\r\n\r\n    // SQL query to join Category and subCat_one based on category name\r\n    const sql = `\r\n        SELECT sc.sb_c_id, sc.subcategory, sc.img, c.name AS category\r\n        FROM subCat_one sc\r\n                 INNER JOIN Category c ON sc.Ca_Id = c.Ca_Id\r\n        WHERE c.name = ?\r\n    `;\r\n\r\n    try {\r\n        const [rows] = await db.query(sql, [category]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No images found for the given category\",\r\n            });\r\n        }\r\n\r\n        // Send back the response with image data\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Category images retrieved successfully\",\r\n            data: rows.map(row => ({\r\n                id: row.sb_c_id,\r\n                category: row.category,\r\n                subcategory: row.subcategory,\r\n                img: row.img.toString(\"base64\"), // Convert binary image to Base64\r\n            })),\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Update stock\r\nrouter.post(\"/update-stock\", upload.single(\"image\"), async (req, res) => {\r\n    const { p_ID, rDate, recCount, cost, detail } = req.body;\r\n    const imageFile = req.file;\r\n\r\n    if (!p_ID || !rDate || !recCount) {\r\n        return res.status(400).json({ error: \"All fields are required\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch current quantity and item details from production\r\n        const [rows] = await db.query(\"SELECT qty, I_Id, s_ID FROM production WHERE p_ID = ?\", [p_ID]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({ error: \"Production order not found\" });\r\n        }\r\n\r\n        const currentQty = rows[0].qty;\r\n        const itemId = rows[0].I_Id;\r\n        const supId = rows[0].s_ID;\r\n        const receivedQty = parseInt(recCount, 10);\r\n\r\n        // Validate that the item exists in the `item` table\r\n        const [itemExists] = await db.query(\"SELECT I_Id FROM item WHERE I_Id = ?\", [itemId]);\r\n\r\n        if (itemExists.length === 0) {\r\n            return res.status(400).json({ error: \"Item ID does not exist in item table\" });\r\n        }\r\n\r\n        console.log(\"Validated Item ID:\", itemId);\r\n\r\n        // Handle image upload\r\n        let imagePath = null;\r\n        if (imageFile) {\r\n            const imageName = `item_${itemId}_${Date.now()}.${imageFile.mimetype.split(\"/\")[1]}`;\r\n            const savePath = path.join(\"./uploads/images\", imageName);\r\n            fs.writeFileSync(savePath, imageFile.buffer);\r\n            imagePath = `/uploads/images/${imageName}`;\r\n        }\r\n\r\n        // Insert into main_stock_received\r\n        const insertQuery = `\r\n            INSERT INTO main_stock_received (s_ID, I_Id, rDate, rec_count, unitPrice, detail)\r\n            VALUES (?, ?, ?, ?, ?, ?)`;\r\n        const [result] = await db.query(insertQuery, [supId, itemId, rDate, receivedQty, cost, detail || \"\"]);\r\n        console.log(result);\r\n        const receivedStockId = result.insertId;\r\n        console.log(receivedStockId);\r\n\r\n        // Fetch last stock_Id for this item\r\n        const [lastStockResult] = await db.query(\r\n            `SELECT MAX(stock_Id) AS lastStockId FROM m_s_r_detail WHERE I_Id = ?`,\r\n            [itemId]\r\n        );\r\n\r\n        let lastStockId = lastStockResult[0]?.lastStockId || 0;\r\n\r\n        const insertDetailQuery = `\r\n            INSERT INTO m_s_r_detail (I_Id, stock_Id, sr_ID, barcode,status,orID,datetime)\r\n            VALUES (?, ?, ?, ?,'Available','','')`;\r\n        console.log(insertDetailQuery);\r\n\r\n        // Ensure barcode folder exists\r\n        const barcodeFolderPath = path.join(\"./uploads/barcodes\");\r\n        if (!fs.existsSync(barcodeFolderPath)) {\r\n            fs.mkdirSync(barcodeFolderPath, { recursive: true });\r\n        }\r\n\r\n        // Ensure `stockCount` is properly defined\r\n        const stockCount = receivedQty;\r\n\r\n        for (let i = 1; i <= stockCount; i++) {\r\n            lastStockId++;\r\n\r\n            // Generate barcode data\r\n            const barcodeData = `${itemId}-${lastStockId}-${receivedStockId}`;\r\n            const barcodeImageName = `barcode_${barcodeData}.png`;\r\n            const barcodeImagePath = path.join(barcodeFolderPath, barcodeImageName);\r\n\r\n            // Generate barcode image\r\n            const pngBuffer = await bwipjs.toBuffer({\r\n                bcid: \"code128\",\r\n                text: barcodeData,\r\n                scale: 3,\r\n                height: 10,\r\n                includetext: true,\r\n                textxalign: \"center\",\r\n            });\r\n\r\n            // Save barcode image to folder\r\n            fs.writeFileSync(barcodeImagePath, pngBuffer);\r\n\r\n            // Save barcode data in the database\r\n            const query = await db.query(insertDetailQuery, [itemId, lastStockId, receivedStockId, pngBuffer]);\r\n        }\r\n\r\n        // Determine new stock status\r\n        let newStatus = \"Incomplete\";\r\n        let newQty = currentQty - receivedQty;\r\n\r\n        if (receivedQty >= currentQty) {\r\n            newStatus = \"Complete\";\r\n            newQty = 0;\r\n        }\r\n\r\n        // Update production table\r\n        const sqlUpdate = `UPDATE production SET qty = ?, status = ? WHERE p_ID = ?`;\r\n        await db.query(sqlUpdate, [newQty, newStatus, p_ID]);\r\n\r\n        // Update stock quantity in Item table\r\n        const sqlUpdateItem = `UPDATE Item SET stockQty = stockQty + ? WHERE I_Id = ?`;\r\n        await db.query(sqlUpdateItem, [receivedQty, itemId]);\r\n\r\n        const sqlUpdateItem1 = `UPDATE Item SET availableQty = availableQty + ? WHERE I_Id = ?`;\r\n        await db.query(sqlUpdateItem1, [receivedQty, itemId]);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Stock received updated successfully\",\r\n            updatedStatus: newStatus,\r\n            remainingQty: newQty,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating stock received:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\", details: error.message });\r\n    }\r\n});\r\n\r\n// Update order in invoice part\r\nrouter.put(\"/update-invoice\", async (req, res) => {\r\n    try {\r\n        console.log(req.body);\r\n\r\n        const {\r\n            orID,\r\n            isPickup,\r\n            netTotal,\r\n            totalAdvance,\r\n            previousAdvance,\r\n            balance,\r\n            addedAdvance,\r\n            updatedDeliveryCharge,\r\n            updatedDiscount\r\n        } = req.body;\r\n\r\n        if (!orID) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"Order ID is required\",\r\n            });\r\n        }\r\n\r\n        // \uD83D\uDD0D Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM Orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orID]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"Order not found\",\r\n            });\r\n        }\r\n\r\n        // \uD83D\uDD04 Determine Payment Status\r\n        let payStatus = \"Pending\"; // Default status\r\n\r\n        if (totalAdvance > 0) {\r\n            payStatus = \"Advanced\"; // Some advance payment has been made\r\n        }\r\n\r\n        if (balance === 0) {\r\n            payStatus = \"Settled\"; // Fully paid order\r\n        }\r\n\r\n        // \uD83D\uDD04 Update Orders table\r\n        const orderUpdateQuery = `\r\n            UPDATE Orders\r\n            SET total = ?, discount = ?, delPrice = ?, advance = ?, balance = ?, payStatus = ?\r\n            WHERE OrID = ?`;\r\n        const orderUpdateParams = [netTotal, updatedDiscount, updatedDeliveryCharge, totalAdvance, balance, payStatus, orID];\r\n        await db.query(orderUpdateQuery, orderUpdateParams);\r\n\r\n        // \uD83D\uDED1 If it's a pickup order, remove it from the delivery table\r\n        if (isPickup) {\r\n            const deleteDeliveryQuery = `DELETE FROM delivery WHERE orID = ?`;\r\n            await db.query(deleteDeliveryQuery, [orID]);\r\n        }\r\n\r\n        // \uD83D\uDD52 Get the current date and time\r\n        const currentDateTime = new Date().toISOString().slice(0, 19).replace(\"T\", \" \");\r\n\r\n        // \uD83D\uDCB0 Insert a new entry into the Payment table\r\n        if (addedAdvance > 0) {\r\n            const insertPaymentQuery = `\r\n                INSERT INTO Payment (orID, amount, dateTime)\r\n                VALUES (?, ?, ?)`;\r\n            const paymentParams = [orID, addedAdvance, currentDateTime];\r\n            await db.query(insertPaymentQuery, paymentParams);\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order and payment updated successfully\",\r\n            payStatus,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"❌ Error updating invoice:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating invoice data\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Fetch Accept orders in booked-unbooked\r\nrouter.get(\"/orders-accept\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all the orders and their associated items' statuses from the accept_orders table.\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Accepted'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        const groupedOrders = {};\r\n        const bookedOrders = [];\r\n        const unbookedOrders = [];\r\n\r\n        // Step 3: Process each order and its items.\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customerEmail: order.customerEmail,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    acceptanceStatuses: [],\r\n                    isUnbooked: false\r\n                };\r\n            }\r\n\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            if (order.acceptanceStatus !== \"Complete\") {\r\n                groupedOrders[order.OrID].isUnbooked = true;\r\n            }\r\n        });\r\n\r\n        // Step 4: Categorize orders.\r\n        Object.values(groupedOrders).forEach(order => {\r\n            if (order.isUnbooked) {\r\n                order.acceptanceStatus = \"Incomplete\";\r\n                unbookedOrders.push(order);\r\n            } else {\r\n                order.acceptanceStatus = \"Complete\";\r\n                bookedOrders.push(order);\r\n            }\r\n        });\r\n\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            bookedOrders: bookedOrders,\r\n            unbookedOrders: unbookedOrders\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Update order\r\nrouter.put(\"/update-order-details\", async (req, res) => {\r\n    try {\r\n        const { orderId, orderDate, customerEmail, phoneNumber, optionalNumber, orderStatus,payStatus,\r\n            deliveryStatus, deliveryCharge, discount, totalPrice,advance , balance , expectedDeliveryDate, specialNote } = req.body;\r\n\r\n        // Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orderId]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        if (advance === 0 && payStatus === 'Advanced'){\r\n\r\n            return res.status(404).json({ success: false, message: \"payement status cannot change to advance when advance is 0\" });\r\n        }\r\n\r\n        // Update order details\r\n        const orderUpdateQuery = `\r\n            UPDATE orders SET orDate = ?, customerEmail = ?, contact1 = ?, contact2 = ?, orStatus = ?, payStatus = ?,\r\n                              delStatus = ?, delPrice = ?, discount = ?, total = ?, advance = ?, balance = ?, expectedDate = ?, specialNote = ?\r\n            WHERE OrID = ?`;\r\n        await db.query(orderUpdateQuery, [\r\n            orderDate, customerEmail, phoneNumber, optionalNumber, orderStatus, payStatus, deliveryStatus,\r\n            deliveryCharge, discount, totalPrice, advance, balance, expectedDeliveryDate, specialNote, orderId\r\n        ]);\r\n        console.log(\"sucess\");\r\n        // return res.status(200).json({ success: true, message: \"Order details updated successfully\" });\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order updated successfully\",\r\n            data: {\r\n                orderId: orderId,\r\n                orderDate: orderDate,\r\n                expectedDeliveryDate: expectedDeliveryDate,\r\n            },\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order data:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating data in database\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\nrouter.put(\"/update-order-items\", async (req, res) => {\r\n    try {\r\n        const { orderId, orderStatus, items } = req.body;\r\n\r\n        if (!items || items.length === 0) {\r\n            return res.status(400).json({ success: false, message: \"No items provided.\" });\r\n        }\r\n// Fetch existing order details from the database\r\n        const checkOrderItemsQuery = `SELECT I_Id FROM Order_Detail WHERE orID = ?`;\r\n        const [existingRecords] = await db.query(checkOrderItemsQuery, [orderId]);\r\n\r\n        const existingItemIds = existingRecords.map(item => item.I_Id);\r\n        const newItemIds = items.map(item => item.itemId);\r\n\r\n// Identify items to remove (exist in DB but not in the request)\r\n        const itemsToRemove = existingItemIds.filter(id => !newItemIds.includes(id));\r\n\r\n        console.log(\"Existing records:\", existingItemIds);\r\n        console.log(\"New records:\", newItemIds);\r\n        console.log(\"Items to remove:\", itemsToRemove);\r\n\r\n// Remove missing items from Order_Detail\r\n        for (const itemId of itemsToRemove) {\r\n            const deleteOrderDetailQuery = `DELETE FROM Order_Detail WHERE orID = ? AND I_Id = ?`;\r\n            await db.query(deleteOrderDetailQuery, [orderId, itemId]);\r\n            const deleteAccceptDetailQuery = `DELETE FROM accept_orders WHERE orID = ? AND I_Id = ?`;\r\n            await db.query(deleteAccceptDetailQuery, [orderId, itemId]);\r\n        }\r\n\r\n// Update or Insert new items\r\n        for (const item of items){\r\n            //Check if the record exists in order detail table\r\n            const checkOrderDetailQuery = `SELECT * FROM Order_Detail WHERE orID = ? AND I_Id = ?`;\r\n            const [existingRecord] = await db.query(checkOrderDetailQuery, [orderId, item.itemId]);\r\n\r\n            if (existingRecord.length > 0) {\r\n                const updateAcceptOrderQuery = `UPDATE Order_Detail SET qty = ?, tprice = ? WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(updateAcceptOrderQuery, [item.quantity , item.price , orderId, item.itemId]);\r\n            } else {\r\n                const insertAcceptOrderQuery = `INSERT INTO Order_Detail (orID, I_Id, qty, tprice) VALUES (?, ?, ?, ?)`;\r\n                await db.query(insertAcceptOrderQuery, [orderId, item.itemId, item.quantity , item.price]);\r\n            }\r\n        }\r\n\r\n        // Ensure order status is 'Accepted' if any item is booked\r\n        const isAnyItemBooked = items.some(item => item.booked);\r\n        if (isAnyItemBooked && orderStatus !== \"Accepted\") {\r\n            return res.status(400).json({ success: false, message: \"Order status must be 'Accepted' if any item is booked.\" });\r\n        }\r\n\r\n        for (const item of items) {\r\n            const itemReceived = item.booked ? \"Yes\" : \"No\";\r\n            const itemStatus = item.booked ? \"Complete\" : \"Incomplete\";\r\n\r\n            // Check if the record exists in accept_orders\r\n            const checkAcceptOrderQuery = `SELECT * FROM accept_orders WHERE orID = ? AND I_Id = ?`;\r\n            const [existingRecord] = await db.query(checkAcceptOrderQuery, [orderId, item.itemId]);\r\n\r\n            if (existingRecord.length > 0) {\r\n                const updateAcceptOrderQuery = `UPDATE accept_orders SET itemReceived = ?, status = ? WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(updateAcceptOrderQuery, [itemReceived, itemStatus, orderId, item.itemId]);\r\n            } else {\r\n                const insertAcceptOrderQuery = `INSERT INTO accept_orders (orID, I_Id, itemReceived, status) VALUES (?, ?, ?, ?)`;\r\n                await db.query(insertAcceptOrderQuery, [orderId, item.itemId, itemReceived, itemStatus]);\r\n            }\r\n\r\n            // Handle booking & inventory\r\n            if (item.booked) {\r\n                const checkBookedItemQuery = `SELECT * FROM booked_item WHERE orID = ? AND I_Id = ?`;\r\n                const [existingBookedItem] = await db.query(checkBookedItemQuery, [orderId, item.itemId]);\r\n\r\n                if (existingBookedItem.length === 0) {\r\n                    const bookItemQuery = `INSERT INTO booked_item (orID, I_Id, qty) VALUES (?, ?, ?)`;\r\n                    await db.query(bookItemQuery, [orderId, item.itemId, item.quantity]);\r\n\r\n                    // Update inventory\r\n                    const updateItemQtyQuery = `UPDATE Item SET bookedQty = bookedQty + ?, availableQty = availableQty - ? WHERE I_Id = ?`;\r\n                    await db.query(updateItemQtyQuery, [item.quantity, item.quantity, item.itemId]);\r\n                }\r\n            } else {\r\n                // Remove from booked items & restore inventory\r\n                const deleteBookedItemQuery = `DELETE FROM booked_item WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(deleteBookedItemQuery, [orderId, item.itemId]);\r\n\r\n                const checkIfBookedQuery = `SELECT * FROM Item WHERE I_Id = ? AND bookedQty >= ?`;\r\n                const [bookedCheck] = await db.query(checkIfBookedQuery, [item.itemId, item.quantity]);\r\n\r\n                if (bookedCheck.length > 0) {\r\n                    const restoreStockQuery = `UPDATE Item SET bookedQty = bookedQty - ?, availableQty = availableQty + ? WHERE I_Id = ?`;\r\n                    await db.query(restoreStockQuery, [item.quantity, item.quantity, item.itemId]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Order items updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order items:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Database update failed\", details: error.message });\r\n    }\r\n});\r\nrouter.put(\"/update-delivery\", async (req, res) => {\r\n    try {\r\n        const { orderId, deliveryStatus, phoneNumber, deliveryInfo } = req.body;\r\n        console.log(orderId , deliveryInfo , deliveryStatus , phoneNumber);\r\n\r\n        if (!orderId || !deliveryStatus) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        if (deliveryStatus === \"Delivery\" && deliveryInfo) {\r\n            // Check if a delivery record already exists\r\n            const checkDeliveryQuery = `SELECT * FROM delivery WHERE orID = ?`;\r\n            const [existingDelivery] = await db.query(checkDeliveryQuery, [orderId]);\r\n\r\n            if (existingDelivery.length > 0) {\r\n                // Update existing delivery record\r\n                const deliveryUpdateQuery = `UPDATE delivery SET address = ?, district = ?, contact = ?, schedule_Date = ? WHERE orID = ?`;\r\n                await db.query(deliveryUpdateQuery, [deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate, orderId]);\r\n            } else {\r\n                // Insert new delivery record\r\n                const insertDeliveryQuery = `INSERT INTO delivery (orID, address, district, contact, schedule_Date) VALUES (?, ?, ?, ?, ?)`;\r\n                await db.query(insertDeliveryQuery, [orderId, deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate]);\r\n            }\r\n        }\r\n\r\n        if (deliveryStatus === \"Pick Up\") {\r\n            // Remove any existing delivery record\r\n            const deleteDeliveryQuery = `DELETE FROM delivery WHERE orID = ?`;\r\n            await db.query(deleteDeliveryQuery, [orderId]);\r\n\r\n            // Update the delivery price to 0 in orders\r\n            const updateDeliveryQuery = `UPDATE orders SET dvPrice = 0 WHERE orID = ?`;\r\n            await db.query(updateDeliveryQuery, [orderId]);\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Delivery information updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating delivery information:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Database update failed\", details: error.message });\r\n    }\r\n});\r\n\r\n//Get All sale team members\r\nrouter.get(\"/salesteam\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all sales team members\r\n        const [salesTeam] = await db.query(`\r\n            SELECT\r\n                st.stID,\r\n                st.orderTarget,\r\n                st.issuedTarget,\r\n                st.totalOrder,\r\n                st.totalIssued,\r\n                e.E_Id,\r\n                e.name AS employeeName,\r\n                e.address,\r\n                e.nic,\r\n                e.dob,\r\n                e.contact,\r\n                e.job,\r\n                e.basic\r\n            FROM sales_team st\r\n                     JOIN Employee e ON st.E_Id = e.E_Id;\r\n        `);\r\n\r\n        // If no sales team members found, return a 404 status\r\n        if (salesTeam.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team members found\" });\r\n        }\r\n\r\n        // Format the response data\r\n        const formattedSalesTeam = salesTeam.map(member => ({\r\n            stID: member.stID,\r\n            E_Id: member.E_Id,\r\n            employeeName: member.employeeName,\r\n            address: member.address,\r\n            nic: member.nic,\r\n            dob: member.dob,\r\n            contact: member.contact,\r\n            job: member.job,\r\n            basic: member.basic,\r\n            orderTarget: member.orderTarget,\r\n            issuedTarget: member.issuedTarget,\r\n            totalOrder: member.totalOrder,\r\n            totalIssued: member.totalIssued\r\n        }));\r\n\r\n        // Send the formatted data as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Sales team members found.\",\r\n            data: formattedSalesTeam\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching sales team members:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching sales team members\" });\r\n    }\r\n});\r\n\r\n// Get orders for a specific sales team member (stID)\r\nrouter.get(\"/orders/by-sales-team\", async (req, res) => {\r\n    try {\r\n        const { stID } = req.query;\r\n        console.log(stID);\r\n\r\n        // Fetch sales team details, orders, and coupon details\r\n        const [results] = await db.query(`\r\n            SELECT\r\n                e.E_Id AS employeeId,\r\n                e.name AS employeeName,\r\n                e.contact AS employeeContact,\r\n                e.nic AS employeeNic,\r\n                e.dob AS employeeDob,\r\n                e.address AS employeeAddress,\r\n                e.job AS employeeJob,\r\n                e.basic AS employeeBasic,\r\n                st.stID,\r\n                st.orderTarget,\r\n                st.issuedTarget,\r\n                st.totalOrder,\r\n                st.totalIssued,\r\n                COUNT(o.OrID) AS totalCount,\r\n                SUM(CASE WHEN o.orStatus = 'issued' THEN 1 ELSE 0 END) AS issuedCount,\r\n                COALESCE(SUM(o.total), 0) AS totalOrderValue,\r\n                COALESCE(SUM(CASE WHEN o.orStatus = 'issued' THEN o.total ELSE 0 END), 0) AS issuedOrderValue,\r\n                o.OrID AS orderId,\r\n                o.orDate AS orderDate,\r\n                o.total AS totalPrice,\r\n                o.orStatus AS orderStatus,\r\n                sc.cpID AS couponId,\r\n                sc.discount AS couponDiscount\r\n            FROM sales_team st\r\n                     JOIN Employee e ON e.E_Id = st.E_Id\r\n                     LEFT JOIN Orders o ON o.stID = st.stID\r\n                     LEFT JOIN sales_coupon sc ON sc.stID = st.stID  \r\n            WHERE st.stID = ?\r\n            GROUP BY\r\n                st.stID, e.E_Id, e.name, e.contact, e.nic, e.dob, e.address, e.job, e.basic,\r\n                st.orderTarget, st.issuedTarget, st.totalOrder, st.totalIssued,\r\n                o.OrID, o.orDate, o.total, o.orStatus, sc.cpID, sc.discount;\r\n        `, [stID]);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ message: \"No data found for this sales team member.\" });\r\n        }\r\n\r\n        // Extract member details from the first row\r\n        const memberDetails = {\r\n            employeeId: results[0].employeeId,\r\n            employeeName: results[0].employeeName,\r\n            employeeContact: results[0].employeeContact,\r\n            employeeNic: results[0].employeeNic,\r\n            employeeDob: results[0].employeeDob,\r\n            employeeAddress: results[0].employeeAddress,\r\n            employeeJob: results[0].employeeJob,\r\n            employeeBasic: results[0].employeeBasic,\r\n            stID: results[0].stID,\r\n            orderTarget: results[0].orderTarget,\r\n            issuedTarget: results[0].issuedTarget,\r\n            totalOrder: results[0].totalOrder,\r\n            totalIssued: results[0].totalIssued,\r\n            totalCount: results[0].totalCount,\r\n            issuedCount: results[0].issuedCount\r\n        };\r\n\r\n        // Extract orders\r\n        const orders = results\r\n            .filter(order => order.orderId !== null)\r\n            .map(order => ({\r\n                orderId: order.orderId,\r\n                orderDate: order.orderDate,\r\n                totalPrice: order.totalPrice,\r\n                orderStatus: order.orderStatus\r\n            }));\r\n\r\n        // Extract coupon details (avoiding duplicates)\r\n        const coupons = results\r\n            .filter(coupon => coupon.couponId !== null)\r\n            .map(coupon => ({\r\n                cpID: coupon.couponId,\r\n                discount: coupon.couponDiscount\r\n            }));\r\n\r\n        return res.status(200).json({\r\n            message: \"Sales team details, orders, and coupons fetched successfully.\",\r\n            data: {\r\n                memberDetails,\r\n                orders: orders.length > 0 ? orders : [],\r\n                coupons: coupons.length > 0 ? coupons : [] // ✅ Ensure coupons array is empty if none exist\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching orders, member details, and coupons:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching orders, member details, and coupons.\" });\r\n    }\r\n});\r\n\r\n// Get all categories\r\nrouter.get(\"/categories\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all categories\r\n        const [categories] = await db.query(\"SELECT * FROM Category\");\r\n\r\n        // If no categories found, return a 404 status\r\n        if (categories.length === 0) {\r\n            return res.status(404).json({ message: \"No categories found\" });\r\n        }\r\n\r\n        // Map through categories to format the response\r\n        const formattedCategories = categories.map(category => ({\r\n            id: category.Ca_Id,  // Assuming you have a Ca_Id column for the category ID\r\n            name: category.name   // Assuming you have a name column for the category name\r\n        }));\r\n\r\n        // Send the formatted categories as a JSON response\r\n        return res.status(200).json(formattedCategories);\r\n    } catch (error) {\r\n        console.error(\"Error fetching categories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching categories\" });\r\n    }\r\n});\r\n\r\n//API to Get All Sub Categories (sub_one and sub_two) by Category ID (Ca_Id):\r\nrouter.get(\"/subcategories\", async (req, res) => {\r\n    try {\r\n        const { Ca_Id } = req.query;\r\n\r\n        if (!Ca_Id) {\r\n            return res.status(400).json({ message: \"Category ID is required.\" });\r\n        }\r\n\r\n        // Fetch subCat_one and related subCat_two details for the given Ca_Id\r\n        const [subCategories] = await db.query(`\r\n            SELECT\r\n                s1.sb_c_id AS subCatOneId,\r\n                s1.subcategory AS subCatOneName,\r\n                s1.img AS subCatOneImg,\r\n                s2.sb_cc_id AS subCatTwoId,\r\n                s2.subcategory AS subCatTwoName,\r\n                s2.img AS subCatTwoImg\r\n            FROM subCat_one s1\r\n                     LEFT JOIN subCat_two s2 ON s1.sb_c_id = s2.sb_c_id\r\n            WHERE s1.Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({ message: \"No subcategories found for this category.\" });\r\n        }\r\n\r\n        // Group subCat_two under corresponding subCat_one and set \"None\" if empty\r\n        const groupedData = subCategories.reduce((acc, curr) => {\r\n            const existingSubCatOne = acc.find(item => item.subCatOneId === curr.subCatOneId);\r\n\r\n            const subCatTwoItem = curr.subCatTwoId\r\n                ? {\r\n                    subCatTwoId: curr.subCatTwoId,\r\n                    subCatTwoName: curr.subCatTwoName,\r\n                    subCatTwoImg: curr.subCatTwoImg\r\n                }\r\n                : { subCatTwoId: \"None\", subCatTwoName: \"None\", subCatTwoImg: null };\r\n\r\n            if (existingSubCatOne) {\r\n                if (!existingSubCatOne.subCatTwo.some(item => item.subCatTwoId === subCatTwoItem.subCatTwoId)) {\r\n                    existingSubCatOne.subCatTwo.push(subCatTwoItem);\r\n                }\r\n            } else {\r\n                acc.push({\r\n                    subCatOneId: curr.subCatOneId,\r\n                    subCatOneName: curr.subCatOneName,\r\n                    subCatOneImg: curr.subCatOneImg,\r\n                    subCatTwo: [subCatTwoItem]\r\n                });\r\n            }\r\n\r\n            return acc;\r\n        }, []);\r\n\r\n        return res.status(200).json({\r\n            message: \"Subcategories fetched successfully.\",\r\n            data: groupedData\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching subcategories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching subcategories.\" });\r\n    }\r\n});\r\n\r\n// find subcat one and two data by category name\r\nrouter.get(\"/SubCatNames\", async (req, res) => {\r\n    try {\r\n        const { categoryName } = req.query;\r\n\r\n        if (!categoryName) {\r\n            return res.status(400).json({ message: \"Category name is required.\" });\r\n        }\r\n\r\n        // Fetch the Ca_Id based on the category name\r\n        const [categoryResult] = await db.query(`\r\n            SELECT Ca_Id FROM Category WHERE name = ?;\r\n        `, [categoryName]);\r\n\r\n        if (categoryResult.length === 0) {\r\n            return res.status(404).json({ message: \"Category not found.\" });\r\n        }\r\n\r\n        const Ca_Id = categoryResult[0].Ca_Id;\r\n\r\n        // Fetch subCat_one and related subCat_two details for the given Ca_Id\r\n        const [subCategories] = await db.query(`\r\n            SELECT\r\n                s1.sb_c_id AS subCatOneId,\r\n                s1.subcategory AS subCatOneName,\r\n                s1.img AS subCatOneImg,\r\n                s2.sb_cc_id AS subCatTwoId,\r\n                s2.subcategory AS subCatTwoName,\r\n                s2.img AS subCatTwoImg\r\n            FROM subCat_one s1\r\n                     LEFT JOIN subCat_two s2 ON s1.sb_c_id = s2.sb_c_id\r\n            WHERE s1.Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({ message: \"No subcategories found for this category.\" });\r\n        }\r\n\r\n        // Group subCat_two under corresponding subCat_one and set \"None\" if empty\r\n        const groupedData = subCategories.reduce((acc, curr) => {\r\n            const existingSubCatOne = acc.find(item => item.subCatOneId === curr.subCatOneId);\r\n\r\n            const subCatTwoItem = curr.subCatTwoId\r\n                ? {\r\n                    subCatTwoId: curr.subCatTwoId,\r\n                    subCatTwoName: curr.subCatTwoName,\r\n                    subCatTwoImg: curr.subCatTwoImg\r\n                }\r\n                : { subCatTwoId: \"None\", subCatTwoName: \"None\", subCatTwoImg: null };\r\n\r\n            if (existingSubCatOne) {\r\n                if (!existingSubCatOne.subCatTwo.some(item => item.subCatTwoId === subCatTwoItem.subCatTwoId)) {\r\n                    existingSubCatOne.subCatTwo.push(subCatTwoItem);\r\n                }\r\n            } else {\r\n                acc.push({\r\n                    subCatOneId: curr.subCatOneId,\r\n                    subCatOneName: curr.subCatOneName,\r\n                    subCatOneImg: curr.subCatOneImg,\r\n                    subCatTwo: [subCatTwoItem]\r\n                });\r\n            }\r\n\r\n            return acc;\r\n        }, []);\r\n\r\n        return res.status(200).json({\r\n            message: \"Subcategories fetched successfully.\",\r\n            data: groupedData\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching subcategories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching subcategories.\" });\r\n    }\r\n});\r\n\r\n// API endpoint to save item-supplier association\r\nrouter.post('/add-item-supplier', async (req, res) => {\r\n    const { I_Id, s_ID ,cost } = req.body;\r\n\r\n    // Check if I_Id and s_ID are provided\r\n    if (!I_Id || !s_ID ) {\r\n        return res.status(400).json({ success: false, message: 'Item ID and Supplier ID are required' });\r\n    }\r\n\r\n    try {\r\n        // Step 1: Check if the Item ID exists in the Item table\r\n        const [itemExists] = await db.query('SELECT * FROM Item WHERE I_Id = ?', [I_Id]);\r\n        if (itemExists.length === 0) {\r\n            return res.status(404).json({ success: false, message: 'Item not found' });\r\n        }\r\n\r\n        // Step 2: Check if the Supplier ID exists in the Supplier table\r\n        const [supplierExists] = await db.query('SELECT * FROM Supplier WHERE s_ID = ?', [s_ID]);\r\n        if (supplierExists.length === 0) {\r\n            return res.status(404).json({ success: false, message: 'Supplier not found' });\r\n        }\r\n\r\n        // Step 3: Insert the item-supplier relationship into the item_supplier table\r\n        const insertQuery = 'INSERT INTO item_supplier (I_Id, s_ID,unit_cost) VALUES (?, ?,?)';\r\n        const [result] = await db.query(insertQuery, [I_Id, s_ID,cost]);\r\n\r\n        // Step 4: Return success response\r\n        return res.status(200).json({ success: true, message: 'Item-Supplier relationship added successfully', data: result });\r\n    } catch (error) {\r\n        console.error('Error adding item-supplier:', error.message);\r\n        return res.status(500).json({ success: false, message: 'Server error', error: error.message });\r\n    }\r\n});\r\n\r\n// Route for adding stock with barcode generation\r\nrouter.post(\"/add-stock-received\", upload.single(\"image\"), async (req, res) => {\r\n    try {\r\n        const { supplierId, itemId, date, cost, stockCount, comment } = req.body;\r\n        const imageFile = req.file;\r\n\r\n        // Validate required fields\r\n        if (!supplierId || !itemId || !date || !stockCount) {\r\n            return res.status(400).json({ success: false, message: \"All fields are required!\" });\r\n        }\r\n\r\n        // Validate item existence\r\n        const [itemExists] = await db.query(\"SELECT I_Id FROM Item WHERE I_Id = ?\", [itemId]);\r\n        if (itemExists.length === 0) {\r\n            return res.status(400).json({ success: false, message: \"Invalid Item ID\" });\r\n        }\r\n\r\n        // Handle image upload\r\n        let imagePath = null;\r\n        if (imageFile) {\r\n            const imageName = `item_${itemId}_${Date.now()}.${imageFile.mimetype.split(\"/\")[1]}`;\r\n            const savePath = path.join(\"./uploads/images\", imageName);\r\n            fs.writeFileSync(savePath, imageFile.buffer);\r\n            imagePath = `/uploads/images/${imageName}`;\r\n        }\r\n\r\n        // Insert into main_stock_received\r\n        const insertQuery = `\r\n            INSERT INTO main_stock_received (s_ID, I_Id, rDate, rec_count, unitPrice, detail)\r\n            VALUES (?, ?, ?, ?, ?, ?)`;\r\n        const [result] = await db.query(insertQuery, [supplierId, itemId, date, stockCount, cost, comment || \"\"]);\r\n        const receivedStockId = result.insertId;\r\n\r\n        // Update Item table stock\r\n        await db.query(\r\n            `UPDATE Item SET stockQty = stockQty + ?, availableQty = availableQty + ? WHERE I_Id = ?`,\r\n            [stockCount, stockCount, itemId]\r\n        );\r\n\r\n        // Get last stock_Id\r\n        const [lastStockResult] = await db.query(\r\n            `SELECT MAX(stock_Id) AS lastStockId FROM m_s_r_detail WHERE I_Id = ?`,\r\n            [itemId]\r\n        );\r\n        let lastStockId = lastStockResult[0]?.lastStockId || 0;\r\n\r\n        console.log(\"Last stock ID before insert:\", lastStockId);\r\n\r\n        const insertDetailQuery = `\r\n            INSERT INTO m_s_r_detail (I_Id, stock_Id, sr_ID, barcode, status, orID, datetime)\r\n            VALUES (?, ?, ?, ?, 'Available', ?, NOW())`;\r\n\r\n        // Ensure barcodes folder exists\r\n        const barcodeFolderPath = path.join(\"./uploads/barcodes\");\r\n        if (!fs.existsSync(barcodeFolderPath)) {\r\n            fs.mkdirSync(barcodeFolderPath, { recursive: true });\r\n        }\r\n\r\n        for (let i = 1; i <= stockCount; i++) {\r\n            lastStockId++;\r\n\r\n            // Create barcode data\r\n            const barcodeData = `${itemId}-${lastStockId}-${receivedStockId}`;\r\n            const barcodeImageName = `barcode_${barcodeData}.png`;\r\n            const barcodeImagePath = path.join(barcodeFolderPath, barcodeImageName);\r\n\r\n            // Generate barcode image\r\n            const pngBuffer = await bwipjs.toBuffer({\r\n                bcid: \"code128\",\r\n                text: barcodeData,\r\n                scale: 3,\r\n                height: 10,\r\n                includetext: true,\r\n                textxalign: \"center\",\r\n            });\r\n\r\n            // Save barcode image to folder\r\n            fs.writeFileSync(barcodeImagePath, pngBuffer);\r\n\r\n            // Save barcode details in the database\r\n            await db.query(insertDetailQuery, [itemId, lastStockId, receivedStockId, barcodeData, \"\"]);\r\n            console.log(`Inserted barcode for stock ID: ${lastStockId}`);\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Stock received successfully, image uploaded, and barcodes saved!\",\r\n            stockReceivedId: receivedStockId,\r\n            imagePath,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error adding stock received:\", error);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Find cost by sid and iid\r\nrouter.get(\"/find-cost\", async (req, res) => {\r\n    try {\r\n        const { s_ID , I_Id } = req.query;\r\n\r\n        if (!s_ID || !I_Id ) {\r\n            return res.status(400).json({ message: \"Item ID, Supplier Id are required.\" });\r\n        }\r\n\r\n        // Query the database to fetch the type for the given Ca_Id, sub_one, and sub_two\r\n        const [cost] = await db.query(`\r\n            SELECT unit_cost\r\n            FROM item_supplier\r\n            WHERE s_ID = ? AND I_Id = ? ;\r\n        `, [s_ID,I_Id]);\r\n\r\n        // If no type found for this combination, return a 404 status\r\n        if (cost.length === 0) {\r\n            return res.status(404).json({ message: \"No cost found.\" });\r\n        }\r\n\r\n        // Send the type as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Cost found.\",\r\n            cost: cost[0],  // Return only the first matching cost\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching cost:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching cost\" });\r\n    }\r\n});\r\n\r\n//find issuded order by district\r\nrouter.get(\"/find-completed-orders\", async (req, res) => {\r\n    try {\r\n        const { district, date } = req.query;\r\n        console.log(district,date)\r\n\r\n        if (!district) {\r\n            return res.status(400).json({ success: false, message: \"District is required.\" });\r\n        }\r\n\r\n        if (!date) {\r\n            return res.status(400).json({ success: false, message: \"Date is required.\" });\r\n        }\r\n\r\n        // Parse the date in DD/MM/YYYY format and convert it to YYYY-MM-DD format\r\n        const parsedDate = parseDate(date);\r\n        console.log(parsedDate);\r\n\r\n\r\n        // 1\uFE0F⃣ Fetch Issued Orders with Sales Team & Customer Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.orId, o.orDate, o.customerEmail,o.custName, o.contact1, o.contact2, o.advance, o.balance,\r\n                o.payStatus, o.orStatus, o.delStatus, o.delPrice, o.discount, o.total, o.ordertype,\r\n                o.stID, o.expectedDate, o.specialNote, s.stID, e.name AS salesEmployeeName,\r\n                d.address, d.district, d.contact, d.status AS deliveryStatus, d.schedule_Date\r\n            FROM Orders o\r\n                     JOIN delivery d ON o.orID = d.orID\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE d.district = ? AND o.orStatus = 'Completed' AND o.expectedDate = ?;\r\n        `;\r\n\r\n        const [orders] = await db.query(orderQuery, [district, parsedDate]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No issued orders found for this district and date.\" });\r\n        }\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items for Each Order\r\n        const orderDetails = await Promise.all(orders.map(async (order) => {\r\n            const itemsQuery = `\r\n                SELECT\r\n                    od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                    i.bookedQty, i.availableQty\r\n                FROM Order_Detail od\r\n                         JOIN Item i ON od.I_Id = i.I_Id\r\n                WHERE od.orID = ?`;\r\n\r\n            const [items] = await db.query(itemsQuery, [order.orId]);\r\n\r\n            // 3\uFE0F⃣ Fetch Booked Items for Each Order\r\n            const bookedItemsQuery = `\r\n                SELECT bi.I_Id, i.I_name, bi.qty\r\n                FROM booked_item bi\r\n                         JOIN Item i ON bi.I_Id = i.I_Id\r\n                WHERE bi.orID = ?`;\r\n\r\n            const [bookedItems] = await db.query(bookedItemsQuery, [order.orId]);\r\n\r\n            // 4\uFE0F⃣ Fetch Accepted Items\r\n            const acceptedOrdersQuery = `\r\n                SELECT ao.I_Id, i.I_name, ao.itemReceived, ao.status\r\n                FROM accept_orders ao\r\n                         JOIN Item i ON ao.I_Id = i.I_Id\r\n                WHERE ao.orID = ?`;\r\n\r\n            const [acceptedOrders] = await db.query(acceptedOrdersQuery, [order.orId]);\r\n\r\n            // 5\uFE0F⃣ Build the Response Object\r\n            return {\r\n                orderId: order.orId,\r\n                orderDate: order.orDate,\r\n                customerEmail: order.customerEmail,\r\n                customerName: order.custName,\r\n                ordertype: order.ordertype,\r\n                phoneNumber: order.contact1,\r\n                optionalNumber: order.contact2,\r\n                orderStatus: order.orStatus,\r\n                deliveryStatus: order.delStatus,\r\n                deliveryCharge: order.delPrice,\r\n                discount: order.discount,\r\n                saleID: order.stID,\r\n                totalPrice: order.total,\r\n                advance: order.advance,\r\n                balance: order.balance,\r\n                payStatus: order.payStatus,\r\n                expectedDeliveryDate: order.expectedDate,\r\n                specialNote: order.specialNote,\r\n                salesTeam: order.salesEmployeeName ? { employeeName: order.salesEmployeeName } : null,\r\n                deliveryInfo: {\r\n                    address: order.address,\r\n                    district: order.district,\r\n                    status: order.deliveryStatus,\r\n                    scheduleDate: order.schedule_Date,\r\n                    contact: order.contact\r\n                },\r\n                items: items.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty,\r\n                    color: item.color,\r\n                    price: item.tprice,\r\n                    unitPrice: item.unitPrice,\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty\r\n                })),\r\n                bookedItems: bookedItems.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty\r\n                })),\r\n                acceptedOrders: acceptedOrders.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    itemReceived: item.itemReceived,\r\n                    status: item.status\r\n                }))\r\n            };\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Issued orders fetched successfully.\",\r\n            orders: orderDetails\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching issued orders:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching issued orders.\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get subcat one detail by ca_id\r\nrouter.get(\"/getSubcategories\", async (req, res) => {\r\n    const { Ca_Id } = req.query;\r\n    console.log(Ca_Id);\r\n    if (!Ca_Id) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Category ID (Ca_Id) is required\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Fetch subcategories under the given category ID\r\n        const sqlSubcategories = `SELECT sb_c_id, subcategory FROM subCat_one WHERE Ca_Id = ?`;\r\n        const [subCategories] = await db.query(sqlSubcategories, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No subcategories found for the given category ID\",\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Subcategories retrieved successfully\",\r\n            data: subCategories.map(subCat => ({\r\n                sb_c_id: subCat.sb_c_id,\r\n                subcategory: subCat.subcategory\r\n            })),\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching subcategories:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get subcat two detail by ca_id\r\nrouter.get(\"/getSubcategoriesTwo\", async (req, res) => {\r\n    const { sb_c_id } = req.query;\r\n\r\n    if (!sb_c_id) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Subcategory One ID (sb_c_id) is required\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Fetch subcategory two names under the given subcategory one ID\r\n        const sqlSubcategoriesTwo = `SELECT sb_cc_id, subcategory FROM subCat_two WHERE sb_c_id = ?\r\n        `;\r\n        const [subCategoriesTwo] = await db.query(sqlSubcategoriesTwo, [sb_c_id]);\r\n\r\n        if (subCategoriesTwo.length === 0) {\r\n            return res.status(200).json({\r\n                success: true,\r\n                message: \"No subcategories found\",\r\n                data: [{ sb_cc_id: \"None\", subcategory: \"None\" }],\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Subcategories retrieved successfully\",\r\n            data: subCategoriesTwo.map(subCat => ({\r\n                sb_cc_id: subCat.sb_cc_id,\r\n                subcategory: subCat.subcategory\r\n            })),\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching subcategories:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Category\r\nrouter.post(\"/category\", async (req, res) => {\r\n    try {\r\n        // Fetch the last inserted category ID\r\n        const [lastCategory] = await db.query(\"SELECT Ca_Id FROM Category ORDER BY Ca_Id DESC LIMIT 1\");\r\n\r\n        let newId;\r\n        if (lastCategory.length > 0) {\r\n            // Extract the number from the last ID and increment\r\n            const lastIdNumber = parseInt(lastCategory[0].Ca_Id.split(\"_\")[1], 10);\r\n            newId = `Ca_${String(lastIdNumber + 1).padStart(4, \"0\")}`;\r\n        } else {\r\n            // If no categories exist, start from Ca_0001\r\n            newId = \"Ca_0001\";\r\n        }\r\n\r\n        // SQL query to insert new category\r\n        const sql = `INSERT INTO Category (Ca_Id, name) VALUES (?, ?)`;\r\n        const values = [newId, req.body.Catname];\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, values);\r\n\r\n        // Return success response with the new category details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Category added successfully\",\r\n            data: {\r\n                Ca_Id: newId,\r\n                name: req.body.Catname\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting category data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Sub category one and two with image\r\nrouter.post(\"/subcategory\", upload.fields([{ name: \"subcatone_img\" }, { name: \"subcattwo_img\" }]), async (req, res) => {\r\n    const { Ca_Id, sub_one, sub_two } = req.body;\r\n    const subcatone_img = req.files[\"subcatone_img\"] ? req.files[\"subcatone_img\"][0].buffer : null;\r\n    const subcattwo_img = req.files[\"subcattwo_img\"] ? req.files[\"subcattwo_img\"][0].buffer : null;\r\n\r\n    try {\r\n        // Generate ID for subCat_one\r\n        const sb_c_id = await generateNewId(\"subCat_one\", \"sb_c_id\", \"S1\");\r\n\r\n        // Insert into subCat_one\r\n        await db.query(\r\n            \"INSERT INTO subCat_one (sb_c_id, subcategory, Ca_Id, img) VALUES (?, ?, ?, ?)\",\r\n            [sb_c_id, sub_one, Ca_Id, subcatone_img]\r\n        );\r\n\r\n        let sb_cc_id = null;\r\n        if (sub_two !== \"None\" && subcattwo_img) {\r\n            // Generate ID for subCat_two\r\n            sb_cc_id = await generateNewId(\"subCat_two\", \"sb_cc_id\", \"S2\");\r\n\r\n            // Insert into subCat_two\r\n            await db.query(\r\n                \"INSERT INTO subCat_two (sb_cc_id, subcategory, sb_c_id, img) VALUES (?, ?, ?, ?)\",\r\n                [sb_cc_id, sub_two, sb_c_id, subcattwo_img]\r\n            );\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Sub-category added successfully\",\r\n            data: {\r\n                sb_c_id,\r\n                sub_one,\r\n                Ca_Id,\r\n                sb_cc_id: sb_cc_id || null,\r\n                sub_two: sb_cc_id ? sub_two : null,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting sub-category data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Save new item to supplier\r\nrouter.post(\"/add-supplier-item\", async (req, res) => {\r\n    try {\r\n        const { I_Id, s_ID, unit_cost } = req.body;\r\n        console.log(I_Id, s_ID, unit_cost);\r\n\r\n        // Validate input\r\n        if (!I_Id || !s_ID || !unit_cost) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        // Query to insert the supplier item\r\n        const query = `\r\n            INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n            VALUES (?, ?, ?)\r\n                ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost)\r\n        `;\r\n\r\n        await db.query(query, [I_Id, s_ID, unit_cost]);\r\n\r\n        return res.status(201).json({ success: true, message: \"Item added successfully\" });\r\n    } catch (error) {\r\n        console.error(\"Error adding supplier item:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Fetch all coupons\r\nrouter.get(\"/coupon-details\", async (req, res) => {\r\n    try {\r\n        const query = `\r\n            SELECT\r\n                sc.cpID AS coupon_code,\r\n                sc.discount,\r\n                st.stID AS sales_team_id,\r\n                e.name AS employee_name\r\n            FROM sales_coupon sc\r\n                     JOIN sales_team st ON sc.stID = st.stID\r\n                     JOIN Employee e ON st.E_Id = e.E_Id\r\n        `;\r\n\r\n        const [results] = await db.query(query);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No coupon details found\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Coupon details retrieved successfully\",\r\n            data: results,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching coupon details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching coupon details\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Fetch all Delivery rates\r\nrouter.get(\"/delivery-rates\", async (req, res) => {\r\n    try {\r\n        const query = `SELECT * FROM deli_rates`;\r\n\r\n        const [results] = await db.query(query);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No rates details found\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Rates details retrieved successfully\",\r\n            data: results,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching  details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching details\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// GET API to fetch delivery schedule by district\r\nrouter.get(\"/delivery-schedule\", async (req, res) => {\r\n    const { district } = req.query; // Get district from query parameter\r\n\r\n    if (!district) {\r\n        return res.status(400).json({ message: \"District is required\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch all delivery dates for the given district\r\n        const [result] = await db.query(\r\n            \"SELECT ds_date FROM delivery_schedule WHERE district = ?\",\r\n            [district]\r\n        );\r\n\r\n        if (result.length === 0) {\r\n            return res.status(404).json({ message: \"District not found\" });\r\n        }\r\n\r\n        // Format the dates correctly without timezone shifts\r\n        const upcomingDates = result\r\n            .map(row => {\r\n                // Ensure the date remains in IST (India Standard Time)\r\n                const date = new Date(row.ds_date);\r\n                date.setHours(0, 0, 0, 0); // Remove any possible time shifts\r\n\r\n                // Use toLocaleDateString('en-CA') to keep format as YYYY-MM-DD\r\n                const formattedDate = date.toLocaleDateString('en-CA');\r\n\r\n                return formattedDate;\r\n            })\r\n            .filter(date => {\r\n                const today = new Date().toLocaleDateString('en-CA');\r\n                return date >= today; // Keep today's date and all upcoming dates\r\n            })\r\n            .sort((a, b) => new Date(a) - new Date(b)); // Sort dates\r\n\r\n        if (upcomingDates.length === 0) {\r\n            return res.status(404).json({ message: \"No upcoming delivery dates available\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            message: \"Upcoming delivery dates found\",\r\n            district: district,\r\n            upcomingDates: upcomingDates,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching delivery schedule:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching delivery schedule\" });\r\n    }\r\n});\r\n\r\n// Update change qty\r\nrouter.put(\"/change-quantity\", async (req, res) => {\r\n    const { orId, itemId, newQuantity, updatedPrice, booked } = req.body;\r\n    console.log(req.body);\r\n\r\n    // Validation: Check required fields\r\n    if (!orId || !itemId || newQuantity == null || updatedPrice == null) {\r\n        return res.status(400).json({ message: \"Missing required fields.\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch current item quantities\r\n        const [currentItem] = await db.query(\r\n            \"SELECT bookedQty, availableQty FROM Item WHERE I_Id = ?\",\r\n            [itemId]\r\n        );\r\n        console.log(\"Current Item:\", currentItem);\r\n\r\n        if (!currentItem || currentItem.length === 0) {\r\n            return res.status(404).json({ message: \"Item not found.\" });\r\n        }\r\n\r\n        // Fetch current order quantity\r\n        const [currentOrder] = await db.query(\r\n            \"SELECT qty FROM Order_Detail WHERE orID = ? AND I_Id = ?\",\r\n            [orId, itemId]\r\n        );\r\n\r\n        if (!currentOrder || currentOrder.length === 0) {\r\n            return res.status(404).json({ message: \"Order detail not found.\" });\r\n        }\r\n\r\n        //  Correctly accessing the first row values\r\n        const qtyDifference = Number(newQuantity) - Number(currentOrder[0].qty);\r\n\r\n        let newBookedQty = Number(currentItem[0].bookedQty);\r\n        let newAvailableQty = Number(currentItem[0].availableQty);\r\n\r\n        if (booked) {\r\n            newBookedQty += qtyDifference;\r\n            newAvailableQty -= qtyDifference;\r\n\r\n            if (newAvailableQty < 0) {\r\n                return res.status(400).json({ message: \"Insufficient available quantity.\" });\r\n            }\r\n        }\r\n\r\n        // Update Order_Detail\r\n        await db.query(\r\n            \"UPDATE Order_Detail SET qty = ?, tprice = ? WHERE orID = ? AND I_Id = ?\",\r\n            [newQuantity, updatedPrice, orId, itemId]\r\n        );\r\n\r\n        // Only update booked_item and Item when booked is true\r\n        if (booked) {\r\n            await db.query(\r\n                \"UPDATE booked_item SET qty = ? WHERE orID = ? AND I_Id = ?\",\r\n                [newQuantity, orId, itemId]\r\n            );\r\n\r\n            await db.query(\r\n                \"UPDATE Item SET bookedQty = ?, availableQty = ? WHERE I_Id = ?\",\r\n                [newBookedQty, newAvailableQty, itemId]\r\n            );\r\n        }\r\n\r\n        // Success response\r\n        return res.status(200).json({ message: \"Quantity updated successfully.\" });\r\n    } catch (error) {\r\n        console.error(\"Error updating quantity:\", error.message);\r\n        return res.status(500).json({ message: \"Error updating quantity.\", error: error.message });\r\n    }\r\n});\r\n\r\n// save new stock in item update stock\r\nrouter.post(\"/get-stock-details\", async (req, res) => {\r\n    try {\r\n        // Ensure req.body is an array\r\n        if (!Array.isArray(req.body) || req.body.length === 0) {\r\n            return res.status(400).json({ error: \"Invalid request. Provide an array of item IDs.\" });\r\n        }\r\n\r\n        const itemIds = req.body.map(id => id.trim()); // Trim whitespace\r\n\r\n        // Construct dynamic SQL query with placeholders\r\n        const placeholders = itemIds.map(() => \"?\").join(\", \");\r\n        const sql = `\r\n            SELECT * FROM m_s_r_detail\r\n            WHERE I_Id IN (${placeholders})\r\n              AND status = 'Available'\r\n        `;\r\n\r\n        // Execute query\r\n        const [results] = await db.query(sql, itemIds);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({\r\n                message: \"No stock details found for the provided item IDs\",\r\n                itemIds: itemIds,\r\n                stockDetails: []\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            message: \"Stock details retrieved successfully\",\r\n            itemIds: itemIds,\r\n            stockDetails: results\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching stock details:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n});\r\n\r\n// Issued order\r\nrouter.post(\"/isssued-order\", async (req, res) => {\r\n    const { orID, delStatus, delPrice, discount,subtotal, total, advance, balance, payStatus, stID, paymentAmount, selectedItems } = req.body;\r\n\r\n    console.log(req.body);\r\n\r\n    if (!orID || !stID || paymentAmount === undefined || !selectedItems || selectedItems.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n    }\r\n    const IssuedPrice = parseFloat(paymentAmount);\r\n\r\n\r\n    try {\r\n        // 1. Update Orders table\r\n        await db.query(\r\n            `UPDATE Orders\r\n             SET delStatus = ?, orStatus = 'Issued', delPrice = ?, discount = ?, total = ?, advance = ?, balance = ?, payStatus = ?, stID = ?\r\n             WHERE OrID = ?`,\r\n            [delStatus, delPrice, discount, total, advance, balance, payStatus, stID, orID]\r\n        );\r\n\r\n        // 2. Update m_s_r_detail table (Mark selected items as issued)\r\n        for (const item of selectedItems) {\r\n            await db.query(\r\n                `UPDATE m_s_r_detail\r\n                 SET status = 'Issued', orID = ?, datetime = NOW()\r\n                 WHERE srd_Id = ?`,\r\n                [orID, item.srd_Id]\r\n            );\r\n        }\r\n\r\n        // 3. Update sales_team table\r\n        await db.query(\r\n            `UPDATE sales_team\r\n             SET totalIssued = totalIssued + ?\r\n             WHERE stID = ?`,\r\n            [IssuedPrice, stID]\r\n        );\r\n\r\n        // 4. Update Item stock quantities using Order_Detail table\r\n        const [orderItems] = await db.query(\r\n            `SELECT I_Id, qty FROM Order_Detail WHERE orID = ?`,\r\n            [orID]\r\n        );\r\n\r\n        for (const item of orderItems) {\r\n            await db.query(\r\n                `UPDATE Item\r\n                 SET stockQty = stockQty - ?, bookedQty = bookedQty - ?\r\n                 WHERE I_Id = ?`,\r\n                [item.qty, item.qty, item.I_Id]\r\n            );\r\n        }\r\n\r\n        // 5. Delete from booked_item & accept_orders\r\n        await db.query(`DELETE FROM booked_item WHERE orID = ?`, [orID]);\r\n        await db.query(`DELETE FROM accept_orders WHERE orID = ?`, [orID]);\r\n\r\n        // 6. Insert into Payment table\r\n        await db.query(\r\n            `INSERT INTO Payment (orID, amount, dateTime)\r\n             VALUES (?, ?, NOW())`,\r\n            [orID, paymentAmount]\r\n        );\r\n\r\n        return res.status(200).json({ success: true, message: \"Order updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Issued Orders items\r\nrouter.post(\"/isssued-items\", async (req, res) => {\r\n    const { orID, payStatus, selectedItems } = req.body;\r\n\r\n    console.log(req.body);\r\n\r\n    if (!orID || !payStatus || !selectedItems || selectedItems.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n    }\r\n\r\n    try {\r\n        // 1. Update Orders table\r\n        await db.query(\r\n            `UPDATE Orders SET  orStatus = 'Issued', payStatus = ? WHERE OrID = ?`,\r\n            [ payStatus, orID]\r\n        );\r\n\r\n        // 2. Update m_s_r_detail table (Mark selected items as issued)\r\n        for (const item of selectedItems) {\r\n            await db.query(\r\n                `UPDATE m_s_r_detail\r\n                 SET status = 'Issued', orID = ?, datetime = NOW()\r\n                 WHERE srd_Id = ?`,\r\n                [orID, item.srd_Id]\r\n            );\r\n        }\r\n\r\n        // 4. Update Item stock quantities using Order_Detail table\r\n        const [orderItems] = await db.query(\r\n            `SELECT I_Id, qty FROM Order_Detail WHERE orID = ?`,\r\n            [orID]\r\n        );\r\n\r\n        for (const item of orderItems) {\r\n            await db.query(\r\n                `UPDATE Item\r\n                 SET stockQty = stockQty - ?, bookedQty = bookedQty - ?\r\n                 WHERE I_Id = ?`,\r\n                [item.qty, item.qty, item.I_Id]\r\n            );\r\n        }\r\n\r\n        // 5. Delete from booked_item & accept_orders\r\n        await db.query(`DELETE FROM booked_item WHERE orID = ?`, [orID]);\r\n        await db.query(`DELETE FROM accept_orders WHERE orID = ?`, [orID]);\r\n\r\n        return res.status(200).json({ success: true, message: \"Order updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Save new Delivery Rate\r\nrouter.post(\"/delivery-rates\", async (req, res) => {\r\n    try {\r\n        // SQL query to insert new category\r\n        const sql = `INSERT INTO deli_Rates (district, amount) VALUES (?, ?)`;\r\n        const values = [req.body.District,req.body.rate];\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, values);\r\n\r\n        // Return success response with the new category details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Rate added successfully\",\r\n            data: {\r\n                District: req.body.District,\r\n                rate: req.body.rate\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting rates data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save Scheduled dates\r\nrouter.post(\"/delivery-dates\", async (req, res) => {\r\n    try {\r\n        console.log(req.body);\r\n\r\n        const { District, dates } = req.body; // Extract district and dates array\r\n\r\n        if (!District || !Array.isArray(dates) || dates.length === 0) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"District and at least one date are required\"\r\n            });\r\n        }\r\n\r\n        // SQL query to insert multiple dates\r\n        const sql = `INSERT INTO delivery_schedule (district, ds_date) VALUES ?`;\r\n        const values = dates.map(date => [District, date]); // Create array of values\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, [values]);\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Delivery dates added successfully\",\r\n            data: {\r\n                District,\r\n                dates,\r\n            },\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error inserting delivery dates:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save new employee and saleteam\r\nrouter.post(\"/employees\", async (req, res) => {\r\n    try {\r\n        const { name, address, nic, dob, contact, job, basic, orderTarget , issuedTarget } = req.body;\r\n        console.log(req.body);\r\n\r\n        if (!name || !address || !nic || !dob || !contact || !job || !basic || !orderTarget || !issuedTarget) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"All fields are required except target and currentRate (only for Sales).\"\r\n            });\r\n        }\r\n\r\n        const E_Id = await generateNewId(\"Employee\", \"E_Id\", \"E\"); // Generate new Employee ID\r\n\r\n        const sql = `INSERT INTO Employee (E_Id, name, address, nic, dob, contact, job, basic) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;\r\n        await db.query(sql, [E_Id, name, address, nic, dob, contact, job, basic]);\r\n\r\n        // If job is Sales, insert into sales_team table\r\n        let salesData = null;\r\n        if (job === \"Sales\" && orderTarget && issuedTarget) {\r\n            const stID = await generateNewId(\"sales_team\", \"stID\", \"ST\");\r\n            const sqlSales = `INSERT INTO sales_team (stID, E_Id, orderTarget,issuedTarget, totalOrder, totalIssued) VALUES (?, ?, ?,?,'0', '0')`;\r\n            await db.query(sqlSales,[stID, E_Id, orderTarget , issuedTarget]);\r\n\r\n            salesData = { stID, orderTarget , issuedTarget };\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Employee added successfully\",\r\n            data:  {E_Id,salesData},\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error adding employee:\", err);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error adding employee\",\r\n            details: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save Delivery Notes\r\nrouter.post(\"/create-delivery-note\", async (req, res) => {\r\n    try {\r\n        const { driverName, vehicleName, hire, date, district, orders, balanceToCollect } = req.body;\r\n        console.log(orders);\r\n\r\n        const delHire = parseFloat(hire);\r\n\r\n        // Validate required fields\r\n        if (!driverName || !vehicleName || !date || !hire || !orders || orders.length === 0) {\r\n            return res.status(400).json({ message: \"Driver name, vehicle name, hire, date, and orders are required.\" });\r\n        }\r\n\r\n        // Convert the date from DD/MM/YY format to YYYY-MM-DD\r\n        const [day, month, year] = date.split('/');\r\n        const formattedDate = `20${year.length === 2 ? year : year.slice(2)}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\r\n\r\n        // Insert into the delivery_note table\r\n        const [result] = await db.query(`\r\n            INSERT INTO delivery_note (driverName, vehicalName, date, hire, district, balanceToCollect, status)\r\n            VALUES (?, ?, ?, ?, ?, ?, 'Incomplete')\r\n        `, [driverName, vehicleName, formattedDate, delHire, district, balanceToCollect]);\r\n\r\n        // Get the generated delNoID (Delivery Note ID)\r\n        const delNoID = result.insertId;\r\n\r\n        // Insert the orders into the delivery_note_orders table\r\n        const orderQueries = orders.map(({ orderId, balance }) => {\r\n            return db.query(`\r\n                INSERT INTO delivery_note_orders (delNoID, orID, balance)\r\n                VALUES (?, ?, ?)\r\n            `, [delNoID, orderId, balance]); // Now including balance\r\n        });\r\n\r\n        // Execute all insert queries in parallel\r\n        await Promise.all(orderQueries);\r\n\r\n        // Update delivery status for each order\r\n        const deliveryQueries = orders.map(({ orderId }) => {\r\n            return db.query(`\r\n                UPDATE delivery\r\n                SET status = 'Delivered', delivery_Date = ?\r\n                WHERE orID = ?\r\n            `, [formattedDate, orderId]);\r\n        });\r\n\r\n        // Execute all delivery updates in parallel\r\n        await Promise.all(deliveryQueries);\r\n\r\n        // Send success response\r\n        return res.status(201).json({\r\n            message: \"Delivery note and orders created successfully, and delivery status updated.\",\r\n            delNoID, // Return the generated Delivery Note ID\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error creating delivery note:\", error.message);\r\n        return res.status(500).json({ message: \"Error creating delivery note\", details: error.message });\r\n    }\r\n});\r\n\r\n// Get Delivery Note detail\r\nrouter.get(\"/delivery-note\", async (req, res) => {\r\n    try {\r\n        const { delNoID } = req.query;\r\n\r\n        if (!delNoID) {\r\n            return res.status(400).json({ success: false, message: \"Delivery Note ID is required.\" });\r\n        }\r\n\r\n        // Fetch delivery note details\r\n        const [deliveryNote] = await db.query(\r\n            \"SELECT * FROM delivery_note WHERE delNoID = ?\",\r\n            [delNoID]\r\n        );\r\n\r\n        if (deliveryNote.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Delivery note not found\" });\r\n        }\r\n\r\n        // Fetch associated orders and balance from delivery_note_orders\r\n        const [orders] = await db.query(\r\n            `SELECT o.OrID, o.orStatus AS orderStatus, o.delStatus AS deliveryStatus, \r\n                    o.payStatus, dno.balance AS balanceAmount\r\n             FROM delivery_note_orders dno\r\n             INNER JOIN Orders o ON o.OrID = dno.orID\r\n             WHERE dno.delNoID = ?`,\r\n            [delNoID]\r\n        );\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No orders found for this delivery note\" });\r\n        }\r\n\r\n        // Fetch issued items grouped by order ID\r\n        const orderIds = orders.map(order => order.OrID);\r\n        let issuedItems = [];\r\n\r\n        if (orderIds.length > 0) {\r\n            [issuedItems] = await db.query(\r\n                `SELECT m.orID, m.srd_Id, m.I_Id, m.stock_Id, m.barcode, m.datetime\r\n                 FROM m_s_r_detail m\r\n                 WHERE m.orID IN (?) AND m.status = 'Issued'`,\r\n                [orderIds]\r\n            );\r\n        }\r\n\r\n        // Organize issued items under their respective orders\r\n        const ordersWithIssuedItems = orders.map(order => ({\r\n            ...order,\r\n            issuedItems: issuedItems.filter(item => item.orID === order.OrID),\r\n            balance: order.payStatus === \"COD\" ? order.balanceAmount : null // Include balance only if COD\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Delivery note details fetched successfully\",\r\n            details: deliveryNote[0], // Delivery note details\r\n            orders: ordersWithIssuedItems // Orders with issued items grouped\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching delivery note details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching delivery note details\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Coupone\r\nrouter.post(\"/coupone\", async (req, res) => {\r\n    const sql = `INSERT INTO sales_coupon (cpID,stID,discount) VALUES (?, ?,?)`;\r\n    const values = [\r\n        req.body.couponCode,\r\n        req.body.saleteamCode,\r\n        req.body.discount\r\n    ];\r\n    try {\r\n        // Execute the query and retrieve the result\r\n        const [result] = await db.query(sql, values);\r\n\r\n        // Return success response with inserted data details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Coupone added successfully\",\r\n            data: {\r\n                couponCode : req.body.couponCode,\r\n                saleteamCode: req.body.saleteamCode,\r\n                discount: req.body.discount\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting coupone data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Promotion\r\nrouter.post(\"/promotion\", upload.single('img'), async (req, res) => {\r\n    const sql = `INSERT INTO Promotion (img, date ) VALUES (?, ?)`;\r\n\r\n    const values = [\r\n        req.file.buffer,  // The image file is in `req.file.buffer`\r\n        req.body.date,\r\n    ];\r\n    console.log(values);\r\n\r\n    // try {\r\n    //     const [result] = await db.query(sql, values);\r\n    //\r\n    //     return res.status(201).json({\r\n    //         success: true,\r\n    //         message: \"Promotion added successfully\",\r\n    //         data: {\r\n    //             img: req.body.img,\r\n    //             date: req.body.date,\r\n    //         },\r\n    //     });\r\n    // } catch (err) {\r\n    //     console.error(\"Error inserting item data:\", err.message);\r\n    //     return res.status(500).json({\r\n    //         success: false,\r\n    //         message: \"Error inserting data into database\",\r\n    //         details: err.message,\r\n    //     });\r\n    // }\r\n});\r\n\r\n// Update delivery note when order status issued (done)\r\nrouter.post(\"/delivery-done\", async (req, res) => {\r\n    const { updatedOrders, deliveryNoteId } = req.body; // Extract orders array and delivery note ID\r\n\r\n    if (!updatedOrders || !Array.isArray(updatedOrders) || updatedOrders.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"No valid orders provided.\" });\r\n    }\r\n\r\n    try {\r\n        for (const order of updatedOrders) {\r\n            console.log(order);\r\n            const { OrID, orderStatus, deliveryStatus, received, reason, reasonType, rescheduledDate } = order;\r\n            console.log(OrID);\r\n\r\n            // Ensure the order exists before updating\r\n            const [rows] = await db.query(\r\n                \"SELECT orID, custName, balance, payStatus, expectedDate, stID FROM Orders WHERE orID = ?\",\r\n                [OrID]\r\n            );\r\n\r\n            if (!rows || rows.length === 0) {\r\n                throw new Error(`Order ${OrID} not found.`);\r\n            }\r\n\r\n            const existingOrder = rows[0]; // Fix: Get the first row properly\r\n\r\n            const { orID, custName, balance, payStatus, expectedDate, stID } = existingOrder;\r\n            console.log(orID, custName, balance, payStatus, expectedDate, stID);\r\n\r\n            // Ensure balance is valid\r\n            const updatedBalance = parseFloat(balance) || 0;\r\n            console.log(updatedBalance);\r\n\r\n            // Uncomment this when testing is done\r\n            await db.query(`UPDATE Orders SET advance = ?, balance = ?, payStatus = ? WHERE OrID = ?`, [updatedBalance, 0, 'Settled', OrID]);\r\n            await db.query(`UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?`, [updatedBalance, stID]);\r\n            await db.query(`INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())`, [OrID, updatedBalance]);\r\n            await db.query(`UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?`, [\"Delivered\", expectedDate, OrID]);\r\n            await db.query(`UPDATE delivery_note SET status = ? WHERE delNoID = ?`, [\"Complete\", deliveryNoteId]);\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Orders updated successfully.\",\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error updating orders:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating orders\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Update delivery note when order status issued (done)\r\nrouter.post(\"/delivery-return\", async (req, res) => {\r\n    const { updatedOrders, deliveryNoteId } = req.body;\r\n\r\n    if (!updatedOrders || !Array.isArray(updatedOrders) || updatedOrders.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"No valid orders provided.\" });\r\n    }\r\n\r\n    try {\r\n        for (const order of updatedOrders) {\r\n            const { OrID, orderStatus, deliveryStatus, received, reason, reasonType, rescheduledDate, returnedItems, payment } = order;\r\n\r\n            const nowPayment = parseFloat(payment);\r\n\r\n            // Ensure the order exists before updating\r\n            const [rows] = await db.query(\r\n                \"SELECT orID, custName, balance, payStatus, expectedDate, stID, advance, total, discount, delPrice, contact1, contact2 FROM Orders WHERE orID = ?\",\r\n                [OrID]\r\n            );\r\n\r\n            if (!rows || rows.length === 0) {\r\n                throw new Error(`Order ${OrID} not found.`);\r\n            }\r\n\r\n            const existingOrder = rows[0];\r\n\r\n            const { orID, custName, balance, payStatus, expectedDate, stID, advance, total, discount, delPrice, contact1, contact2 } = existingOrder;\r\n\r\n            // Ensure balance is valid\r\n            const updatedBalance = parseFloat(balance) || 0;\r\n            const updatedAdvance = parseFloat(nowPayment) + parseFloat(advance);\r\n            const netTotal = (parseFloat(total) - parseFloat(discount)) + parseFloat(delPrice);\r\n            let newNetTotal = netTotal;\r\n            let excessAmount = 0;\r\n            let NewTotal = 0;\r\n            let newBalanceset = 0;\r\n\r\n            // Fetch multiple items for the order\r\n            const [orderDetails] = await db.query(\r\n                `SELECT I_Id, qty, tprice FROM Order_Detail WHERE orID = ?`,\r\n                [OrID]\r\n            );\r\n\r\n            if (orderStatus === \"Issued\") {\r\n                console.log(\"Issued order\");\r\n                await db.query(`UPDATE Orders SET advance = ?, balance = ?, payStatus = ? WHERE OrID = ?`,\r\n                    [updatedBalance, 0, 'Settled', OrID]);\r\n                await db.query(`UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?`,\r\n                    [updatedBalance, stID]);\r\n                await db.query(`INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())`,\r\n                    [OrID, updatedBalance]);\r\n                await db.query(`UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?`,\r\n                    [\"Delivered\", expectedDate, OrID]);\r\n\r\n            } else if (orderStatus === \"Returned\") {\r\n                console.log(\"Returned order\");\r\n                // Process returned items\r\n                for (const item of returnedItems) {\r\n                    const detail = orderDetails.find(d => d.I_Id === item.itemId);\r\n\r\n                    if (detail) {\r\n                        let itemQty = parseFloat(item.qty) || 0;\r\n                        let detailQty = parseFloat(detail.qty) || 1;\r\n                        let itemTPrice = parseFloat(detail.tprice) || 0;\r\n\r\n                        if (detailQty === 0) {\r\n                            console.warn(`Warning: Item ${item.itemId} has zero quantity in order details! Skipping calculation.`);\r\n                            continue;\r\n                        }\r\n\r\n                        let unitPrice = itemTPrice / detailQty;\r\n                        newNetTotal -= unitPrice * itemQty;\r\n                    } else {\r\n                        console.warn(`Item ${item.itemId} not found in order details.`);\r\n                    }\r\n\r\n                    await db.query(`UPDATE m_s_r_detail SET status = ?, datetime = NOW() WHERE stock_Id = ? AND I_Id = ?`,\r\n                        [item.status, item.stockId, item.itemId]);\r\n                }\r\n\r\n                NewTotal = (parseFloat(newNetTotal) - parseFloat(discount)) + parseFloat(delPrice);\r\n                newBalanceset = parseFloat(NewTotal) - updatedAdvance;\r\n                excessAmount = updatedAdvance - newNetTotal;\r\n\r\n                await db.query(`UPDATE Orders SET advance = ?, balance = ?, total = ?, payStatus = ?, orStatus = ?, expectedDate = ? WHERE OrID = ?`,\r\n                    [updatedAdvance, newBalanceset, NewTotal, 'Credit', 'Returned', rescheduledDate, OrID]);\r\n                await db.query(`UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?`,\r\n                    [nowPayment, stID]);\r\n                await db.query(`INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())`,\r\n                    [OrID, nowPayment]);\r\n                await db.query(`UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?`,\r\n                    [\"Returned\", expectedDate, OrID]);\r\n                await db.query(`UPDATE Customer SET excessAmount = ? WHERE contact1 = ? OR contact2 = ?`,\r\n                    [excessAmount, contact1, contact2]);\r\n            }\r\n\r\n            await db.query(`UPDATE delivery_note SET status = ? WHERE delNoID = ?`, [\"Complete\", deliveryNoteId]);\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Orders updated successfully.\" });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error updating orders:\", err.message);\r\n        return res.status(500).json({ success: false, message: \"Error updating orders\", details: err.message });\r\n    }\r\n});\r\n\r\n\r\n// Function to generate new ida\r\nconst generateNewId = async (table, column, prefix) => {\r\n    const [rows] = await db.query(`SELECT ${column} FROM ${table} ORDER BY ${column} DESC LIMIT 1`);\r\n    if (rows.length === 0) return `${prefix}_001`; // First entry\r\n    const lastId = rows[0][column]; // Get last ID\r\n    console.log(lastId);\r\n    const lastNum = parseInt(lastId.split(\"_\")[1],10) + 1; // Extract number and increment\r\n    console.log(lastNum);\r\n    console.log(`${prefix}_${String(lastNum).padStart(3, \"0\")}`);\r\n    return `${prefix}_${String(lastNum).padStart(3, \"0\")}`;\r\n};\r\n\r\n// Helper function to parse date from DD/MM/YYYY format to YYYY-MM-DD format\r\nconst parseDate = (dateStr) => {\r\n    const [month ,day, year] = dateStr.split(\"/\");\r\n    console.log(day , month,year)\r\n\r\n    // Check if the date is valid\r\n    if (!day || !month || !year || isNaN(day) || isNaN(month) || isNaN(year)) {\r\n        return null;\r\n    }\r\n    // Ensure the day and month are two digits (e.g., \"03\" instead of \"3\")\r\n    const formattedDate = `${year}-${String(day).padStart(2, '0')}-${String(month).padStart(2, '0')}`;\r\n    console.log(formattedDate);\r\n    return formattedDate;\r\n};\r\n\r\nexport default router;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/adminBackend/Routes/mainRoutes.js b/adminBackend/Routes/mainRoutes.js
--- a/adminBackend/Routes/mainRoutes.js	(revision ea76e0847cc37b3863e11f84fed4aea14d6e48d5)
+++ b/adminBackend/Routes/mainRoutes.js	(date 1741253255825)
@@ -227,10 +227,12 @@
 
         // Check if customer already exists
         const customerQuery = `
-            SELECT c_ID FROM Customer 
-            WHERE contact1 = ? OR contact2 = ?
+            SELECT c_ID FROM Customer
+            WHERE (contact1 = ? AND contact2 = ?)
+               OR (contact1 = ? AND contact2 = ?)
         `;
-        const [customerResult] = await db.query(customerQuery, [phoneNumber, otherNumber]);
+        const [customerResult] = await db.query(customerQuery, [phoneNumber, otherNumber, otherNumber, phoneNumber]);
+
 
         if (customerResult.length > 0) {
             // Customer exists, get their ID
@@ -238,10 +240,10 @@
         } else {
             // Customer does not exist, insert new customer
             const insertCustomerQuery = `
-                INSERT INTO Customer (email, address, contact1, contact2, excessAmount)
-                VALUES (?, ?, ?, ?, ?)
+                INSERT INTO Customer (Name,email, address, contact1, contact2, excessAmount)
+                VALUES (?,?, ?, ?, ?, ?)
             `;
-            const [newCustomer] = await db.query(insertCustomerQuery, [email, address, phoneNumber, otherNumber, 0]);
+            const [newCustomer] = await db.query(insertCustomerQuery, [name,email, address, phoneNumber, otherNumber, 0]);
             c_ID = newCustomer.insertId; // Get the newly inserted customer ID
         }
 
@@ -342,7 +344,6 @@
             return res.status(404).json({ message: "No Orders found" });
         }
 
-
         const formattedOrders = orders.map(order => ({
             OrID : order.OrID, // Assuming you have an id column
             orDate : order.orDate,
@@ -764,6 +765,133 @@
     }
 });
 
+//Get Details of returned orders
+router.get("/returned-order-details", async (req, res) => {
+    try {
+        const { orID } = req.query;
+        if (!orID) {
+            return res.status(400).json({ success: false, message: "Order ID is required" });
+        }
+
+        // 1️⃣ Fetch Order Info with Sales Team Details
+        const orderQuery = `
+            SELECT
+                o.OrID, o.orDate, o.customerEmail, o.contact1, o.contact2, o.advance, o.balance, o.payStatus,
+                o.orStatus, o.delStatus, o.delPrice, o.discount, o.total, o.ordertype, o.stID,
+                o.expectedDate, o.specialNote, s.stID, e.name AS salesEmployeeName,
+                ro.detail AS returnReason  -- Fetch return reason if available
+            FROM Orders o
+            LEFT JOIN sales_team s ON o.stID = s.stID
+            LEFT JOIN Employee e ON s.E_Id = e.E_Id
+            LEFT JOIN return_orders ro ON o.OrID = ro.OrID -- Join return_orders table
+            WHERE o.OrID = ?`;
+
+        const [orderResult] = await db.query(orderQuery, [orID]);
+        if (orderResult.length === 0) {
+            return res.status(404).json({ success: false, message: "Order not found" });
+        }
+        const orderData = orderResult[0];
+
+        // 2️⃣ Fetch Ordered Items with Updated Stock Fields
+        const itemsQuery = `
+            SELECT
+                od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,
+                i.bookedQty, i.availableQty
+            FROM Order_Detail od
+            JOIN Item i ON od.I_Id = i.I_Id
+            WHERE od.orID = ?`;
+
+        const [itemsResult] = await db.query(itemsQuery, [orID]);
+
+        // 3️⃣ Fetch Issued Items for this Order from `m_s_r_detail`
+        const issuedItemsQuery = `
+            SELECT
+                m.I_Id, i.I_name, m.stock_Id, m.sr_ID, m.barcode, m.status, m.datetime
+            FROM m_s_r_detail m
+            JOIN Item i ON m.I_Id = i.I_Id
+            WHERE m.orID = ?`;
+
+        const [issuedItemsResult] = await db.query(issuedItemsQuery, [orID]);
+
+        // 4️⃣ Initialize Response Object
+        const orderResponse = {
+            orderId: orderData.OrID,
+            orderDate: orderData.orDate,
+            customerEmail: orderData.customerEmail,
+            ordertype: orderData.ordertype,
+            phoneNumber: orderData.contact1,
+            optionalNumber: orderData.contact2,
+            orderStatus: orderData.orStatus,
+            deliveryStatus: orderData.delStatus,
+            deliveryCharge: orderData.delPrice,
+            discount: orderData.discount,
+            saleID: orderData.stID,
+            totalPrice: orderData.total,
+            advance: orderData.advance,
+            balance: orderData.balance,
+            payStatus: orderData.payStatus,
+            expectedDeliveryDate: orderData.expectedDate,
+            specialNote: orderData.specialNote,
+            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,
+            returnReason: orderData.returnReason || null, // Include return reason if available
+            items: itemsResult.map(item => ({
+                itemId: item.I_Id,
+                itemName: item.I_name,
+                quantity: item.qty,
+                color: item.color,
+                price: item.tprice,
+                unitPrice: item.unitPrice,
+                bookedQuantity: item.bookedQty,
+                availableQuantity: item.availableQty
+            })),
+            issuedItems: issuedItemsResult.map(item => ({
+                itemId: item.I_Id,
+                itemName: item.I_name,
+                stockId: item.stock_Id,
+                srID: item.sr_ID,
+                barcode: item.barcode.toString('base64'), // Convert to readable format if needed
+                status: item.status,
+                datetime: item.datetime
+            }))
+        };
+
+        // 5️⃣ Fetch Delivery Info If Order is for Delivery
+        if (orderData.delStatus === "Delivery") {
+            const deliveryQuery = `
+                SELECT dv_id, address, district, contact, status, schedule_Date
+                FROM delivery
+                WHERE orID = ?`;
+
+            const [deliveryResult] = await db.query(deliveryQuery, [orID]);
+
+            if (deliveryResult.length > 0) {
+                const deliveryData = deliveryResult[0];
+                orderResponse.deliveryInfo = {
+                    deliveryId: deliveryData.dv_id,
+                    address: deliveryData.address,
+                    district: deliveryData.district,
+                    status: deliveryData.status,
+                    scheduleDate: deliveryData.schedule_Date,
+                };
+            }
+        }
+
+        return res.status(200).json({
+            success: true,
+            message: "Order details fetched successfully",
+            order: orderResponse
+        });
+
+    } catch (error) {
+        console.error("Error fetching order details:", error.message);
+        return res.status(500).json({
+            success: false,
+            message: "Error fetching order details",
+            details: error.message,
+        });
+    }
+});
+
 // Get one order in-detail
 router.get("/order-details", async (req, res) => {
     try {
@@ -1272,15 +1400,16 @@
 // Fetch Returned order
 router.get("/orders-returned", async (req, res) => {
     try {
-        // Query to fetch orders with their acceptance status from accept_orders table
+        // Query to fetch returned orders with their acceptance status and return reason
         const query = `
             SELECT
                 o.OrID, o.orDate, o.customerEmail, o.ordertype, o.orStatus, o.delStatus, o.delPrice,
                 o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,
-                ao.itemReceived,
-                ao.status AS acceptanceStatus
+                ao.itemReceived, ao.status AS acceptanceStatus,
+                ro.detail AS returnReason
             FROM Orders o
-                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID
+            LEFT JOIN accept_orders ao ON o.OrID = ao.orID
+            LEFT JOIN return_orders ro ON o.OrID = ro.OrID
             WHERE o.orStatus = 'Returned'
         `;
 
@@ -1288,7 +1417,7 @@
 
         // If no orders found, return a 404 status
         if (orders.length === 0) {
-            return res.status(404).json({ message: "No Completed orders found" });
+            return res.status(404).json({ message: "No returned orders found" });
         }
 
         // Group orders by OrID
@@ -1312,6 +1441,7 @@
                     stID: order.stID,
                     expectedDeliveryDate: order.expectedDeliveryDate,
                     itemReceived: order.itemReceived,
+                    returnReason: order.returnReason || "No reason provided", // Handle null reasons
                     acceptanceStatus: "Complete", // Default status is Complete
                     acceptanceStatuses: [] // Track individual item statuses
                 };
@@ -1331,13 +1461,13 @@
 
         // Send the formatted orders with their acceptance status as a JSON response
         return res.status(200).json({
-            message: "Completed orders found.",
+            message: "Returned orders found.",
             data: formattedOrders,
         });
 
     } catch (error) {
-        console.error("Error fetching completed orders:", error.message);
-        return res.status(500).json({ message: "Error fetching completed orders", error: error.message });
+        console.error("Error fetching returned orders:", error.message);
+        return res.status(500).json({ message: "Error fetching returned orders", error: error.message });
     }
 });
 
@@ -3711,10 +3841,11 @@
             const updatedBalance = parseFloat(balance) || 0;
             const updatedAdvance = parseFloat(nowPayment) + parseFloat(advance);
             const netTotal = (parseFloat(total) - parseFloat(discount)) + parseFloat(delPrice);
-            let newNetTotal = netTotal;
+            let newNetTotal = 0;
             let excessAmount = 0;
             let NewTotal = 0;
             let newBalanceset = 0;
+            let unitPrice =0;
 
             // Fetch multiple items for the order
             const [orderDetails] = await db.query(
@@ -3749,8 +3880,8 @@
                             continue;
                         }
 
-                        let unitPrice = itemTPrice / detailQty;
-                        newNetTotal -= unitPrice * itemQty;
+                        unitPrice = itemTPrice / detailQty;
+                        console.log("unit price "+unitPrice);
                     } else {
                         console.warn(`Item ${item.itemId} not found in order details.`);
                     }
@@ -3759,9 +3890,12 @@
                         [item.status, item.stockId, item.itemId]);
                 }
 
-                NewTotal = (parseFloat(newNetTotal) - parseFloat(discount)) + parseFloat(delPrice);
+                newNetTotal = (parseFloat(netTotal) - parseFloat(unitPrice)) ;
+                NewTotal = (parseFloat(newNetTotal)- parseFloat(discount))+ parseFloat(delPrice);
                 newBalanceset = parseFloat(NewTotal) - updatedAdvance;
                 excessAmount = updatedAdvance - newNetTotal;
+                console.log("Total :"+total+" Balance :"+balance +" new net total :"+newNetTotal+" new advance :"+updatedAdvance)
+                console.log("New Total :"+NewTotal+" New Balance :"+newBalanceset+" Excess Amount : "+excessAmount)
 
                 await db.query(`UPDATE Orders SET advance = ?, balance = ?, total = ?, payStatus = ?, orStatus = ?, expectedDate = ? WHERE OrID = ?`,
                     [updatedAdvance, newBalanceset, NewTotal, 'Credit', 'Returned', rescheduledDate, OrID]);
@@ -3771,8 +3905,55 @@
                     [OrID, nowPayment]);
                 await db.query(`UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?`,
                     ["Returned", expectedDate, OrID]);
-                await db.query(`UPDATE Customer SET excessAmount = ? WHERE contact1 = ? OR contact2 = ?`,
-                    [excessAmount, contact1, contact2]);
+                await db.query(`UPDATE Customer SET excessAmount = ? WHERE (contact1 = ? AND contact2 = ?) OR (contact1 = ? AND contact2 = ?)`,
+                    [excessAmount, contact1, contact2 , contact2,contact1]);
+                await db.query(`INSERT INTO return_orders (orID, detail) VALUES (?, ?)`,
+                    [OrID, reason]);
+            } else if (orderStatus === "Cancelled") {
+                console.log("Cancelled order");
+                // Process returned items
+                for (const item of returnedItems) {
+                    const detail = orderDetails.find(d => d.I_Id === item.itemId);
+
+                    if (detail) {
+                        let itemQty = parseFloat(item.qty) || 0;
+                        let detailQty = parseFloat(detail.qty) || 1;
+                        let itemTPrice = parseFloat(detail.tprice) || 0;
+
+                        if (detailQty === 0) {
+                            console.warn(`Warning: Item ${item.itemId} has zero quantity in order details! Skipping calculation.`);
+                            continue;
+                        }
+
+                        unitPrice = itemTPrice / detailQty;
+                        console.log("unit price "+unitPrice);
+                    } else {
+                        console.warn(`Item ${item.itemId} not found in order details.`);
+                    }
+
+                    await db.query(`UPDATE m_s_r_detail SET status = ?, datetime = NOW() WHERE stock_Id = ? AND I_Id = ?`,
+                        [item.status, item.stockId, item.itemId]);
+                }
+
+                newNetTotal = (parseFloat(netTotal) - parseFloat(unitPrice)) ;
+                NewTotal = (parseFloat(newNetTotal)- parseFloat(discount))+ parseFloat(delPrice);
+                newBalanceset = parseFloat(NewTotal) - updatedAdvance;
+                excessAmount = updatedAdvance - newNetTotal;
+                console.log("Total :"+total+" Balance :"+balance +" new net total :"+newNetTotal+" new advance :"+updatedAdvance)
+                console.log("New Total :"+NewTotal+" New Balance :"+newBalanceset+" Excess Amount : "+excessAmount)
+
+                await db.query(`UPDATE Orders SET advance = ?, balance = ?, total = ?, payStatus = ?, orStatus = ?, expectedDate = ? WHERE OrID = ?`,
+                    [updatedAdvance, newBalanceset, NewTotal, 'Credit', 'Cancelled', rescheduledDate, OrID]);
+                await db.query(`UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?`,
+                    [nowPayment, stID]);
+                await db.query(`INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())`,
+                    [OrID, nowPayment]);
+                await db.query(`UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?`,
+                    ["Cancelled", expectedDate, OrID]);
+                await db.query(`UPDATE Customer SET excessAmount = ? WHERE (contact1 = ? AND contact2 = ?) OR (contact1 = ? AND contact2 = ?)`,
+                    [excessAmount, contact1, contact2 , contact2,contact1]);
+                await db.query(`INSERT INTO canceled_orders (orID, detail) VALUES (?, ?)`,
+                    [OrID, reason]);
             }
 
             await db.query(`UPDATE delivery_note SET status = ? WHERE delNoID = ?`, ["Complete", deliveryNoteId]);
@@ -3786,7 +3967,6 @@
     }
 });
 
-
 // Function to generate new ida
 const generateNewId = async (table, column, prefix) => {
     const [rows] = await db.query(`SELECT ${column} FROM ${table} ORDER BY ${column} DESC LIMIT 1`);
